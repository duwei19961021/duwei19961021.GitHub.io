<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BLOG</title>
  
  
  <link href="https://duwei19961021.github.io/atom.xml" rel="self"/>
  
  <link href="https://duwei19961021.github.io/"/>
  <updated>2021-05-06T06:46:01.386Z</updated>
  <id>https://duwei19961021.github.io/</id>
  
  <author>
    <name>拦云</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nginx线程池</title>
    <link href="https://duwei19961021.github.io/2021/05/04/ngx_thread_pool/"/>
    <id>https://duwei19961021.github.io/2021/05/04/ngx_thread_pool/</id>
    <published>2021-05-03T16:43:27.000Z</published>
    <updated>2021-05-06T06:46:01.386Z</updated>
    
    <content type="html"><![CDATA[<h4 id="nginx线程池"><a href="#nginx线程池" class="headerlink" title="nginx线程池"></a>nginx线程池</h4><pre><code class="c++">// task链表struct ngx_thread_task_s {    ngx_thread_task_t   *next; // 指向下一个task结构    ngx_uint_t          id;    void                *ctx;    void                (*handler)(void *data, ngx_log_t *log); // 要执行的任务(函数指针)    ngx_event_t         event;};// 存取任务的数据结构(链表实现的队列)typedef struct {    ngx_thread_task_t        *first; // 队尾    ngx_thread_task_t       **last; // 队头} ngx_thread_pool_queue_t;struct ngx_thread_pool_s {    ngx_thread_mutex_t        mtx; // 互斥锁：其本质是 pthread_mutex_t，使用的pthread库    ngx_thread_pool_queue_t   queue; // 通过这个数据结构的两个指针，添加task，取task交给线程执行    ngx_int_t                 waiting;    ngx_thread_cond_t         cond; // 同步锁：其本质是 pthread_cond_t，使用的pthread库    ngx_log_t                *log;    ngx_str_t                 name;    ngx_uint_t                threads; // 线程池中线程的数量    ngx_int_t                 max_queue; // 队列中task最大数量    u_char                   *file;    ngx_uint_t                line;};</code></pre><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><ol><li><p>static ngx_int_t ngx_thread_pool_init(ngx_thread_pool_t *tp, ngx_log_t *log, ngx_pool_t *pool): 初始化线程池</p><pre><code class="c">static ngx_int_t  ngx_thread_pool_init(ngx_thread_pool_t *tp, ngx_log_t *log, ngx_pool_t *pool){    int             err;    pthread_t       tid; // 线程id ngx_uint_t      n; // 线程个数    pthread_attr_t  attr; // 设置线程属性的对象    if (ngx_notify == NULL) {        ngx_log_error(NGX_LOG_ALERT, log, 0,               &quot;the configured event method cannot be used with thread pools&quot;);        return NGX_ERROR;    }    ngx_thread_pool_queue_init(&amp;tp-&gt;queue); /*        #define ngx_thread_pool_queue_init(q)                                         \          (q)-&gt;first = NULL;                                                        \          (q)-&gt;last = &amp;(q)-&gt;first      初始化ngx_thread_pool_queue_t：空队列    */    if (ngx_thread_mutex_create(&amp;tp-&gt;mtx, log) != NGX_OK) {        return NGX_ERROR;    }    /*        ngx_int_t ngx_thread_mutex_create(ngx_thread_mutex_t *mtx, ngx_log_t *log)        {            ngx_err_t            err;            pthread_mutexattr_t  attr; // 设置互斥锁属性的结构            err = pthread_mutexattr_init(&amp;attr); // 初始化锁属性结构            if (err != 0) {                ngx_log_error(NGX_LOG_EMERG, log, err,                              &quot;pthread_mutexattr_init() failed&quot;);                return NGX_ERROR;            }            err = pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK);            // 通过：man pthread_mutexattr_settype 查询手册得知，这个函数功能是设置锁的类型。            // PTHREAD_MUTEX_ERRORCHECK：这种类型的互斥锁提供错误检查，一个线程试图重新锁            // 互斥锁而不首先解锁它将返回一个错误。试图解锁另一个线程已锁定的互斥锁的线程将返回            // 一个错误。一个线程尝试解锁已解锁的互斥锁将返回一个错误。            // 出现上述三种情况时就会范湖错误。            if (err != 0) {                ngx_log_error(NGX_LOG_EMERG, log, err,                              &quot;pthread_mutexattr_settype&quot;                              &quot;(PTHREAD_MUTEX_ERRORCHECK) failed&quot;);                return NGX_ERROR;            }            err = pthread_mutex_init(mtx, &amp;attr); // 这一步才是真正的初始化锁并给锁设置属性            if (err != 0) {                ngx_log_error(NGX_LOG_EMERG, log, err,                              &quot;pthread_mutex_init() failed&quot;);                return NGX_ERROR;            }            err = pthread_mutexattr_destroy(&amp;attr); // 销毁attr，属性已经设置完，可以释放            if (err != 0) {                ngx_log_error(NGX_LOG_ALERT, log, err,                              &quot;pthread_mutexattr_destroy() failed&quot;);            }            return NGX_OK;        }    */    if (ngx_thread_cond_create(&amp;tp-&gt;cond, log) != NGX_OK) { // 初始条件变量，如果初始化失败则线程池的初始化就是有问题的，之前创建的互斥锁资源需要释放        (void) ngx_thread_mutex_destroy(&amp;tp-&gt;mtx, log);        return NGX_ERROR;    }    /*      ngx_int_t ngx_thread_cond_create(ngx_thread_cond_t *cond, ngx_log_t *log)      {          ngx_err_t  err;          err = pthread_cond_init(cond, NULL);          if (err == 0) {              return NGX_OK;          }          ngx_log_error(NGX_LOG_EMERG, log, err, &quot;pthread_cond_init() failed&quot;);          return NGX_ERROR;      }    */    tp-&gt;log = log;    err = pthread_attr_init(&amp;attr); // 初始化给线程设置属性的结构    if (err) {        ngx_log_error(NGX_LOG_ALERT, log, err,                      &quot;pthread_attr_init() failed&quot;);        return NGX_ERROR;    }    err = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); // 线程分离，这种属性的线程在运行结束后会自动释放所有资源，无需等待，而无需使用pthread_join进行回收，避免阻塞主线程。这里仅仅初始化attr结构，并未真正意义上给线程设置属性。    if (err) {        ngx_log_error(NGX_LOG_ALERT, log, err,                      &quot;pthread_attr_setdetachstate() failed&quot;);        return NGX_ERROR;    }#if 0    err = pthread_attr_setstacksize(&amp;attr, PTHREAD_STACK_MIN);    if (err) {        ngx_log_error(NGX_LOG_ALERT, log, err,                      &quot;pthread_attr_setstacksize() failed&quot;);        return NGX_ERROR;    }#endif    for (n = 0; n &lt; tp-&gt;threads; n++) { // 创建n个线程        err = pthread_create(&amp;tid, &amp;attr, ngx_thread_pool_cycle, tp); // 线程执行的函数是ngx_thread_pool_cycle，给ngx_thread_pool_cycle函数的参数是tp        if (err) {            ngx_log_error(NGX_LOG_ALERT, log, err,                          &quot;pthread_create() failed&quot;);            return NGX_ERROR;        }    }    (void) pthread_attr_destroy(&amp;attr);    return NGX_OK;}</code></pre></li><li><p>static void * ngx_thread_pool_cycle(void *data)</p><pre><code class="c">static void *ngx_thread_pool_cycle(void *data){    ngx_thread_pool_t *tp = data; // 线程池指针    int                 err;    sigset_t            set; // 线程的信号集    ngx_thread_task_t  *task; // task组成队列（叫链表也行）中的元素，元素结构中有个函数指针，也就是要执行的任务函数的指针#if 0    ngx_time_update();#endif    ngx_log_debug1(NGX_LOG_DEBUG_CORE, tp-&gt;log, 0,                   &quot;thread in pool \&quot;%V\&quot; started&quot;, &amp;tp-&gt;name);    sigfillset(&amp;set); // 所有信号对应的bitmap上都设置为1    sigdelset(&amp;set, SIGILL); // 执行了非法指令    sigdelset(&amp;set, SIGFPE); // 发生致命的算数运算错误     sigdelset(&amp;set, SIGSEGV); // 段错误    sigdelset(&amp;set, SIGBUS); // 非法地址    err = pthread_sigmask(SIG_BLOCK, &amp;set, NULL); // 除了以上四个信号，其它信号都会被阻塞（blokc）    if (err) {        ngx_log_error(NGX_LOG_ALERT, tp-&gt;log, err, &quot;pthread_sigmask() failed&quot;);        return NULL;    }    for ( ;; ) {        if (ngx_thread_mutex_lock(&amp;tp-&gt;mtx, tp-&gt;log) != NGX_OK) {            // 给mtx上锁，如果mtx已经被锁了则会报错（因为之前设置过锁属性--PTHREAD_MUTEX_ERRORCHECK），这个线程执行结束，走到            // 这一步链表上的task并没有被取下来。如果线程获取task时发现task队列正有其它线程在从中获取任务则直接结束，不进行阻塞。            return NULL;        }          // 上锁成功，进入临界区！！！        /* the number may become negative */        tp-&gt;waiting--; // 上锁成功，休眠的线程数量减1        while (tp-&gt;queue.first == NULL) { // 如果task队列空（没有任务取），则进入阻塞状态，直到被唤醒            if (ngx_thread_cond_wait(&amp;tp-&gt;cond, &amp;tp-&gt;mtx, tp-&gt;log)                != NGX_OK)               // pthread_cond_wait函数在进入休眠时会将锁释放，重新被唤醒时再加锁。如果wait失败则锁不会被释放，所以在这里是用while而不是if，ngx_thread_cond_wait执行失败会释放锁            {                (void) ngx_thread_mutex_unlock(&amp;tp-&gt;mtx, tp-&gt;log); // 解锁                return NULL;            }        }        task = tp-&gt;queue.first;         tp-&gt;queue.first = task-&gt;next; // 取出一个task        if (tp-&gt;queue.first == NULL) { // 判断是否取完，取完则将task队列恢复至初始状态            tp-&gt;queue.last = &amp;tp-&gt;queue.first;        }        if (ngx_thread_mutex_unlock(&amp;tp-&gt;mtx, tp-&gt;log) != NGX_OK) { // 取到task之后是没必要等task中的任务执行完毕之后再释放锁，取出之后就可以立马释放锁了，让其它线程取，提高线程协作的效率。            return NULL;        }#if 0        ngx_time_update();#endif        ngx_log_debug2(NGX_LOG_DEBUG_CORE, tp-&gt;log, 0,                       &quot;run task #%ui in thread pool \&quot;%V\&quot;&quot;,                       task-&gt;id, &amp;tp-&gt;name);        task-&gt;handler(task-&gt;ctx, tp-&gt;log); // 此时可以执行task中的任务了        ngx_log_debug2(NGX_LOG_DEBUG_CORE, tp-&gt;log, 0,                       &quot;complete task #%ui in thread pool \&quot;%V\&quot;&quot;,                       task-&gt;id, &amp;tp-&gt;name);        task-&gt;next = NULL;        ngx_spinlock(&amp;ngx_thread_pool_done_lock, 1, 2048); // task执行完需要将task添加到done链表上去，添加这个操作执行的时间非常短，所以这里采用的自旋锁，提高效率，减少线程切换带来的开销。        *ngx_thread_pool_done.last = task; // 将task添加到链表末尾        ngx_thread_pool_done.last = &amp;task-&gt;next;        ngx_memory_barrier();        ngx_unlock(&amp;ngx_thread_pool_done_lock); // 解锁队列        (void) ngx_notify(ngx_thread_pool_handler); // 暂时没看懂，貌似和事件驱动模型有关    }}static voidngx_thread_pool_handler(ngx_event_t *ev){    ngx_event_t        *event;    ngx_thread_task_t  *task;    ngx_log_debug0(NGX_LOG_DEBUG_CORE, ev-&gt;log, 0, &quot;thread pool handler&quot;);    ngx_spinlock(&amp;ngx_thread_pool_done_lock, 1, 2048);    task = ngx_thread_pool_done.first;    ngx_thread_pool_done.first = NULL;    ngx_thread_pool_done.last = &amp;ngx_thread_pool_done.first;    ngx_memory_barrier();    ngx_unlock(&amp;ngx_thread_pool_done_lock);    while (task) {        ngx_log_debug1(NGX_LOG_DEBUG_CORE, ev-&gt;log, 0,                       &quot;run completion handler for task #%ui&quot;, task-&gt;id);        event = &amp;task-&gt;event;        task = task-&gt;next;        event-&gt;complete = 1;        event-&gt;active = 0;        event-&gt;handler(event);    }}</code></pre></li><li><p>ngx_thread_pool_t <strong>***ngx_thread_pool_add</strong>(<strong>ngx_conf_t ***</strong>cf<strong>,</strong> ngx_str_t *****name)：添加一个内存池</p><pre><code class="c">ngx_thread_pool_t *ngx_thread_pool_add(ngx_conf_t *cf, ngx_str_t *name){    ngx_thread_pool_t       *tp, **tpp;    ngx_thread_pool_conf_t  *tcf;    if (name == NULL) { // 如果没定义线程池的名字默认为 &quot;default&quot;        name = &amp;ngx_thread_pool_default;    }    tp = ngx_thread_pool_get(cf-&gt;cycle, name); // 先查找线程池的集合，判断其中是否已经创建过，有则直接返回其指针    if (tp) {        return tp;    }    tp = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_thread_pool_t)); // 在内存池上给线程池的结构申请内存    if (tp == NULL) {        return NULL;    }    tp-&gt;name = *name;    tp-&gt;file = cf-&gt;conf_file-&gt;file.name.data;    tp-&gt;line = cf-&gt;conf_file-&gt;line;    tcf = (ngx_thread_pool_conf_t *) ngx_get_conf(cf-&gt;cycle-&gt;conf_ctx,                                                  ngx_thread_pool_module);    tpp = ngx_array_push(&amp;tcf-&gt;pools);    if (tpp == NULL) {        return NULL;    }    *tpp = tp;    return tp;}</code></pre></li><li><p>ngx_thread_pool_t <strong>***ngx_thread_pool_get</strong>(<strong>ngx_cycle_t ***</strong>cycle<strong>,</strong> ngx_str_t *****name)：通过name获取内存池指针</p><pre><code class="c">ngx_thread_pool_t *ngx_thread_pool_get(ngx_cycle_t *cycle, ngx_str_t *name){    ngx_uint_t                i;    ngx_thread_pool_t       **tpp;    ngx_thread_pool_conf_t   *tcf;    tcf = (ngx_thread_pool_conf_t *) ngx_get_conf(cycle-&gt;conf_ctx,                                                  ngx_thread_pool_module);    tpp = tcf-&gt;pools.elts;    for (i = 0; i &lt; tcf-&gt;pools.nelts; i++) {        if (tpp[i]-&gt;name.len == name-&gt;len            &amp;&amp; ngx_strncmp(tpp[i]-&gt;name.data, name-&gt;data, name-&gt;len) == 0)        {            return tpp[i];        }    }    return NULL;}</code></pre></li><li><p>static void ngx_thread_pool_destroy<strong>(</strong>ngx_thread_pool_t *****tp)：销毁线程池</p><pre><code class="c">static voidngx_thread_pool_destroy(ngx_thread_pool_t *tp){    ngx_uint_t           n;    ngx_thread_task_t    task;    volatile ngx_uint_t  lock;    ngx_memzero(&amp;task, sizeof(ngx_thread_task_t));    task.handler = ngx_thread_pool_exit_handler; // 修改task的handler指针，指向退出线程的函数    task.ctx = (void *) &amp;lock;    for (n = 0; n &lt; tp-&gt;threads; n++) {        lock = 1;        if (ngx_thread_task_post(tp, &amp;task) != NGX_OK) { // 判断当前task是否能退出，能退出则会解锁lock            return;        }        while (lock) {            ngx_sched_yield();        }        task.event.active = 0;    }    (void) ngx_thread_cond_destroy(&amp;tp-&gt;cond, tp-&gt;log); // 销毁条件变量    (void) ngx_thread_mutex_destroy(&amp;tp-&gt;mtx, tp-&gt;log); // 销毁互斥锁}</code></pre></li><li><p>dddd</p><pre><code class="c">ngx_int_tngx_thread_task_post(ngx_thread_pool_t *tp, ngx_thread_task_t *task){    if (task-&gt;event.active) {        ngx_log_error(NGX_LOG_ALERT, tp-&gt;log, 0,                      &quot;task #%ui already active&quot;, task-&gt;id);        return NGX_ERROR;    }    if (ngx_thread_mutex_lock(&amp;tp-&gt;mtx, tp-&gt;log) != NGX_OK) {        return NGX_ERROR;    }    if (tp-&gt;waiting &gt;= tp-&gt;max_queue) {        (void) ngx_thread_mutex_unlock(&amp;tp-&gt;mtx, tp-&gt;log);        ngx_log_error(NGX_LOG_ERR, tp-&gt;log, 0,                      &quot;thread pool \&quot;%V\&quot; queue overflow: %i tasks waiting&quot;,                      &amp;tp-&gt;name, tp-&gt;waiting);        return NGX_ERROR;    }    task-&gt;event.active = 1;    task-&gt;id = ngx_thread_pool_task_id++;    task-&gt;next = NULL;    if (ngx_thread_cond_signal(&amp;tp-&gt;cond, tp-&gt;log) != NGX_OK) {        (void) ngx_thread_mutex_unlock(&amp;tp-&gt;mtx, tp-&gt;log);        return NGX_ERROR;    }    *tp-&gt;queue.last = task;    tp-&gt;queue.last = &amp;task-&gt;next;    tp-&gt;waiting++;    (void) ngx_thread_mutex_unlock(&amp;tp-&gt;mtx, tp-&gt;log);    ngx_log_debug2(NGX_LOG_DEBUG_CORE, tp-&gt;log, 0,                   &quot;task #%ui added to thread pool \&quot;%V\&quot;&quot;,                   task-&gt;id, &amp;tp-&gt;name);    return NGX_OK;}</code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;nginx线程池&quot;&gt;&lt;a href=&quot;#nginx线程池&quot; class=&quot;headerlink&quot; title=&quot;nginx线程池&quot;&gt;&lt;/a&gt;nginx线程池&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;// task链表
struct ngx_threa</summary>
      
    
    
    
    <category term="Nginx" scheme="https://duwei19961021.github.io/categories/Nginx/"/>
    
    
    <category term="thread_pool" scheme="https://duwei19961021.github.io/tags/thread-pool/"/>
    
  </entry>
  
  <entry>
    <title>c++继承</title>
    <link href="https://duwei19961021.github.io/2021/05/03/c++polymorphic/"/>
    <id>https://duwei19961021.github.io/2021/05/03/c++polymorphic/</id>
    <published>2021-05-03T04:17:03.000Z</published>
    <updated>2021-05-03T06:15:22.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><pre><code class="c++">#include &lt;iostream&gt;using namespace std;class Person{public:    virtual void ByTicket()    {        cout &lt;&lt; &quot;正常排队----全价格买票&quot; &lt;&lt; endl;    }};class Student: public Person{public:    virtual void ByTicket()    {        cout &lt;&lt; &quot;正常排队----半价格买票&quot; &lt;&lt; endl;    }};// 1、继承类中，虚函数的重写。//    重写的条件：//          a. 父子类中的函数都必须是虚函数。//          b. 函数名、参数、返回值都要相同。// 2、基类指针或者指针去调用这个虚函数。//    指向谁，调用谁的虚函数void Buy(Person&amp; p){      // 不满足多态：跟类型有关，也就是说p是什么类型，就调用这个类型的成员函数。      // 满足多态：跟对象有关，也就是说指向的是哪个对象就调用哪个的虚函数。    p.ByTicket();}int main(){    Person p;    Buy(p);    Student s;    Buy(s);    return 0;}</code></pre><h5 id="虚函数重写的两个例外"><a href="#虚函数重写的两个例外" class="headerlink" title="虚函数重写的两个例外"></a>虚函数重写的两个例外</h5><h6 id="1、协变"><a href="#1、协变" class="headerlink" title="1、协变"></a>1、协变</h6><p>基类与派生类虚函数返回值类型不同。</p><p>派生类重写基类虚函数时，与基类虚函数返回值类型不同。即基类虚函数返回基类对象的指针或引用，派生类虚函数返回派生类对象的指针或引用。</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;class A{};class B: public A{};class Person{public:    virtual A* ByTicket()    {        cout &lt;&lt; &quot;正常排队----全价格买票&quot; &lt;&lt; endl;        return new A;    }};class Student: public Person{public:    virtual B* ByTicket()    {        cout &lt;&lt; &quot;正常排队----半价格买票&quot; &lt;&lt; endl;        return new B;    }};void Buy(Person&amp; p){    p.ByTicket();}int main(){    Person p;    Buy(p);    Student s;    Buy(s);    return 0;}</code></pre><h6 id="2、析构函数的重写"><a href="#2、析构函数的重写" class="headerlink" title="2、析构函数的重写"></a>2、析构函数的重写</h6><p>基类与派生类的析构函数名不同</p><p>如果基类的析构函数为虚函数，此时派生类析构函数只要定义，无论是否加关键字virtual，都与基类的析构函数构成重写。虽然基类与派生类的析构函数名字不同，违背了重写的规则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名字统一处理成destructor。</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;class Person{public:    virtual ~Person()    {        cout &lt;&lt; &quot;~Person&quot; &lt;&lt; endl;    }};class Student: public Person{public:    ~Student()    {        cout &lt;&lt; &quot;~Student&quot; &lt;&lt; endl;    }};int main(){    /*    Person p1;    Student s1;output:    ~Student // s1后入栈后销毁，销毁时先调用自己的析构函数    ~Person // 因为Student继承了Person类，所以派生类在销毁时还需要调用父类的析构函数去销毁属于父类的那部分数据    ~Person // 最后调用父类的析构函数    */    /*    1、如果父子类的析构函数不构成多态    Person *p1 = new Person;    Person *p2 = new Student;    delete p1; // p1.destructor()    delete p2; // p2.destructor() // 不构成多态就会按照类型去调用output:    ~Person // 父类调用析构函数    ~Person    // 由于编译器的处理，析构函数名会被处理成destructor，delete父类指针，会调用父类的析构函数(屏蔽了子类函数的析构函数，它们是同名成员destructor)，此时Student类对象中属于父类的数据被析构函数销毁，但是子类的析构函数没有被调用，造成内存泄露。    */    /*    2、如果父子类的析构函数构成多态    Person *p1 = new Person;    Person *p2 = new Student;    delete p1;    delete p2;output:    ~Person // 父类析构    ~Student // delete时，调用对象对应的析构函数    ~Person    */    return 0;}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h4&gt;&lt;h5 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h5&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="C语言" scheme="https://duwei19961021.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="c++" scheme="https://duwei19961021.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++继承</title>
    <link href="https://duwei19961021.github.io/2021/04/25/c++inheritance/"/>
    <id>https://duwei19961021.github.io/2021/04/25/c++inheritance/</id>
    <published>2021-04-25T14:55:23.000Z</published>
    <updated>2021-05-03T04:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h5 id="1、什么是继承？"><a href="#1、什么是继承？" class="headerlink" title="1、什么是继承？"></a>1、什么是继承？</h5><p>继承是面向对象程序设计使代码可以复用的重要手段，允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生的新类叫派生类。继承是类设计层次的复用。</p><pre><code class="c++">class Person{public:    void speak()    {        ;    }    void sleep()    {        ;    }public:    int age;    string name;private:    float weight;};class boy: public Person{};class girl: public Person{};</code></pre><p>boy类和girl类都具有speak()、sleep()行为，以及年龄、名字属性，它们都可以从Person类中继承，而没有必要在他们自己的类中再次声明定义。在这个例子中：Person类称为父类或者基类，boy、girl类称为子类或者派生类。</p><h5 id="2、继承定义"><a href="#2、继承定义" class="headerlink" title="2、继承定义"></a>2、继承定义</h5><h6 id="继承关系和访问限定符"><a href="#继承关系和访问限定符" class="headerlink" title="继承关系和访问限定符"></a>继承关系和访问限定符</h6><p>继承方式：</p><ul><li>public 继承</li><li>protected 继承</li><li>private 继承</li></ul><h6 id="继承父类，子类访问父类成员的变化。"><a href="#继承父类，子类访问父类成员的变化。" class="headerlink" title="继承父类，子类访问父类成员的变化。"></a>继承父类，子类访问父类成员的变化。</h6><table><thead><tr><th align="left">类成员/继承方式</th><th align="center">public继承</th><th align="center">protected继承</th><th align="center">private继承</th></tr></thead><tbody><tr><td align="left">基类的public成员</td><td align="center">派生类的public成员</td><td align="center">派生类的protected成员</td><td align="center">派生类的private成员</td></tr><tr><td align="left">基类的protected成员</td><td align="center">派生类的protected成员</td><td align="center">派生类的protected成员</td><td align="center">派生类的private成员</td></tr><tr><td align="left">基类的private成员</td><td align="center">在派生类中不可见</td><td align="center">在派生类中不可见</td><td align="center">在派生类中不可见</td></tr></tbody></table><p>1、在子类中的访问方式 = min(基类访问方式，继承方式)。</p><p>2、基类private成员，在子类中不可见。(不可见，但是任然被继承)。</p><pre><code class="c++">#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;class Person{public:    void speak()    {        ;    }    void sleep()    {        ;    }public:    int age;    string name;private:    float weight;};class boy: public Person{};class girl: public Person{};int main(){    cout &lt;&lt; &quot;sizeof(Person) = &quot; &lt;&lt; sizeof(Person) &lt;&lt; endl; // 24    cout &lt;&lt; &quot;sizeof(boy) = &quot; &lt;&lt; sizeof(boy) &lt;&lt; endl; // 24    cout &lt;&lt; &quot;sizeof(girl) = &quot; &lt;&lt; sizeof(girl) &lt;&lt; endl; // 24      // Person、boy、girl类的大小相同    boy b;    cout &lt;&lt; b.Person::weight &lt;&lt; endl; // error,父类的private成员，派生类无法访问    return 0;}</code></pre><h4 id="基类和派生类对象赋值转换（只存在于public继承）"><a href="#基类和派生类对象赋值转换（只存在于public继承）" class="headerlink" title="基类和派生类对象赋值转换（只存在于public继承）"></a>基类和派生类对象赋值转换（只存在于public继承）</h4><ul><li>派生类可以赋值给 基类的对象 / 基类的指针 / 基类的引用，有个形象的说法叫做切片或者切割。</li><li>基类对象不能赋值给派生类对象。</li><li>基类的指针可以通过强制类型转换赋值给派生类的指针，但是必须是基类的指针是指向派生类对象时才是安全的。</li></ul><p><img src="https://img.3amupupup.online/CppInheritance.png" alt="切片"></p><pre><code class="c++">#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;class Person{public:    Person()    {        _name = &quot;duwei&quot;;        _sex = &quot;man&quot;;        _age = 24;    }public:    string _name;    string _sex;    int _age;};class Student: public Person{public:    int _No;};int main(){    Person p;    Student stu;    p = stu;      cout &lt;&lt; p._name &lt;&lt; &quot;,&quot; &lt;&lt; p._sex &lt;&lt; &quot;,&quot; &lt;&lt; p._age &lt;&lt; endl; // duwei,man,24    cout &lt;&lt; p._NO &lt;&lt; endl; // 错误：‘class Person’没有名为‘_NO’的成员。如图所示，发生了切片    return 0;}</code></pre><h5 id="3、继承中的作用域"><a href="#3、继承中的作用域" class="headerlink" title="3、继承中的作用域"></a>3、继承中的作用域</h5><blockquote><ol><li><p>在继承体系中基类和派生类都有独立的作用域。</p></li><li><p>子类和父类中存在同名成员，子类成员将屏蔽对父类中同名成员的直接访问，这种情况叫隐藏，也叫重定义。</p><pre><code class="c++">#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;class Person{public:    string _name = &quot;duwei&quot;;    int _age = 24;    string _city = &quot;hz&quot;;};class Student:public Person{public:    string _name = &quot;zhangsan&quot;;    int _age = 25;    string _home = &quot;hunan&quot;;};int main(){    Student stu;    cout &lt;&lt; stu._name &lt;&lt; endl; // zhangsan    cout &lt;&lt; stu.Person::_name &lt;&lt; endl; // duwei 如果需要访问父类中的同名成员，需要加上作用域。    return 0;}</code></pre></li><li><p>如果是成员函数的隐藏，只需要函数名相同就构成隐藏。</p></li><li><p>在实际继承体系中，最好不要定义同名的成员。</p></li></ol></blockquote><h5 id="4、派生类的默认成员函数"><a href="#4、派生类的默认成员函数" class="headerlink" title="4、派生类的默认成员函数"></a>4、派生类的默认成员函数</h5><ol><li><p>派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。<strong>如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段显示调用。</strong></p><pre><code class="c++">#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;class Person{public:    Person()    {        _name = &quot;duwei&quot;;        _sex = &quot;man&quot;;        _age = 24;    }public:    string _name;    string _sex;    int _age;};class Student: public Person{public:    Student(int No)    : Person() // 继承下来的父类部分成员，要使用父类的构造函数去初始化，不能自己显示的初始化。    , _No(No)    {}public:    int _No;};int main(){    Student s(20);    cout &lt;&lt; s._name &lt;&lt; &quot;,&quot; &lt;&lt; s._sex &lt;&lt; &quot;,&quot; &lt;&lt; s._age &lt;&lt; endl; // duwei,man,24    cout &lt;&lt; s._No &lt;&lt; endl; // 20    return 0;}</code></pre></li><li><p>派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化。</p><pre><code class="c++">#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;class Person{public:   Person()   {       _name = &quot;duwei&quot;;       _sex = &quot;man&quot;;       _age = 24;   }public:   string _name;   string _sex;   int _age;};class Student: public Person{public:   Student(int No)   : Person()   , _No(No)   {}   Student(const Student &amp;s)   : Person(s) // 存在切片行为，派生类对象赋值给基类对象   , _No(s._No)   {}public:   int _No;};int main(){   Student s(20);   Student s2(s);   return 0;}</code></pre></li><li><p>派生类的operator=必须要调用基类的operator=完成基的复制。</p><pre><code class="c++">#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;class Person{public:    Person()    {        _name = &quot;duwei&quot;;        _sex = &quot;man&quot;;        _age = 24;    }public:    string _name;    string _sex;    int _age;};class Student: public Person{public:    Student(int No)    : Person()    , _No(No)    {}    Student(const Student &amp;s)    : Person(s)    , _No(s._No)    {}    Student&amp; operator=(const Student &amp;s)    {        if(this != &amp;s)        {            Person::operator=(s); // 需要加上作用域，否则会和子类中的 operator= 产生歧义            _No = s._No;        }        return *this;    }public:    int _No;};int main(){    Student s(20);    Student s2(s);    Student s3 = s2;    return 0;}</code></pre></li><li><p>派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员。因为这样才能保证派生对象先清理派生类成员再清理基类成员的顺序。（先创建的后销毁）</p></li><li><p>派生类对象初始化先调用基类构造再调派生类构造。</p></li><li><p>派生类对象析构清理先调用派生类析构再调基类的析构。</p></li></ol><h5 id="5、继承与友元"><a href="#5、继承与友元" class="headerlink" title="5、继承与友元"></a>5、继承与友元</h5><p>友元关系不能继承，也就是说基类友元不能访问子类私有和保护成员。</p><h5 id="6、继承和静态成员"><a href="#6、继承和静态成员" class="headerlink" title="6、继承和静态成员"></a>6、继承和静态成员</h5><p>基类定义了static静态成员，则整个继承体系里面只有一个这样的成员。无论派生出多少个子类，都只有一 个static成员实例 。</p><h5 id="7、菱形继承"><a href="#7、菱形继承" class="headerlink" title="7、菱形继承"></a>7、菱形继承</h5><h6 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h6><p>一个子类只有一个直接父类时称这个继承关系为单继承。</p><p>![单继承](../Library/Application Support/typora-user-images/image-20210429205858101.png)</p><h6 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h6><p>一个子类有两个或以上直接父类时称这个继承关系为多继承。</p><p>![多继承](../Library/Application Support/typora-user-images/image-20210429210815054.png)</p><h6 id="棱形继承"><a href="#棱形继承" class="headerlink" title="棱形继承"></a>棱形继承</h6><p>多继承的特殊情况</p><p>![棱形继承](../Library/Application Support/typora-user-images/image-20210429210855540.png)</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person{public:    string name;};class Teacher : public Person{    int _id; // 职工编号};class Student : public Person{public:    int _num; // 学号};class Assistant:public Student, public Teacher{    string _course; // 课程名};int main(){    Assistant a;    // a.name = &quot;duwei&quot;; // 错误：对成员‘name’的请求有歧义    a.Student::name = &quot;duwei&quot;; // 指定父类可以解决二义性，但是数据会存在冗余    a.Teacher::name = &quot;duwei&quot;;    return 0;}</code></pre><h6 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h6><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person{public:    string name;};class Teacher : virtual public Person{    int _id; // 职工编号};class Student : virtual public Person{public:    int _num; // 学号};class Assistant:public Student, public Teacher{    string _course; // 课程名};int main(){    Assistant a;    a.name = &quot;duwei&quot;;    cout &lt;&lt; a.name &lt;&lt; endl; // duwei    a.Student::name = &quot;zhangsan&quot;;    cout &lt;&lt; a.name &lt;&lt; endl; // zhangsan    a.Teacher::name = &quot;lisi&quot;;    cout &lt;&lt; a.name &lt;&lt; endl; // lisi    return 0;}</code></pre><h6 id="虚拟继承分析"><a href="#虚拟继承分析" class="headerlink" title="虚拟继承分析"></a>虚拟继承分析</h6><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class A{public:    int _a;};class B : public A{public:    int _b;};class C : public A{public:    int _c; // 学号};class D: public B, public C{public:    int _d;};int main(){    D d;    cout &lt;&lt; sizeof(d) &lt;&lt; endl;    d.B::_a = 1;    d.C::_a = 2;    d._b = 3;    d._d = 4;    return 0;}</code></pre><p>![image-20210429225636867](../Library/Application Support/typora-user-images/image-20210429225636867.png)</p><p>借助Clion查看d对象在内存上的结构：</p><p>其中成员 _a 各自一份的，类继承之后的存储和结构体成员的存储类似。</p><p>![image-20210429231041888](../Library/Application Support/typora-user-images/image-20210429231041888.png)</p><p>使用虚拟继承之后只有一份公共的虚基类成员 A，解决了数据冗余和二义性 </p><p>![image-20210502155450341](../Library/Application Support/typora-user-images/image-20210502155450341.png)</p><blockquote><p>set p pertty &lt;on/off&gt;: 按照层次打印结构体</p><p>set p obj &lt;on/off&gt;: 在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是off。 使用show print object查看对象选项的设置。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h4&gt;&lt;h5 id=&quot;1、什么是继承？&quot;&gt;&lt;a href=&quot;#1、什么是继承？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是继承？&quot;</summary>
      
    
    
    
    <category term="C语言" scheme="https://duwei19961021.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="c++" scheme="https://duwei19961021.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>thread</title>
    <link href="https://duwei19961021.github.io/2021/04/20/thread/"/>
    <id>https://duwei19961021.github.io/2021/04/20/thread/</id>
    <published>2021-04-20T09:02:24.000Z</published>
    <updated>2021-05-05T13:03:34.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h5><ul><li>在一个程序里的一个执行路线就叫做线程。更准确的定义是：线程是“一个进程的内部序列”。</li><li>一个进程至少有一个线程。</li><li>线程在进程内部运行，本质是在进程地址空间运行。</li><li>透过进程虚拟地址空间，可以看到进程大部分的资源，将进程资源合理的分配给每个执行流，就形成了线程执行流。</li></ul><p>进程：承担系统分配资源的基本实体。为了承担资源操作系统为进程提供了大批数据结构和内存块，以承担程序的数据和代码。</p><p>线程：调度的基本单位，是进程内部的执行流。（线程在进程的地址空间内运行）</p><h5 id="线程优点"><a href="#线程优点" class="headerlink" title="线程优点"></a>线程优点</h5><ul><li><p>创建一个新线程的代价比创建一个新进程代价要小的多。</p><p>进程是承担系统分配资源的基本实体，只有当资源创建好了，这个进程才算是被创建好；而线程只需要创建一个pcb，然后将已分配的部分资源指派给线程就好了。</p></li><li><p>与进程之间的切换相比，线程之间切换需要操作系统做的工作要少很多。（地址空间、页表不需要更换，只需要更换tss）</p><p>线程切换理论上只需要切换tss。线程只对应了进程部分资源。</p></li><li><p>线程占用的资源少</p></li><li><p>能充分利用多处理器的可并行数量</p></li><li><p>在等待慢I/O操作结束时，程序可执行其它计算任务。</p></li><li><p>计算密集型应用，为了能在多处理器系统上运行，将计算分割到多个线程中实现</p></li><li><p>I/O密集应用，为了提高性能，将I/O操作重叠，线程可以同时等待不同的I/O操作。</p></li></ul><h5 id="线程有点"><a href="#线程有点" class="headerlink" title="线程有点"></a>线程有点</h5><ul><li><p>性能损失</p><p>一个很少被外部事件阻塞的计算密集型线程往往无法与其它线程共享一个处理器。如果计算密集型线程的数量比可用处理器多，那么可能会有较大的性能损失，这里性能的损失指的是增加了额外的同步和调度开销，而可用的资源不变。</p></li><li><p>健壮性降低</p><p>编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的偏差或者共享了不该共享的变量而造成的不良影响的可能性是很大的，换句话说线程之间缺乏保护。</p></li><li><p>缺乏访问控制</p><p>进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响。</p></li><li><p>编程难度提高</p></li></ul><h5 id="线程异常"><a href="#线程异常" class="headerlink" title="线程异常"></a>线程异常</h5><p>线程时进程的执行分支，线程出现异常，就类似进程出现异常，进而触发信号机制，终止进程，进程终止，该进程内的所有线程也就随即退出。</p><h5 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h5><ul><li>进程是资源分配的基本单位</li><li>线程时调度的基本单位</li><li>线程共享进程数据，但也拥有自己的一部分数据：<ul><li>线程ID</li><li>*一组寄存器(独立的硬件上下文)</li><li>*栈</li><li>errno</li><li>信号屏蔽字</li><li>调度优先级</li></ul></li></ul><h5 id="进程的多个线程共享"><a href="#进程的多个线程共享" class="headerlink" title="进程的多个线程共享"></a>进程的多个线程共享</h5><p>同一地址空间，因此Text Segment(代码段)、Data Segment(数据区)都是共享的，如果定义一个函数，在各线程中都可以调用，如果定义一个全局变量，在各个线程中都可以访问，除此之外，线程还共享以下进程资源和环境：</p><ul><li>文件描述符</li><li>每种信号的处理方式(SIG_IGN、SIG_DFL)</li><li>当前工作目录</li><li>用户id和组id</li></ul><h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><h6 id="牛刀小试"><a href="#牛刀小试" class="headerlink" title="牛刀小试"></a>牛刀小试</h6><pre><code class="c">#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;void *thread_run(void *arg){    while(1)    {        printf(&quot;I am %s\n&quot;, (char*)arg);        sleep(1);    }}int main(){    pthread_t tid;    int ret = pthread_create(&amp;tid, NULL, thread_run, (void*)&quot;thread 1&quot;); // 创建线程，成功返回0，失败返回相对应的错误码。    while(1)    {        printf(&quot;I am thread!\n&quot;);        sleep(2);    }}</code></pre><pre><code class="shell">☁  ~  ps aux |grep testroot     27491  0.0  0.0  14568   380 pts/0    Sl+  21:41   0:00 ./test☁  ~  ps -alF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD0 S     0 27491 26311  0  80   0 -  3642 hrtime pts/0    00:00:00 test0 R     0 27537 27501  0  80   0 - 38265 -      pts/1    00:00:00 ps☁  ~  ps -aL  PID   LWP TTY          TIME CMD27491 27491 pts/0    00:00:00 test27491 27492 pts/0    00:00:00 test27543 27543 pts/1    00:00:00 ps# LWP ———— 轻量级进程</code></pre><h6 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h6><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;void* thread_run(void* arg){    while(1)    {        printf(&quot;thread 1: %lu, pid: %d\n&quot;,pthread_self(), getpid());        sleep(1);    }//    pthread_exit((void*)99); // 终止线程//    return (void*)10;}int main(){    pthread_t tid;    int i;    pthread_create(&amp;tid, NULL, thread_run, &quot;thread 1&quot;);    while(1)    {        printf(&quot;main thread: %lu, pid: %d\n&quot;,pthread_self(), getpid());        sleep(10);        break;    }    pthread_cancel(tid); // 使线程退出    void* ret = NULL;    pthread_join(tid, &amp;ret); // 获取线程的退出码    printf(&quot;thread return number: %d\n&quot;, (long long)ret);    return 0;}</code></pre><h6 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h6><blockquote><ul><li>默认情况下，新创建的进程是joinable的，线程退出后，需要对其进行pthread_join操作，否则无法释放资源，从而导致系统资源泄露。</li><li>如果不关心线程的返回值，join是一种负担，这个时候可以告诉操作系统，当线程退出时，自动释放线程资源。</li></ul></blockquote><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;void* thread_run(void* arg){    pthread_detach(pthread_self());    while(1)    {        printf(&quot;thread 1: %lu, pid: %d\n&quot;,pthread_self(), getpid());        sleep(1);        break;    }    return (void*)10;}int main(){    pthread_t tid;    int i;    pthread_create(&amp;tid, NULL, thread_run, &quot;thread 1&quot;);    while(1)    {        printf(&quot;main thread: %lu, pid: %d\n&quot;,pthread_self(), getpid());        sleep(1);        break;    }    pthread_cancel(tid);    void* ret = NULL;    pthread_join(tid, &amp;ret);    printf(&quot;thread return number: %d\n&quot;, (long long)ret);    return 0;}/*  main thread: 140614304589568, pid: 9352  thread 1: 140614296327936, pid: 9352  thread return number: 0*/</code></pre><h6 id="多线程抢票"><a href="#多线程抢票" class="headerlink" title="多线程抢票"></a>多线程抢票</h6><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#define N 10int tickets = 10000;pthread_mutex_t lock;void* get(void* arg){    usleep(1000);    int num = (int)arg;    while(1)    {        usleep(100);        pthread_mutex_lock(&amp;lock);        if(tickets &gt; 0)        {            printf(&quot;thread %d get ticket: %d\n&quot;, num, tickets);            tickets--;            pthread_mutex_unlock(&amp;lock);        }        else        {            pthread_mutex_unlock(&amp;lock);            break;        }    }}int main(){    pthread_mutex_init(&amp;lock, NULL);    int i;    pthread_t arr[N];    for(i = 0; i &lt; N; i++)    {        pthread_create(arr+i, NULL, get, (void*)i);    }    for(i = 0; i &lt; N; i++)    {        pthread_join(arr[i], NULL);    }    pthread_mutex_destroy(&amp;lock);    return 0;}</code></pre><h6 id="锁的本质"><a href="#锁的本质" class="headerlink" title="锁的本质"></a>锁的本质</h6><ol><li><p>对临界区进行保护，所有执行的线程都必须遵守这个规则。</p></li><li><p>lock -&gt; 访问临界区 -&gt; unlock。</p></li><li><p>所有线程必须看到同一把锁，所以说：锁本身就是临界资源！锁必须保证自身安全！申请锁的过程，不能有中间状态，lock -&gt; 原子性，unlock -&gt; 原子性。</p></li><li><p>lock -&gt; 访问临界区(花时间) -&gt; unlock，在特定线程/进程拥有锁的时候，期间有新线程/进程过来申请锁，一定申请不到！新线程该如何？阻塞，本质：将进程/线程对应的pcb投入到操作系统的进程等待队列，unlock之后进行进程/线程的唤醒操作！</p></li><li><p>如何理解锁</p><pre><code class="c">struct mutex{    int lock; // 0/1    wait_queue *head;    ...}</code></pre></li><li><p>对锁的相关操作</p><pre><code class="c">pthread_mutex_init：初始化锁pthread_mutex_destroy：释放锁，锁也是资源pthread_mutex_unlock：上锁pthread_mutex_unlock：解锁</code></pre></li><li><p>一次保证只有一个线程进入临界区，访问临界资源，就叫做互斥。</p></li><li><p>加锁为什么一般效率比较低，或者影响效率？所有任务都串行了；线程切换会带来cpu的消耗，上下文切换。</p></li></ol><h6 id="互斥量本质研究"><a href="#互斥量本质研究" class="headerlink" title="互斥量本质研究"></a>互斥量本质研究</h6><blockquote><p>为了实现互斥锁，大多数体系结构都提供了swap或者exchange指令，该指令的作用是把寄存器和内存单元数据交换，由于只有一条指令，保证了原子性。</p></blockquote><pre><code>lock:    move $0, $al    xchgb $al, mutex    if(al &gt; 0)    {        return 0;    }    else    {        挂起等待;    }    goto lock;    unlock:        move $1, mutex        唤醒等待mutex线程        return 0;</code></pre><h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><h6 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h6><blockquote><ul><li>当一个线程互斥的访问某个变量时，它可能发现在其它线程改变状态之前，什么也做不了。</li><li>例如一个线程访问队列时，当它发现队列为空，它只能等待，直到其它线程将数据添加到队列中。这种情况需要用到条件变量，当它发现队列为空时应当去通知生产者往队列里投放数据。</li></ul></blockquote><h6 id="同步概念与竞态条件"><a href="#同步概念与竞态条件" class="headerlink" title="同步概念与竞态条件"></a>同步概念与竞态条件</h6><blockquote><p>同步：在保证数据安全的前提下，让线程能够按照某种特定的顺序访问临界资源，从而有效避免饥饿问题，叫做同步。</p><p>竞态条件：因为时序问题而导致程序异常，称之为竞态条件。</p></blockquote><h6 id="为什么要同步？"><a href="#为什么要同步？" class="headerlink" title="为什么要同步？"></a>为什么要同步？</h6><p>互斥能够保证线程之间访问资源不出错，但是不能保证高效。同步的目的是让多线程同步高效的完成某些任务。</p><ol><li>如果条件不满足，等待，释放锁</li><li>通知机制</li></ol><h6 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h6><pre><code class="c">// 初始化条件变量int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);// 销毁条件变量int pthread_cond_destroy(pthread_cond_t *cond);// 等待条件满足int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);// 通知cond条件下wait的线程int pthread_cond_signal(pthread_cond_t *cond);</code></pre><h6 id="牛刀小试-1"><a href="#牛刀小试-1" class="headerlink" title="牛刀小试"></a>牛刀小试</h6><pre><code class="c">#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;pthread_cond_t cond;pthread_mutex_t lock;void* thread_run1(void* arg){    const char* name = (char*)arg;    while(1)    {        pthread_cond_wait(&amp;cond, &amp;lock); // 程序执行到这里，使当前线程加入cond结构下的某个成员里，猜测是个数组或者链表        printf(&quot;%s, activing....\n&quot;,name);        printf(&quot;\n&quot;);    }}void* thread_run2(void* arg){    const char* name = (char*)arg;    while(1)    {        sleep(1);        pthread_cond_signal(&amp;cond); // 唤醒cond条件下等待的线程。（个人理解：从cond结构的某个成员里取出一个线程进行唤醒）        printf(&quot;%s, signal to thread1 done....\n&quot;,name);        printf(&quot;\n&quot;);    }}int main(){    pthread_t t1,t2;    pthread_cond_init(&amp;cond, NULL);    pthread_mutex_init(&amp;lock, NULL);    pthread_create(&amp;t1, NULL, thread_run1, (void *)&quot;thread 1&quot;);    pthread_create(&amp;t2, NULL, thread_run2, (void *)&quot;thread 2&quot;);    pthread_join(&amp;t1, NULL);    pthread_join(&amp;t2, NULL);    return 0;}</code></pre><h6 id="基于阻塞队列的生产消费模型"><a href="#基于阻塞队列的生产消费模型" class="headerlink" title="基于阻塞队列的生产消费模型"></a>基于阻塞队列的生产消费模型</h6><pre><code class="c">#ifndef __BLOCK_QUEUE_H__#define __BLOCK_QUEUE_H__#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;pthread.h&gt;template&lt;class T&gt;class BlockQueue{public:    BlockQueue(size_t cap = 5): _cap(cap)    {        pthread_mutex_init(&amp;lock, nullptr);        pthread_cond_init(&amp;c_cond, nullptr);        pthread_cond_init(&amp;p_cond, nullptr);    }    ~BlockQueue()    {        pthread_mutex_destroy(&amp;lock);        pthread_cond_destroy(&amp;c_cond);        pthread_cond_destroy(&amp;p_cond);    }    void Put(T &amp;data)    {        LockQueue();        while(Full())        {            WakeUpCon();            ProWait();        }        q.push(data);        unLockQueue();    }    void Get(T &amp;data)    {        LockQueue();        while(Empty())        {            WakeUpPro(); // 先唤醒生产者            ConWait(); // 再休眠消费者        }        data = q.front();        q.pop();        unLockQueue();    }private:    void ProWait()    {        pthread_cond_wait(&amp;p_cond, &amp;lock);        /*         * 1、为什么要等？条件不满足         * 2、怎么知道条件是否满足？要判断是否满足条件就必须进入临界区，需要持有锁进入         * 3、如果条件不满足就需要阻塞等待，但是不能持有锁去等待！！！(锁被你拿着，其它线程无法获取锁就无法进入临界区，条件就无法发生改变，因此进入死锁状态)，因此wait时必须释放锁。         * 4、因此这个函数需要传入一个lock         *         * 1、在调用该函数时会自动释放锁。         * 2、当该函数返回时，返回到了临界区内，所以该函数会让该线程重新持有该锁。         */    }    void ConWait()    {        pthread_cond_wait(&amp;c_cond, &amp;lock);    }    void WakeUpPro()    {        pthread_cond_signal(&amp;p_cond);        std::cout &lt;&lt; &quot;signal productor&quot; &lt;&lt; std::endl;    }    void WakeUpCon()    {        pthread_cond_signal(&amp;c_cond);        std::cout &lt;&lt; &quot;signal consumer&quot; &lt;&lt; std::endl;    }    bool Empty()    {        return q.empty();    }    bool Full()    {        return q.size() == _cap;    }    void LockQueue()    {        pthread_mutex_lock(&amp;lock);    }    void unLockQueue()    {        pthread_mutex_unlock(&amp;lock);    }private:    pthread_mutex_t lock;    pthread_cond_t c_cond; // 消费者在该条件下等    pthread_cond_t p_cond; // 生产者在该条件下等    std::queue&lt;T&gt; q;    size_t _cap;};#endif</code></pre><pre><code class="c">#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &quot;BlockQueue.hpp&quot;#include &lt;stdlib.h&gt;using namespace std;void* Pro_run(void *arg){    BlockQueue&lt;int&gt; *q = (BlockQueue&lt;int&gt;*)arg;    while(true)    {        int data = rand()%110;        q-&gt;Put(data);        cout &lt;&lt; &quot;Pro put: &quot; &lt;&lt; data &lt;&lt; endl;        sleep(1);    }}void* Con_run(void *arg){    BlockQueue&lt;int&gt; *q = (BlockQueue&lt;int&gt;*)arg;    while(true)    {        int data = 0;        q-&gt;Get(data);        cout &lt;&lt; &quot;Con get: &quot; &lt;&lt; data &lt;&lt; endl;    }}int main(){    pthread_t con,pro;    BlockQueue&lt;int&gt; *bq = new BlockQueue&lt;int&gt;(10);    pthread_create(&amp;pro, nullptr, Pro_run, (void*)bq);    pthread_create(&amp;con, nullptr, Con_run, (void*)bq);    pthread_join(con, nullptr);    pthread_join(pro, nullptr);    delete bq;    return 0;}</code></pre><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><h6 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h6><p>信号量本质是一个计数器，描述临界资源有效个数的计数器。（保证每次访问的临界资源不是同一个）</p><p>允许多个线程操作临界区内的多个资源。</p><pre><code class="c">int count = 5;count--; // p() 原子性count++; // v() 原子性// 临界资源可以看成是多份的，不冲突的，提高效率</code></pre><h6 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h6><p>临界资源可以看成多份且不冲突的，信号量本质就是多份资源的计数器。</p><pre><code class="c">struct sem{    int count;    mutex lock;    wait_queue *head;}void P(){    lock();    if(count &gt; 0)    {        count--;    }    else    {        wait();    }    unlock();}</code></pre><h6 id="相关函数-1"><a href="#相关函数-1" class="headerlink" title="相关函数"></a>相关函数</h6><pre><code class="c">#include &lt;semaphore.h&gt;// 初始化信号量int sem_init(sem_t *sem, int pshared, unsigned int value); // pshared：0表示线程间共享，1表示进程间共享。value：信号量初始值// 销毁信号量int sem_destroy(sem_t *sem);// 等待信号量，会将信号量的值减1，P()int sem_wait(sem_t *sem);// 发布信号量，表示资源使用完毕，可以归还了。将信号量值加1，V()int sem_post(sem_t *sem)</code></pre><h6 id="基于环形队列的生产消费者模型"><a href="#基于环形队列的生产消费者模型" class="headerlink" title="基于环形队列的生产消费者模型"></a>基于环形队列的生产消费者模型</h6><p><img src="https://img.3amupupup.online/circle_queue_by_semaphore.png" alt="环形队列"></p><pre><code class="c">#include &lt;vector&gt;#include &lt;semaphore.h&gt;template&lt;class T&gt;class RingQueue{public:    RingQueue(size_t cap = 10):_v(cap)    {        p_index = c_index = 0;        _max_cap = cap;        sem_init(&amp;sem_data, 0, 0);        sem_init(&amp;sem_blank, 0, _max_cap);    }    ~RingQueue()    {        sem_destroy(&amp;sem_data);        sem_destroy(&amp;sem_blank);        p_index = 0;        c_index = 0;    }    void Get(T &amp;out)    {        P(sem_data); // 取数据时，要将数据对应的信号量减1        out = _v[c_index];        c_index++;        c_index %= _max_cap; // 数据减1时对应的装数据的格子增1        V(sem_blank);    }    void Put(T &amp;in)    {        P(sem_blank);        _v[p_index] = in;        p_index++;        p_index %= _max_cap;        V(sem_data);    }private:    void P(sem_t &amp;s)    {        sem_wait(&amp;s);    }    void V(sem_t &amp;s)    {        sem_post(&amp;s);    }private:    std::vector&lt;T&gt; _v;    size_t _max_cap;    sem_t sem_data;    sem_t sem_blank;    size_t p_index;    size_t c_index;};</code></pre><pre><code class="c">#include &quot;RingQueue.hpp&quot;#include &lt;iostream&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;using namespace std;void* Productor(void *arg){    RingQueue&lt;int&gt; *q = (RingQueue&lt;int&gt;*)arg;    while(true)    {        int data = rand() % 100;        q-&gt;Put(data);        cout &lt;&lt; &quot;Productor Put data: &quot; &lt;&lt; data &lt;&lt; endl;    }}void* Consumer(void *arg){    RingQueue&lt;int&gt; *q = (RingQueue&lt;int&gt;*)arg;    while(true)    {        int data;        q-&gt;Get(data);        cout &lt;&lt; &quot;Consumer Get data: &quot; &lt;&lt; data &lt;&lt; endl;        sleep(1);    }}int main(){    RingQueue&lt;int&gt; *rq = new RingQueue&lt;int&gt;;    pthread_t pro, con;    pthread_create(&amp;pro, nullptr, Productor, (void*)rq);    pthread_create(&amp;con, nullptr, Consumer, (void*)rq);    pthread_join(pro, nullptr);    pthread_join(con, nullptr);    return 0;}</code></pre><h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><pre><code class="c++">#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;pthread.h&gt;#include &lt;cmath&gt;#include &lt;unistd.h&gt;class Task{public:    int base;public:    Task() = default;    Task(int num): base(num){}    void Run()    {        std::cout &lt;&lt; &quot;thread id[&quot; &lt;&lt; pthread_self() &lt;&lt;&quot;]&quot; &lt;&lt; &quot;thread run done...... : base# &quot; &lt;&lt; base &lt;&lt; &quot; pow is # &quot; &lt;&lt; pow(base, 2)  &lt;&lt; std::endl;        usleep(100);    }};class ThreadPool{private:    pthread_mutex_t lock;    pthread_cond_t cond; // 只能让消费者等，如果作为服务器时，生产者等待那么就无法接收外部请求了    std::queue&lt;Task&gt; q;    size_t max_num;public:    void LockQueue()    {        pthread_mutex_lock(&amp;lock);    }    void UnLockQueue()    {        pthread_mutex_unlock(&amp;lock);    }    void ThreadWait()    {        pthread_cond_wait(&amp;cond, &amp;lock);    }    void WakeUpThread()    {        pthread_cond_signal(&amp;cond);    }    bool IsEmpty()    {        return q.size() == 0;    }    // threadpool    void Get(Task &amp;out)    {        out = q.front();        q.pop();    }    // server    void Put(Task &amp;in)    {        LockQueue();        q.push(in);        UnLockQueue();        WakeUpThread(); // 生产者塞任务进入队列之后，需要通知消费者。    }public:    ThreadPool(int num = 5): max_num(num)    {}    static void* Routine(void *arg)    {        ThreadPool *this_p = (ThreadPool*)arg;        while(true)        {            this_p-&gt;LockQueue();            while(this_p-&gt;IsEmpty())            {                this_p-&gt;ThreadWait();            }            Task t;            this_p-&gt;Get(t);            this_p-&gt;UnLockQueue();            t.Run();        }    }    void ThreadPoolInit()    {        pthread_cond_init(&amp;cond, nullptr);        pthread_mutex_init(&amp;lock, nullptr);        pthread_t t;        for(size_t i = 0; i &lt; max_num; i++)        {            pthread_create(&amp;t, nullptr, Routine, this);        }    }    ~ThreadPool()    {        pthread_cond_destroy(&amp;cond);        pthread_mutex_destroy(&amp;lock);    }};</code></pre><p>线程池存在的价值：</p><ul><li>有任务，立马有线程进行服务，省掉了线程创建的时间。</li><li>有效防止，server中线程过多，导致系统过载问题。</li></ul><p>线程池 VS 进程池：</p><ul><li>线程池占用资源更少，但是健壮性不强。</li><li>进程池占用资源更多，但是健壮性强。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;什么是线程？&quot;&gt;&lt;a href=&quot;#什么是线程？&quot; class=&quot;headerlink&quot; title=&quot;什么是线程？&quot;&gt;&lt;/a&gt;什么是线程？&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;在一个程序里的一个执行路线就叫做线程。更准确的定义是：线程是“一个进程的内部序列”。&lt;/li&gt;
</summary>
      
    
    
    
    <category term="C语言" scheme="https://duwei19961021.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="线程" scheme="https://duwei19961021.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CppPrimer</title>
    <link href="https://duwei19961021.github.io/2021/04/13/CppPrimer/"/>
    <id>https://duwei19961021.github.io/2021/04/13/CppPrimer/</id>
    <published>2021-04-13T03:26:55.000Z</published>
    <updated>2021-04-17T15:47:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><h4 id="1-5-类简介"><a href="#1-5-类简介" class="headerlink" title="1.5 类简介"></a>1.5 类简介</h4><h5 id="1-5-1-Sales-item类"><a href="#1-5-1-Sales-item类" class="headerlink" title="1.5.1 Sales_item类"></a>1.5.1 Sales_item类</h5><p>c++中通过定义类来定义数据结构。一个类定义了一个类型，以及与其相关联的操作。</p><h5 id="1-5-2-成员函数"><a href="#1-5-2-成员函数" class="headerlink" title="1.5.2 成员函数"></a>1.5.2 成员函数</h5><p>成员函数时定义为类一部分的函数，有时也被称为方法。</p><h3 id="第三章-字符串、向量和数组"><a href="#第三章-字符串、向量和数组" class="headerlink" title="第三章 字符串、向量和数组"></a>第三章 字符串、向量和数组</h3><h4 id="3-2-标准库类型-string"><a href="#3-2-标准库类型-string" class="headerlink" title="3.2 标准库类型 string"></a>3.2 标准库类型 string</h4><h5 id="3-2-1-定义和初始化-string-对象"><a href="#3-2-1-定义和初始化-string-对象" class="headerlink" title="3.2.1 定义和初始化 string 对象"></a>3.2.1 定义和初始化 string 对象</h5><pre><code class="c">string s1;string s2 = s1;string s3 = &quot;heya&quot;;string s4(10,&#39;c&#39;);</code></pre><h6 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h6><p>如果使用等号初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。</p><p>与之相反，如果不使用等号，则执行的是直接初始化。</p><h3 id="第四章-表达式"><a href="#第四章-表达式" class="headerlink" title="第四章 表达式"></a>第四章 表达式</h3><h4 id="4-11-类型转换"><a href="#4-11-类型转换" class="headerlink" title="4.11 类型转换"></a>4.11 类型转换</h4><h6 id="何时发生类型转换"><a href="#何时发生类型转换" class="headerlink" title="何时发生类型转换"></a>何时发生类型转换</h6><ol><li>在大多表达式中，比int类型小的整形值会提升为较大的整数类型。</li><li>在条件中，非布尔值转换成布尔类型。</li><li>初始化过程中，初始值转换成变量类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。</li><li>如果算数运算或关系运算的运算对象有多种类型，需要转换成同一种类型。</li><li>函数调用时会发生类型转换。</li></ol><h5 id="4-11-1-算术转换"><a href="#4-11-1-算术转换" class="headerlink" title="4.11.1 算术转换"></a>4.11.1 算术转换</h5><h6 id="算术转换"><a href="#算术转换" class="headerlink" title="算术转换"></a>算术转换</h6><p>算术转换的含义是把一种算术类型转换成另一种算术类型。</p><p>算术转换的规则定义了一套类型转换的层次，其中运算符的运算对象将转换成最宽的类型。例如：</p><p>如果一个运算对象是long double，那么不论另外一个运算对象的类型是什么都会转换成long double</p><h6 id="整形提升"><a href="#整形提升" class="headerlink" title="整形提升"></a>整形提升</h6><p>负责把小整数类型转换成较大的整数类型。(前提是转换后的类型要能容纳原类型所有可能的值)</p><h5 id="4-11-3-显示类型转换"><a href="#4-11-3-显示类型转换" class="headerlink" title="4.11.3 显示类型转换"></a>4.11.3 显示类型转换</h5><h6 id="命名的强制类型转换"><a href="#命名的强制类型转换" class="headerlink" title="命名的强制类型转换"></a>命名的强制类型转换</h6><p>cast-name&lt;type&gt; (expression)，type是转换的目标类型，expression是要转换的值。如果type是引用类型，则结果是左值。cast-name是static_cast、</p><p>dynamic_cast、const_cast和reinterpret_cast中的一种。dynamic_cast支持运行时类型识别。</p><h6 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h6><p>任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。</p><pre><code class="c">#include &lt;iostream&gt;using namespace std;int main(){    int a = 10;    int b = 3;    double ret = static_cast&lt;double&gt;(a) / b;    cout &lt;&lt; ret &lt;&lt; endl;    return 0;}// output: 3.33333</code></pre><p>当需要把一个较大的算数类型赋值给较小的类型时，static_cast非常有用。此时强制类型转换的意思是告诉编译器和读者：我们知道且不在乎潜在的精度损失。</p><p>static_cast对于编译器无法自动执行的类型转换也非常有用。例如，可以使用static_cast找回存在于void*指针中的值。</p><pre><code class="c">#include &lt;iostream&gt;using namespace std;int main(){    double d = 3.14;    void* p = &amp;d; // 任何非常量对象的地址都能存入void*    double *dp = static_cast&lt;double*&gt;(p); // 将void*转换回初始的指针类型    return 0;}</code></pre><h6 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h6><blockquote><p>顶层const表示指针本身是个常量，底层const表示指针指向的对象是一个常量。</p></blockquote><p>const_cast 只能改变运算对象的底层const：</p><pre><code class="c">#include &lt;iostream&gt;using namespace std;int main(){    char c = &#39;a&#39;;    char const *cp  = &amp;c;    char *p = const_cast&lt;char*&gt;(cp); // 如果不使用const_cast去掉const性质，那么*cp是无法修改的。    *p = &#39;b&#39;;    cout &lt;&lt; &quot;*cp = &quot; &lt;&lt; *cp &lt;&lt; &quot;,&quot; &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl;    return 0;}</code></pre><pre><code class="c">const char *pc;char *p = const_cast&lt;char*&gt;(pc);</code></pre><p>将常量对象转换成非常量对象的行为一般称为–去掉const性质。一旦抹去对象的const性质，编译器不再阻止对该对象进行写操作。如果一个对象本身不是一个常量，使用强制类型转换获得写权限是合法行为。</p><pre><code class="c">const char *cp;char *p = const_cast&lt;char*&gt;(cp); // 不能转换掉const性质，const_cast只能改变运算对象的底层conststatic_cast&lt;string&gt;(cp);const_cast&lt;string&gt;(cp); // 错误，const_cast只能改变常量属性</code></pre><h6 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h6><p>reinterpret_cast 通常为运算对象的位模式提供较低层次上的重新解释。</p><h3 id="第六章-函数"><a href="#第六章-函数" class="headerlink" title="第六章 函数"></a>第六章 函数</h3><h4 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h4><p>实参是形参的初始值。实参的类型必须与对应的形参存在对应关系。</p><h5 id="6-1-1-局部对象"><a href="#6-1-1-局部对象" class="headerlink" title="6.1.1 局部对象"></a>6.1.1 局部对象</h5><p>名字有作用域，对象有生命周期。</p><ul><li>名字的作用域是程序文本的一部分，名字在其中可见。</li><li>对象的声明周期是程序执行过程中该对象存在的一段时间。</li></ul><p>函数体是一个语句块。块构成一个新的作用域，可以在其中定义变量。形参和函数体内部定义的变量统称为局部变量。它们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量会隐藏在外层作用域中同名的其它所有声明。</p><h6 id="自动对象"><a href="#自动对象" class="headerlink" title="自动对象"></a>自动对象</h6><p>只存在于块执行期间的对象称为自动对象。(函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它)。形参是自动对象。</p><h6 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h6><p>在程序执行路径第一次经过对象定义语句时初始化，直到程序终止才被销毁。</p><h4 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h4><h5 id="6-2-6-含有可变形参的函数"><a href="#6-2-6-含有可变形参的函数" class="headerlink" title="6.2.6 含有可变形参的函数"></a>6.2.6 含有可变形参的函数</h5><p>为了编写能处理不同数量实参的函数，c++11新标准提供了两种主要方法：</p><ol><li><p>如果所有实参类型相同，可以传递一个名为initializer_list的标准库类型。initializer_list对象中的元素永远是常量值，无法改变其中的元素的值。</p><pre><code class="c">#include &lt;iostream&gt;#include &lt;initializer_list&gt;using namespace std;void test(initializer_list&lt;int&gt; il){    for(initializer_list&lt;int&gt;::iterator it = il.begin(); it != il.end(); it++)    {        cout &lt;&lt; *it &lt;&lt; endl;    }}int main(){    initializer_list&lt;int&gt; il = {1,3,5,7,9,2,4,6,8,10};    test(il);    return 0;}</code></pre></li></ol><ol start="2"><li>如果实参的类型不同，可以编写一种特殊的函数，也就是可变参数模板。</li></ol><h6 id=""><a href="#" class="headerlink" title=""></a></h6><h4 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h4><h6 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h6><p>如果同一作用域内的几个函数名字相同但形参列表不同，称之为函数重载。</p><pre><code class="c">void print(const char *cp);void print(const int *beg, const int *end);void print(const int ia[], size_t size);</code></pre><p>对于重载函数来说，它们应该在形参数量或形参类型上有所不同。</p><p>不允许两个函数除了返回类型外其它所有的要素都相同，也就是说返回值类型不能作为函数重载的要素。</p><h6 id="重载和const形参"><a href="#重载和const形参" class="headerlink" title="重载和const形参"></a>重载和const形参</h6><p>一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。</p><pre><code class="c">#include &lt;iostream&gt;#include &lt;initializer_list&gt;using namespace std;class C1{};/*// 重复定义,顶层const无法区分void Print(C1* c1){    cout &lt;&lt; &quot;c1&quot; &lt;&lt; endl;}void Print(C1* const c2) // 表示形参指针变量c2是个常量，顶层const{    cout &lt;&lt; &quot;c2&quot; &lt;&lt; endl;}*/void echo(C1&amp; c1){    cout &lt;&lt; &quot;ref c1&quot; &lt;&lt; endl;}void echo(const C1&amp; c2) // const修饰c2这个引用指向的对象是个常量，因此是底层const{    cout &lt;&lt; &quot;c2&quot; &lt;&lt; endl &lt;&lt; endl;;}void echo(C1* c3){    cout &lt;&lt; &quot;c3&quot; &lt;&lt; endl;}void echo(const C1* c4) // const修饰的是C1对象{    cout &lt;&lt; &quot;c4&quot; &lt;&lt; endl;}/*void echo(C1* const c5) // 此时const修饰的是c5这个指针变量本身而非其指向的对象，是顶层const{    ;}*/int main(){    return 0;}</code></pre><h6 id="const-cast和重载"><a href="#const-cast和重载" class="headerlink" title="const_cast和重载"></a>const_cast和重载</h6><pre><code class="c">const string &amp;shorterString(const string &amp;s1, const string &amp;s2){    return s1.size() &lt;= s2.size() ? s1 : s2;}// 这种情况下，返回值也必须是const 引用类型/*     当需要得到一个普通的引用时，借助const_cast。(这里的两个shorterString函数是有发生重载的)    先将它的实参强制类型转换成对应的const的引用，然后调用shorterString函数的const版本。    const版本返回对const string的引用，再将这个引用转换成一个普通的string&amp;，然后返回。*/string &amp;shorterString(string &amp;s1, string &amp;s2){    const string &amp;r = shorterString(const_cast&lt;const string&amp;&gt;(s1), const_cast&lt;const string&amp;&gt;(s2));    return  const_cast&lt;string&amp;&gt;(r);}</code></pre><h4 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5 特殊用途语言特性"></a>6.5 特殊用途语言特性</h4><h5 id="6-5-1-默认实参"><a href="#6-5-1-默认实参" class="headerlink" title="6.5.1 默认实参"></a>6.5.1 默认实参</h5><pre><code class="c">int sum(int a = 10, int b = 20);</code></pre><h5 id="6-5-2-内联函数和constexpr函数"><a href="#6-5-2-内联函数和constexpr函数" class="headerlink" title="6.5.2 内联函数和constexpr函数"></a>6.5.2 内联函数和constexpr函数</h5><p>把一些规模较小的操作定义成函数有很多好处，包括：</p><ul><li>容易阅读和理解</li><li>函数可以确保行为的统一</li><li>容易修改</li><li>复用</li></ul><p>但是也存在一个潜在的缺点，一次函数调用包含这一系列工作：</p><ol><li>调用前要先保存寄存器，并在返回时恢复；</li><li>可能需要拷贝实参；</li><li>程序转向一个新的位置继续执行。</li></ol><h6 id="内联函数可避免函数调用的开销"><a href="#内联函数可避免函数调用的开销" class="headerlink" title="内联函数可避免函数调用的开销"></a>内联函数可避免函数调用的开销</h6><p>将函数指定为内联函数，通常就是将它在每个调用点上“内联地”展开。例如 6.4 中的shorterString函数：</p><pre><code class="c">// 调用cout &lt;&lt; shorterString(s1, s2) &lt;&lt; endl;// 将在编译过程中展开成类似于下面的形式cout &lt;&lt; (s1.size() &lt; s2.size() ? s1 : s2) &lt;&lt; endl;// 在函数前加上inline关键字将其声明成内联函数，实际上不一定需要加inline，编译器会帮我们去优化的。</code></pre><h6 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h6><p>constexpr函数(constexpr function)是指 能用于常量表达式的函数。定义constexpr函数的方法与其它函数类似，需要遵循以下约定：</p><ol><li><p>函数的返回类型及所有形参的类型都得是字面值类型</p></li><li><p>函数体中必须有且只有一条return语句</p><pre><code class="c">constexpr int new_sz() { return 42; }constexpr int foo = new_sz();/*    执行该初始化任务时，编译器把对constexpr函数的调用替换成其结果值。    为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。*//*    constexpr函数体内也可以包含其它语句，只要这些语句不执行任何操作就行。例如，constexpr函数中可以有空语句、    类型别名以及using声明。*/constexpr size_t scale(size_t cnt) { return new_sz() * cnt; }int arr[scale(2)]; // 正确，scale的实参是常量表达式，所以它的返回值也是常量表达式。int i = 2；int a2[scale(i)]; // 错误，数组的大小不能是变量，必须是常量。因为scale的实参是变量，所以它的返回值也是一个变量</code></pre></li></ol><h4 id="6-6-函数匹配"><a href="#6-6-函数匹配" class="headerlink" title="6.6 函数匹配"></a>6.6 函数匹配</h4><h6 id="确定候选函数和可行函数"><a href="#确定候选函数和可行函数" class="headerlink" title="确定候选函数和可行函数"></a>确定候选函数和可行函数</h6><p>第一步是确定本次调用对应的重载函数集，集合中的函数称为候选函数。候选函数具备两个特征：① 与被调用的函数同名，② 其生命在调用点可见</p><p>第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为可行函数。可行函数具备两个特征：① 其形参数量与本次调用提供的实参数量相等，② 每个实参的类型与对应的形参类型相同或者能转换成形参的类型。</p><pre><code class="c">void f();void f(int);void f(int, int);void f(double, double = 3.14);f(5.6); /*     调用 void f(double, double);     可行函数：        f(int) // double能转换成int        f(double, double) // 第二个形参提供了默认值    如果没有找到可行函数，编译器将报告无匹配函数的错误。*/</code></pre><h6 id="寻找最佳匹配-如果有的话"><a href="#寻找最佳匹配-如果有的话" class="headerlink" title="寻找最佳匹配(如果有的话)"></a>寻找最佳匹配(如果有的话)</h6><p>第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。实参类型与形参类型越接近，匹配的越好。精确匹配比需要类型转换的匹配更好。所以最终调用的是 f(double, double = 3.14)。</p><h6 id="含有多个形参的函数匹配"><a href="#含有多个形参的函数匹配" class="headerlink" title="含有多个形参的函数匹配"></a>含有多个形参的函数匹配</h6><p>例如调用：f(42, 2.56);</p><p>先确定可行函数：f(int, int)，f(double, double)。</p><p>接下来一次检查每个实参以确定哪个函数是最佳匹配。如果有且只有一个函数满足下列条件，则匹配成功：</p><ul><li>该函数每个实参的匹配都不劣于其它可行函数需要的匹配。</li><li>至少有一个实参的匹配优于其它可行函数提供的匹配。</li></ul><p>在上面的调用中，如果只考虑第一个实参，那么f(int, int) 能精确匹配；要想匹配第二个函数，int类型的实参必须转换成double类型，但是需要内置类型转换的匹配劣于精确匹配，因此就第一个实参来说，f(int, int) 比 f(double, double)更好。</p><p>接着考虑第二个实参2.56，同理，f(double, double)更好。</p><p>编译器最终会因为这个调用具有二义性而拒绝其请求：因为每一个可行函数各自在一个实参上实现了更好的匹配，从整体上无法判断孰优孰劣。</p><pre><code class="c">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void f(){    cout &lt;&lt; &quot;f()&quot; &lt;&lt; endl;}void f(int){    cout &lt;&lt; &quot;f(int)&quot; &lt;&lt; endl;}void f(int, int){    cout &lt;&lt; &quot;f(int, int)&quot; &lt;&lt; endl;}void f(double, double = 3.14){    cout &lt;&lt; &quot;f(double, double = 3.14)&quot; &lt;&lt; endl;}void f(int, int, int){    cout &lt;&lt; &quot;f(int, int, int)&quot; &lt;&lt; endl;}void f(double, double, double){    cout &lt;&lt; &quot;f(double, double, double)&quot; &lt;&lt; endl;}int main(){    f(5.6); // 正确    f(32,3.14); // 报错    f(32, 33, 4.4); // 报错    return 0;}</code></pre><h5 id="6-6-1"><a href="#6-6-1" class="headerlink" title="6.6.1"></a>6.6.1</h5><p>为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级：</p><ol><li>精确匹配<ul><li>实参类型和形参类型相同</li><li>实参从数组类型或函数类型转换成对应的指针类型</li><li>向实参添加顶层const或者从实参中删除顶层const</li></ul></li><li>通过const转换实现的函数匹配</li><li>通过类型提升实现的匹配</li><li>通过算术类型转换或指针转换实现的匹配</li><li>通过类类型转换实现的匹配</li></ol><h6 id="需要类型提升和算术类型转换的匹配"><a href="#需要类型提升和算术类型转换的匹配" class="headerlink" title="需要类型提升和算术类型转换的匹配"></a>需要类型提升和算术类型转换的匹配</h6><p>小整形一般都会提升到int类型或者更大的整形类型。</p><pre><code class="c">void ff(int);void ff(short);ff(&#39;a&#39;); // char提升成int，调用f(int)</code></pre><p>所有算术类型转换的级别都一样。例如，从int想unsigned int的转换并不比int向double的转换级别高。例如：</p><pre><code class="c">void manip(long);void manip(float);manip(3.14); // 错误：二义性调用</code></pre><h6 id="函数匹配和const实参"><a href="#函数匹配和const实参" class="headerlink" title="函数匹配和const实参"></a>函数匹配和const实参</h6><h4 id="6-7-函数指针"><a href="#6-7-函数指针" class="headerlink" title="6.7 函数指针"></a>6.7 函数指针</h4><p>函数指针指向的是函数而非对象。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。</p><pre><code class="c">bool lengthCompare(const string &amp;, const string &amp;);bool (const string&amp;, const string&amp;);bool (*pf)(const string&amp;, const string&amp;);</code></pre><h3 id="第七章-类"><a href="#第七章-类" class="headerlink" title="第七章 类"></a>第七章 类</h3><p>类的基本思想是数据抽象和封装(实现了类的接口和实现的分离，隐藏实现细节)。数据抽象是一种依赖于接口和实现的分离编程技术。</p><h4 id="7-1-定义抽象数据类型"><a href="#7-1-定义抽象数据类型" class="headerlink" title="7.1 定义抽象数据类型"></a>7.1 定义抽象数据类型</h4><h5 id="7-1-4-构造函数"><a href="#7-1-4-构造函数" class="headerlink" title="7.1.4 构造函数"></a>7.1.4 构造函数</h5><p>每个类都定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数控制其对象的初始化过程，这些函数叫构造函数。构造函数的任务是初始化类对象的数据成员，无论何时只要类被初始化，就会调用构造函数。</p><p>构造函数的名字与类名相同，无返回值。</p><p>构造函数不能声明成const，当创建一个类的const对象时，直到构造函数完成初始化完成，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。</p><p>如果类没有显示的定义构造函数，那么编译器就会为我们隐式的定义一个默认构造函数。</p><h6 id="某些类不能依赖于合成的默认构造函数"><a href="#某些类不能依赖于合成的默认构造函数" class="headerlink" title="某些类不能依赖于合成的默认构造函数"></a>某些类不能依赖于合成的默认构造函数</h6><ol><li><p>只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。</p><p>编译器只有在发现类不包含任何构造函数的情况下才会自动生成一个构造函数。一旦我们自己定义了其它的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认的构造函数。（依据：如果一个类在某种情况下需要控制对象初始化，那么该类很可能在所有情况下都需要控制。）</p></li><li><p>含有内置内省或者复合类型成员的类应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数。否则，在用户创建类的对象时就可能得到未定义的值。</p></li><li><p>有些时候编译器不能为类合成默认的构造函数。</p><p>例如，如果一个类中包含一个其它类类型成员且这个成员没有默认的构造函数，那么编译器将无法初始化该成员。对于这样的类必须自定义默认构造函数，否则该类将没有默认的构造函数。</p></li></ol><h6 id="default"><a href="#default" class="headerlink" title="=default"></a>=default</h6><p>当定义其它形式的构造函数时，也需要默认的构造函数，c++11中可以使用=default来要求编译器生成默认构造函数</p><pre><code class="c">#include &lt;iostream&gt;using namespace std;class Person{public:    Person() = default;    Person(int age)    {        _age = age;    }private:    int _age;};int main(){    Person p;    return 0;}</code></pre><h4 id="7-2-访问控制与封装"><a href="#7-2-访问控制与封装" class="headerlink" title="7.2 访问控制与封装"></a>7.2 访问控制与封装</h4><p>定义在public说明符之后的成员在整个程序内可以被访问，public成员定义类的接口。</p><p>定义在private说明符之后的成员可以被类的成员函数访问。</p><h6 id="使用struct-或-class关键字"><a href="#使用struct-或-class关键字" class="headerlink" title="使用struct 或 class关键字"></a>使用struct 或 class关键字</h6><p>class中，默认的权限是私有的。struct中，默认的权限是public。</p><h5 id="7-2-1-友元"><a href="#7-2-1-友元" class="headerlink" title="7.2.1 友元"></a>7.2.1 友元</h5><p>类可以允许其它类或者函数访问它的非公有成员，方法是令其它类或者函数成为它的友元。</p><h3 id="第十章-泛型算法"><a href="#第十章-泛型算法" class="headerlink" title="第十章 泛型算法"></a>第十章 泛型算法</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h3&gt;&lt;h4 id=&quot;1-5-类简介&quot;&gt;&lt;a href=&quot;#1-5-类简介&quot; class=&quot;headerlink&quot; title=&quot;1.5 类简介</summary>
      
    
    
    
    <category term="C语言" scheme="https://duwei19961021.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="book" scheme="https://duwei19961021.github.io/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>信号</title>
    <link href="https://duwei19961021.github.io/2021/04/12/signal/"/>
    <id>https://duwei19961021.github.io/2021/04/12/signal/</id>
    <published>2021-04-12T11:57:55.000Z</published>
    <updated>2021-05-04T09:08:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.3amupupup.online/pending-block-handler.png" alt="signal"></p><blockquote><ul><li>每个信号都有两个标志位表示阻塞(block)和未决(pending)，还有一个函数指针表示处理动作。信号产生时，内核在该进程控制块中设置该信号的未决标志，在上图例子中SIGHUP信号未阻塞也未产生过，当它递达时执行默认处理动作。</li><li>SIGINT信号产生过，但正在被阻塞，所以暂时不能递达。虽然它的处理动作是忽略，但在没有解除阻塞之前不能忽略这个信号，因为进程有机会改变处理动作之后在接触阻塞。</li><li>SIGQUIT信号未产生过，一旦产生SIGQUIT信号将被阻塞，它的处理动作是用户自定义函数 sighandler。如果在进程接触某信号的阻塞之前这种信号产生过多次，将如何处理？linux处理方式：常规信号在递达之前多次只计一次。而实时信号在递达之前产生多次可以依次放在一个队列里。</li></ul></blockquote><h5 id="信号保存：pending位图"><a href="#信号保存：pending位图" class="headerlink" title="信号保存：pending位图"></a>信号保存：pending位图</h5><p>01000000 00000000 00000000 00000000：信号2</p><p>比特位的位置：代表是哪个信号</p><p>比特为的内容：代表是否收到这个信号。(0无，1有)</p><h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><pre><code class="c">struct task_struct{  ....;  unsigned int sigbitmap = 0;  ....;}</code></pre><p>操作系统如何发送信号？ 找到进程的pcb，将sigbitmap第八个位置的比特位修改为1。(操作系统给进程“发送”信号，操作系统给进程写信号)</p><h6 id="信号相关概念"><a href="#信号相关概念" class="headerlink" title="信号相关概念"></a>信号相关概念</h6><ol><li>实际执行信号的处理动作称为信号递达(Delivery)。</li><li>信号从产生到递达之间的状态，称为信号未决(Pending)。</li><li>进程可以选择阻塞(Block)某个信号。</li><li>被阻塞的信号将保持在未决状态，直到进程解除对此信号的阻塞，才执行递达动作。</li><li>忽略和阻塞是不同的，只要信号被阻塞就不会递达，而忽略是在递达之后可选的一种处理动作。</li></ol><h5 id="block位图"><a href="#block位图" class="headerlink" title="block位图"></a>block位图</h5><p>记录信号被屏蔽/阻塞信息：</p><p>01000000 00000000 00000000 00000000</p><p>比特位的位置，代表是哪个信号？(是谁)</p><p>比特为的内容，代表是否被屏蔽。</p><h5 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h5><p>是一个函数指针数组，信号编号是数组的下标。</p><pre><code class="c">sighandler_t signal(int signum, sighandler_t handler);</code></pre><p>因此可以得知signal函数的作用：修改收到一个信号时的处理动作。(修改递达行为)</p><h5 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h5><pre><code class="c">int sigemptyset(sigset_t *set); // 初始化set所指向的信号集，使信号对应的所有比特位为0。int sigfillset(sigset_t *set); // 初始化set所指向的信号集，使信号对应的所有比特位都为1。int sigaddset(sigset_t *set, int signum); // 设置set对应的信号集，将signum信号对应比特位置为1。int sigdelset(sigset_t *set, int signum); // 设置set对应的信号集，将signum信号对应的比特位置为0。int sigismember(const sigset_t *set, int signum); // 判断信号signum是否存在于信号集set中，也就是判断对应的比特位是否为1。int sigprocmask(int how, const sigset_t *restrict set, igset_t *restrict oset);/*    读取或修改进程的信号屏蔽字(阻塞信号集)，成功返回0，出错返回-1。    如果oset时非空指针，则读取进程的当前信号屏蔽字通过oset参数传出。    如果set时非空指针，则根据how参数修改进程的信号屏蔽字。    如果set和oset都不为空，则先将未修改前的信号屏蔽字保存到oset中，再根据how参数修改信号屏蔽字。    how:         ① SIG_BLOCK，set包含了希望添加到当前信号屏蔽字的信号。mask|set        ② SIG_UNBLOCK，set包含了希望从当前信号屏蔽字中解除阻塞的信号。mask&amp;~set，例：set: 10001 =&gt; ~set: 01110 =&gt; mask&amp;~set: 比特位同时为1才会保存下来        ③ SIG_SETMASK，设置当前信号屏蔽字为set指向的的值。mast=set*/</code></pre><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;void show_pending(sigset_t pending){    for(int i = 1; i &lt;= 31; i++)    {        if(sigismember(&amp;pending, i)) // 1~31信号，挨个判断是否在pending信号集中并打印显示        {            printf(&quot;1&quot;);        }        else        {            printf(&quot;0&quot;);        }    }    printf(&quot;\n&quot;);}void handler(int signum){    printf(&quot;get a signal: %d\n&quot;,signum);}int main(){    sigset_t pending;    sigset_t block, oblock;    sigisemptyset(&amp;block); // 先对block进行初始化，设置全0，这里修改的只是参数block，而不是修改的当前进程的信号屏蔽字    sigisemptyset(&amp;pending); // 同上，初始化pending，设置全0    sigaddset(&amp;block, 2); // 将2号信号添加进block    sigprocmask(SIG_SETMASK, &amp;block, &amp;oblock); // 修改当前进程的信号屏蔽字，等于block。也就是使当前进程屏蔽2号信号      int count = 0;    while(1)    {        sigemptyset(&amp;pending);        sigpending(&amp;pending); // 获取当前进程的pending信号集        show_pending(pending);        sleep(1);        if(count++ == 10)        {            printf(&quot;recover sig mask.\n&quot;);            sigprocmask(SIG_SETMASK, &amp;oblock, NULL);        }    }    return 0;}// output/*  0000000000000000000000000000000  0000000000000000000000000000000  ^C0100000000000000000000000000000 // 键盘键入 ctrl+c，收到2号信号指挥pending上的第二个比特位被设置为1，代表收到了2号信号，但是由于我们屏蔽了2号信号，所以进程不会结束而是继续打印  0100000000000000000000000000000  0100000000000000000000000000000  0100000000000000000000000000000  0100000000000000000000000000000  0100000000000000000000000000000  0100000000000000000000000000000  0100000000000000000000000000000  0100000000000000000000000000000  recover sig mask.  get a signal: 2  0000000000000000000000000000000  0000000000000000000000000000000  0000000000000000000000000000000  0000000000000000000000000000000  0000000000000000000000000000000  0000000000000000000000000000000  ^Cget a signal: 2  0000000000000000000000000000000  ^\[1]    8302 quit       ./test // 键盘键入 ctrl + \ 退出*/</code></pre><h5 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h5><p>信号检测、处理、递达发生在进程从内核态切换到用户态的时候。</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;void handler(int signum){    printf(&quot;get a signal: %d\n&quot;,signum);}int main(){    struct sigaction act, oact;    act.sa_hander = handler;    act.sa_flags = 0;    sigemptyset(&amp;act.sa_mask);    sigaction(2, &amp;act, &amp;oact);    while(1);    return 0;}</code></pre><h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><p>volatile作用：保持内存的可见性，告知编译器，被该关键字修饰的变量，不允许被优化，对该变量的任何操作，都必须在真实的内存中操作。</p><pre><code class="c">#include &lt;signal.h&gt;#include &lt;stdio.h&gt;// int quit = 0;volatile int quit = 0;// 被volatile修饰的变量是不可被覆盖的，在任何执行流中读取该数据必须从该数据的真实存储位置读取，不能从任何缓存中读取。void handler(int sig){    quit = 1;}int main(){    signal(2, handler);    while(!quit); // 如果声明为int类型，quit会被优化为寄存器变量，while循环一直检测的是寄存器中的值，所以进程收到2号信号之后，修改的是内存上的值，寄存器上的值未被修改，所以进程没有退出    printf(&quot;process exit\n&quot;);    return 0;}</code></pre><h5 id="SIGCHILD"><a href="#SIGCHILD" class="headerlink" title="SIGCHILD"></a>SIGCHILD</h5><p>wait、waitpid函数清理僵尸进程，父进程可以阻塞或者非阻塞地等待子进程结束。阻塞方式会导致父进程不能处理其它任务。非阻塞方式：父进程在处理其它任务时还得时不时轮询一下，程序实现复杂。</p><p>子进程在结束时会给父进程发送SIGCHILD信号，该信号的默认处理动作是忽略，父进程可以自定义SIGCHILD信号的处理函数，这样父进程只需要关注自己的工作，不必关心子进程，子进程终止时会通知父进程，父进程在处理函数中调用wait回收即可。</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;void handler(int sig){    printf(&quot;parent recived signal: %d\n&quot;, sig);}int main(){    signal(SIGCHLD, handler);    pid_t pid = fork();    if(pid == 0)    {        int i = 0;        while(i &lt; 5)        {            printf(&quot;i am child process\n&quot;);            i++;            sleep(1);        }        printf(&quot;child process exit\n&quot;);        exit(0);    }    else    {        while(1)        {            printf(&quot;i am parent process\n&quot;);            sleep(1);        }    }    return 0;}/*output:      ☁  signal [master] ⚡  ./run      i am parent process      i am child process      i am parent process      i am child process      i am parent process      i am child process      i am parent process      i am child process      i am parent process      i am child process      i am parent process      child process exit      parent recived signal: 17      i am parent process      i am parent process      i am parent process      i am parent process      ^C */</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.3amupupup.online/pending-block-handler.png&quot; alt=&quot;signal&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;每个信号都有两个标志位表示阻塞(block)和未决(pendi</summary>
      
    
    
    
    <category term="操作系统" scheme="https://duwei19961021.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="信号" scheme="https://duwei19961021.github.io/tags/%E4%BF%A1%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>nginx散列表</title>
    <link href="https://duwei19961021.github.io/2021/03/23/ngx_hash/"/>
    <id>https://duwei19961021.github.io/2021/03/23/ngx_hash/</id>
    <published>2021-03-23T10:21:27.000Z</published>
    <updated>2021-04-01T02:08:45.460Z</updated>
    
    <content type="html"><![CDATA[<h4 id="nginx数据类型：散列表"><a href="#nginx数据类型：散列表" class="headerlink" title="nginx数据类型：散列表"></a>nginx数据类型：散列表</h4><p><img src="https://img.3amupupup.online/ngx_hash_2.png" alt="散列表"></p><pre><code class="c">// 存储key和value的元素typedef struct {    void             *value;    // 指向value的指针    u_short           len;  // key的长度    u_char            name[1];  // key长度是可变的，这里使用了c语言的柔性数组} ngx_hash_elt_t;// hash表结构typedef struct {    ngx_hash_elt_t  **buckets;  // hash表的桶指针地址值    ngx_uint_t        size; // hash表的t桶个数} ngx_hash_t;// hash表初始化时所需的key的结构typedef struct {    ngx_str_t         key;  // key    ngx_uint_t        key_hash; // key经过hash函数计算得到的值    void             *value;    // value} ngx_hash_key_t;// 初始化结构，通过这个结构里的参数进行初始化typedef struct {    ngx_hash_t       *hash; // 指向hash表的指针    ngx_hash_key_pt   key;  // hash函数    ngx_uint_t        max_size; // 最多能有多少个桶    ngx_uint_t        bucket_size;  // 桶的大小(桶的内存空间size，单位是字节)    char             *name; // hash表名称    ngx_pool_t       *pool; // 内存池    ngx_pool_t       *temp_pool;    // 临时内存池} ngx_hash_init_t;</code></pre><h5 id="散列表提供的接口"><a href="#散列表提供的接口" class="headerlink" title="散列表提供的接口"></a>散列表提供的接口</h5><pre><code class="c">ngx_int_t ngx_hash_init(ngx_hash_init_t *hinit, ngx_hash_key_t *names, ngx_uint_t nelts); // 构建散列表void * ngx_hash_find(ngx_hash_t *hash, ngx_uint_t key, u_char *name, size_t len); // 查找keyngx_int_t ngx_hash_wildcard_init(ngx_hash_init_t *hinit, ngx_hash_key_t *names, ngx_uint_t nelts);    // 构建通配符散列表</code></pre><h5 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h5><ol><li><p>ngx_int_t ngx_hash_init(ngx_hash_init_t *hinit, ngx_hash_key_t *names, ngx_uint_t nelts): 构建散列表</p><p><img src="https://img.3amupupup.online/ngx_hash_test_1.png" alt="test"></p><pre><code class="c">/*typedef struct {    ngx_str_t         key;  // ngx_string类型的key    ngx_uint_t        key_hash; //  key经过hash函数处理之后的值    void             *value;    // value} ngx_hash_key_t;*//*    第一个参数：hash表初始化结构：通过这个结构提供的参数进行初始化    第二个参数：ngx_hash_key_t组成的数组(先将key的hash值算好存储在结构里，    用的时候直接取就行了，而不是边用边计算hash值)    第三个元素：数组的元素个数*//*    出现的参数说明：                        max_size: 桶的最大数量(这个hash表桶的最大个数)                        bucket_size: 桶的内存空间大小(不能超过65535)                        elt: ngx_hash_elt_t类型，桶中存储的元素    */ngx_int_tngx_hash_init(ngx_hash_init_t *hinit, ngx_hash_key_t *names, ngx_uint_t nelts){    u_char          *elts;    size_t           len;    u_short         *test;    ngx_uint_t       i, n, key, size, start, bucket_size;    ngx_hash_elt_t  *elt, **buckets;    if (hinit-&gt;max_size == 0) {        /*            如果max_size为0，那么这个hash表毫无意义         */        ngx_log_error(NGX_LOG_EMERG, hinit-&gt;pool-&gt;log, 0,                      &quot;could not build %s, you should &quot;u                      &quot;increase %s_max_size: %i&quot;,                      hinit-&gt;name, hinit-&gt;name, hinit-&gt;max_size);        return NGX_ERROR;    }    if (hinit-&gt;bucket_size &gt; 65536 - ngx_cacheline_size) {        /*                从这里可以看出：bucket_size的长度不会超过65535字节，                elt的len成员的类型是u_short(无符号短整型，范围0~65535)，                也就是说一个桶在最坏情况下只能存储一个elt(如果elt足够长)。        */        ngx_log_error(NGX_LOG_EMERG, hinit-&gt;pool-&gt;log, 0,                      &quot;could not build %s, too large &quot;                      &quot;%s_bucket_size: %i&quot;,                      hinit-&gt;name, hinit-&gt;name, hinit-&gt;bucket_size);        return NGX_ERROR;    }    for (n = 0; n &lt; nelts; n++) {        if (hinit-&gt;bucket_size &lt; NGX_HASH_ELT_SIZE(&amp;names[n]) + sizeof(void *))          /*              这里直接说结论：所有的bucket都是存储在一块连续的内存上的，所有的bucket通过              自己末尾上的NULL指针进行间隔(看上面的图)，由于names数组中每个元素对应的key              的长度可能都是不一样的，在用names中的元素生成对应的elt(elt包含一个柔性数组)时，              names中元素的key的长度不同，生成的elt的大小也就不同，为了提高对内存的访问效率，              ngx对每个elt进行了内存对齐，所以在连续内存上给elt分配内存时，并不是elt多大就分配              多少内存，而是分配对齐后的内存(类似结构体的内存对齐)。              这里遍历names中的每个元素，计算对应elt的内存大小进行计算，如果发现出现了              bucket_size小于其中任何一个元素的对应的elt的内存的大小(必须保证bucket_size              能存储至少一个elt)，就会返回失败提醒调用者增加bucket_size。          */        {            ngx_log_error(NGX_LOG_EMERG, hinit-&gt;pool-&gt;log, 0,                          &quot;could not build %s, you should &quot;                          &quot;increase %s_bucket_size: %i&quot;,                          hinit-&gt;name, hinit-&gt;name, hinit-&gt;bucket_size);            return NGX_ERROR;        }    }    test = ngx_alloc(hinit-&gt;max_size * sizeof(u_short), hinit-&gt;pool-&gt;log);      /*          申请一个数组test，max_size个元素，元素类型u_short，稍后会进行模拟hash表的生成过程，          test数组是用来存储每一个bucket在生成hash表的过程中存储的元素所占用的内存大小，检测桶          中所有元素的内存大小是否超过了bucket_size。      */    if (test == NULL) {        return NGX_ERROR;    }    bucket_size = hinit-&gt;bucket_size - sizeof(void *);      /*          上面说过一个结论：每个bucket的末尾都存在一个NULL指针。所以一个桶能真正被用来          存储elt的空间应该减去一个空指针的大小。      */    start = nelts / (bucket_size / (2 * sizeof(void *)));    /*        一个ngx_hash_elt_t结构实例化之后的对象在内存上最少需要占用(2 * sizeof(void *))        字节内存，在此记为elt_min_size。        bucket_size / elt_min_size 的含义即：桶中能存储的最大元素个数，在此记为max_num。        start = nelts / max_num 的含义即为：桶的个数(至少)。      */    start = start ? start : 1;    // 最起码要给一个桶    if (hinit-&gt;max_size &gt; 10000 &amp;&amp; nelts &amp;&amp; hinit-&gt;max_size / nelts &lt; 100) {        /*             这一段暂时说不出原因，应该是对桶个数上的优化        */        start = hinit-&gt;max_size - 1000;    }    for (size = start; size &lt;= hinit-&gt;max_size; size++) {        /*            这里开始进行探测的逻辑，内存循环根据桶子的个数去探测是否能装下所有elt，            外层循环不断增加桶子个数。        */        ngx_memzero(test, size * sizeof(u_short));        /*            初始化为0，按需初始化，有多少个桶就初始化多少个test的元素(置0)        */        for (n = 0; n &lt; nelts; n++) {            if (names[n].key.data == NULL) {              /*                  key是ngx_string类型，ngx_string的成员data指向字符的地址                这里是排除空串的情况              */                continue;            }            key = names[n].key_hash % size;            /*                key的hash值 模 上size(桶个数)就能得出位于哪个bucket            */            len = test[key] + NGX_HASH_ELT_SIZE(&amp;names[n]);              /*                  test[key]上存储的是对应的桶buckets[key]已经使用了的空间，                  len是当前桶再次存储一个elt之后的内存空间大小的值              */#if 0            ngx_log_error(NGX_LOG_ALERT, hinit-&gt;pool-&gt;log, 0,                          &quot;%ui: %ui %uz \&quot;%V\&quot;&quot;,                          size, key, len, &amp;names[n].key);#endif            if (len &gt; bucket_size) {               /*                  如果有发现len大于桶子的存储空间，说明发生了hash碰撞次数较多                  (碰撞多存储的元素就多)，导致桶子里的空间溢出了，因此跳出当前                  循环进入外层的循环去增加桶子的葛素。              */                 goto next;            }            test[key] = (u_short) len;              /*                  如果没发生桶空间溢出，则将len更新至test              */        }        goto found;          /*              走完一圈都没发生桶子空间溢出，则说明此时的size比较合适，能够存储所有元素          */    next:        continue;    }    size = hinit-&gt;max_size;    ngx_log_error(NGX_LOG_WARN, hinit-&gt;pool-&gt;log, 0,                  &quot;could not build optimal %s, you should increase &quot;                  &quot;either %s_max_size: %i or %s_bucket_size: %i; &quot;                  &quot;ignoring %s_bucket_size&quot;,                  hinit-&gt;name, hinit-&gt;name, hinit-&gt;max_size,                  hinit-&gt;name, hinit-&gt;bucket_size, hinit-&gt;name);found:    /*         此时已经找到了最合适的桶子数：size。(决定桶子个数的原则：不浪费内存)    */    for (i = 0; i &lt; size; i++) {        test[i] = sizeof(void *);          /*              上一步计算除去了bucket中NULL指针的空间,但是在实际中，              NULL指针也要算进去，这样才能给bucket分配最准确的内存大小，          */    }    for (n = 0; n &lt; nelts; n++) {        if (names[n].key.data == NULL) {    // 忽略空key            continue;        }        key = names[n].key_hash % size; // 得到当前key应该位于哪个桶        len = test[key] + NGX_HASH_ELT_SIZE(&amp;names[n]);    // 当前桶子已经使用了的内存空间        if (len &gt; 65536 - ngx_cacheline_size) {               /*                  如果有桶的长度大于bucket_size，说明桶溢出了              */            ngx_log_error(NGX_LOG_EMERG, hinit-&gt;pool-&gt;log, 0,                          &quot;could not build %s, you should &quot;                          &quot;increase %s_max_size: %i&quot;,                          hinit-&gt;name, hinit-&gt;name, hinit-&gt;max_size);            ngx_free(test); // 这里下一步是直接返回错误了，test必须free掉，否则会发生内存泄露            return NGX_ERROR;        }        test[key] = (u_short) len;          /*              test对应的元素保存了对应桶子的所需空间大小(桶里进一个elt，len累加)，              test[i] == bucket[i]的size          */    }    len = 0;    for (i = 0; i &lt; size; i++) {        if (test[i] == sizeof(void *)) {            continue;        }        test[i] = (u_short) (ngx_align(test[i], ngx_cacheline_size));        len += test[i];        /*            计算出所有bucket总共需要多少内存        */    }    if (hinit-&gt;hash == NULL) {        hinit-&gt;hash = ngx_pcalloc(hinit-&gt;pool, sizeof(ngx_hash_wildcard_t)                                             + size * sizeof(ngx_hash_elt_t *));        /*            sizeof(ngx_hash_wildcard_t)应该是有其它作用，暂时不理会。这里            分配了一个指针数组(ngx_hash_elt_t *)，每个指针指向对应的bucket的头部。            (看文章开始的图)        */        if (hinit-&gt;hash == NULL) {            ngx_free(test);            return NGX_ERROR;        }        buckets = (ngx_hash_elt_t **)                      ((u_char *) hinit-&gt;hash + sizeof(ngx_hash_wildcard_t));    } else {        buckets = ngx_pcalloc(hinit-&gt;pool, size * sizeof(ngx_hash_elt_t *));        if (buckets == NULL) {            ngx_free(test);            return NGX_ERROR;        }    }    elts = ngx_palloc(hinit-&gt;pool, len + ngx_cacheline_size);      /*          根据之前计算得到的len给所有elts分配一大块连续的内存(从内存池上申请的)      */    if (elts == NULL) {        ngx_free(test);        return NGX_ERROR;    }    elts = ngx_align_ptr(elts, ngx_cacheline_size); // 内存对齐，暂时不理解    for (i = 0; i &lt; size; i++) {        if (test[i] == sizeof(void *)) { // 说明在构建hash表时没有elt落进这个桶            continue;        }        buckets[i] = (ngx_hash_elt_t *) elts;          /*              类型转换          */        elts += test[i];          /*              test[i]中存储的是模拟hash表构建过程中，每个桶中元素大小的总和。              现在按照这个值给桶子按需分配内存，最大程度的节省内存          */     }    for (i = 0; i &lt; size; i++) {    // test数组置0        test[i] = 0;    }    for (n = 0; n &lt; nelts; n++) {        if (names[n].key.data == NULL) {    // 跳过空key            continue;        }        // 这里开始真正的遍历names数组，构建hash表        key = names[n].key_hash % size;        elt = (ngx_hash_elt_t *) ((u_char *) buckets[key] + test[key]); // 拿到elt的首地址        elt-&gt;value = names[n].value; // 写入value        elt-&gt;len = (u_short) names[n].key.len; // 写入len字段        ngx_strlow(elt-&gt;name, names[n].key.data, names[n].key.len); // 修改key为小写        test[key] = (u_short) (test[key] + NGX_HASH_ELT_SIZE(&amp;names[n]));         // 记录每个bucket的大小    }    for (i = 0; i &lt; size; i++) { // 遍历buckets        if (buckets[i] == NULL) {            continue;        }        elt = (ngx_hash_elt_t *) ((u_char *) buckets[i] + test[i]);          /*              buckets[i]是每个bucket的首地址，加上起存储空间就是末尾的位置，              将次位置当做elt处理，其value置空，当做间隔标志。          */        elt-&gt;value = NULL;  // 置为NULL    }    ngx_free(test);    hinit-&gt;hash-&gt;buckets = buckets;    hinit-&gt;hash-&gt;size = size;#if 0    for (i = 0; i &lt; size; i++) {        ngx_str_t   val;        ngx_uint_t  key;        elt = buckets[i];        if (elt == NULL) {            ngx_log_error(NGX_LOG_ALERT, hinit-&gt;pool-&gt;log, 0,                          &quot;%ui: NULL&quot;, i);            continue;        }        while (elt-&gt;value) {            val.len = elt-&gt;len;            val.data = &amp;elt-&gt;name[0];            key = hinit-&gt;key(val.data, val.len);            ngx_log_error(NGX_LOG_ALERT, hinit-&gt;pool-&gt;log, 0,                          &quot;%ui: %p \&quot;%V\&quot; %ui&quot;, i, elt, &amp;val, key);            elt = (ngx_hash_elt_t *) ngx_align_ptr(&amp;elt-&gt;name[0] + elt-&gt;len,                                                   sizeof(void *));        }    }#endif    return NGX_OK;}</code></pre></li><li><p>void * ngx_hash_find(ngx_hash_t *hash, ngx_uint_t key, u_char *name, size_t len): 查找key</p><pre><code class="c">/* * 第一个参数：hash表 * 第二个参数：key经过hash函数计算出的值 * 第三个参数：key * 第四个长度：key的长度 */void *ngx_hash_find(ngx_hash_t *hash, ngx_uint_t key, u_char *name, size_t len){    ngx_uint_t       i;    ngx_hash_elt_t  *elt;#if 0    ngx_log_error(NGX_LOG_ALERT, ngx_cycle-&gt;log, 0, &quot;hf:\&quot;%*s\&quot;&quot;, len, name);#endif    elt = hash-&gt;buckets[key % hash-&gt;size];    /*        key进行取模得到它是位于哪个桶里，得到的是bucket的首地址    */    if (elt == NULL) {        /*            说明桶里没有元素        */        return NULL;    }    while (elt-&gt;value) {        /*            桶的结尾元素：elt-&gt;value==NULL，间隔标志，            走到NULL说明key不存在        */         if (len != (size_t) elt-&gt;len) {          /*              如果传入的key的长度不等于桶中elt的长度(elt-&gt;len是指key的长度)              那么必不是这个key，就不用检查key了。先判断长度，在判断key，长              度不同key就不用比较了          */            goto next;        }        for (i = 0; i &lt; len; i++) {              /*                  比较key              */            if (name[i] != elt-&gt;name[i]) {                goto next;            }        }        return elt-&gt;value;          /*              走到这里说明找到了          */    next:        elt = (ngx_hash_elt_t *) ngx_align_ptr(&amp;elt-&gt;name[0] + elt-&gt;len,                                               sizeof(void *));        /*            计算下一个元素的起始地址并进行类型转换        */        continue;    }    return NULL;    // 否则返回空}</code></pre></li><li><p>ngx_int_t ngx_hash_wildcard_init<strong>(</strong>ngx_hash_init_t <strong>***hinit</strong>,** ngx_hash_key_t <strong>***names</strong>,**    ngx_uint_t nelts**);</p></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>ngx_hash_init初始化的hash表是静态的，根据给定的一组key结构和key的个数进行初始化，生成的hash表仅仅是为了查找，不能动态添加元素。初始化过程中会模拟hash表的构建，但又不是真正意义上的构建，仅仅是在模拟构建时计算每个桶需要的空间，然后在真正构建hash表时按需给桶分配内存，最大程度的节省内存。</p><p>所有bucket下的所有elt位于一块连续的内存上，通过elt-&gt;value == NULL作为bucket之间的间隔。</p><p>最重要的一点：</p><p>buckets是一块连续的内存，由多个bucket组成，每个bucket的末尾存在一个NULL指针作为标志位。</p><p>bucket由多个elt组成，因为key的长度不一样，最终生成的elt长度也不一样(key是保存在elt的柔性数组上)，也就是说不能像操作数组一样去操作buckets(数组的每个元素大小相同，可以通过步长去访问，但是这里的bucket中的每个elt长度不一致)。</p><p>解决办法：</p><p><img src="https://img.3amupupup.online/ngx_align_1.png" alt="ngx_align"></p><p>这两个宏函数的作用： 在b的基础上对a求最小的倍数。 ngx_hash_elt_t的前两个结构体成员自动对齐了，不对齐的是后面的这个柔性数组，经过这两个宏函数处理后，在柔性数组后面补了一块内存(红色部分)，这就对齐了。这是连续的内存但是因为elt这个结构的内存大小和key有关系，key越大name越大越大elt越大，key是不定长的，因此每个elt的大小都不一样，那就不能像数组那样操作bucket。在计算模拟hash构建阶段，会计算elt对齐后的内存空间大小，因此elt的末尾地址必然是4或8的倍数，访问第二个元素时，通过拿到第一个elt的(&amp;elt-&gt;name[0] + elt-&gt;len)再使用ngx_align_ptr对其进行取整，拿到的就是下一个elt的首地址。(要拿到第二个元素就必须知道第一个元素的name数组后的第一个内存地址，拿第三个就需要知道第二个的，有链表那味儿，但是无伤大雅，因为在构建hash时多个元素可能会落进同一个桶里，查找时如果得到的桶里恰好有多个元素，也是需要去遍历对比name的)。</p><h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h5><ol><li><p>内存对齐</p><pre><code class="c">#define ngx_align(d, a)     (((d) + (a - 1)) &amp; ~(a - 1))#define ngx_align_ptr(p, a)                                                   \    (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) &amp; ~((uintptr_t) a - 1))#define NGX_HASH_ELT_SIZE(name)                                               \    (sizeof(void *) + ngx_align((name)-&gt;key.len + 2, sizeof(void *)))/*    a = 4:  二进制： 0000 0100       从右往左，第三位为1，剩下全为0;    a = 8:  二进制： 0000 1000       从右往左，第四位为1, 剩下全为0；    a = 16: 二进制:  0001 0000       从右往左，第五位为1，剩下全为0；    a - 1 = 3:  二进制： 0000 0011   从右往左，第三位之前，全是1；    a - 1 = 7:  二进制： 0000 0111   从右往左，第四位之前，全是1；    a - 1 = 15: 二进制： 0000 1111   从右往左，第五位之前，全是1；    ~(a - 1) = ~3:  二进制： 1111 1100   从右往左，第二位之后，全是1；    ~(a - 1) = ~7:  二进制： 1111 1000   从右往左，第三位之后，全是1；    ~(a - 1) = ~15: 二进制： 1111 0000   从右往左，第四位之后，全是1；    一个数，一定是这个数的二进制从右起第一个不为零的位所表示的数的整数倍    a = 12:  二进制： 0000 1100     从右起，第一个不为零的位所表示的整数为 0000 0100 即 4    那么，a = 12 一定是 4 的整数倍    如果，我们需要任意的一个数a对4取整怎么办呢？很简单，只需要把a从右起的若干位置0就可以了。    比如：            a = 13: 二进制：0000 1101            向0000 0100 即 4 取整，只需要将 0000 1101从右起，前两位置0，即可得到，0000 1100 即12            这个置0的过程可以表达为0000 1101 &amp;  1111 1100            而 1111 1100 = ~(4 - 1)，因此，13 对 4 取整的二进制运算即为：13 &amp; ~(4 - 1)    对于一个任意的数d和一个2的任意次幂a：    d对a向下取整的二进制运算为：d &amp; ~(a -1)    d对a向上取整的二进制运算为：(d + (a - 1)) &amp; ~(a - 1)*//*    ngx_align(9,4) = 12    ngx_align(17,4) = 20    ngx_align_ptr(p, a)和ngx_align一样，只是会先将内存地址转成数字再计算*/</code></pre></li><li><p>柔性数组</p><p><img src="https://img.3amupupup.online/soft_array.png" alt="柔性数组"></p><p>结论：柔性数组与结构体在内存上是连续的</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;nginx数据类型：散列表&quot;&gt;&lt;a href=&quot;#nginx数据类型：散列表&quot; class=&quot;headerlink&quot; title=&quot;nginx数据类型：散列表&quot;&gt;&lt;/a&gt;nginx数据类型：散列表&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://img.3amu</summary>
      
    
    
    
    <category term="Nginx" scheme="https://duwei19961021.github.io/categories/Nginx/"/>
    
    
    <category term="hashtable" scheme="https://duwei19961021.github.io/tags/hashtable/"/>
    
  </entry>
  
  <entry>
    <title>ngx_align</title>
    <link href="https://duwei19961021.github.io/2021/03/22/ngx_align/"/>
    <id>https://duwei19961021.github.io/2021/03/22/ngx_align/</id>
    <published>2021-03-22T07:44:36.108Z</published>
    <updated>2021-03-24T08:03:45.472Z</updated>
    
    <content type="html"><![CDATA[<p>1、cache line</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/130770773" target="_blank" rel="noopener">CPU Cache</a></p><p>CPU 每次访问数据时先在缓存中查找一次，找不到则去主存找，访问完数据后会将数据存入缓存，以备后用。这就产生了一个问题，CPU 在访问某个地址的时候如何知道目标数据是在缓存中存在？如何知道缓存的数据是否还有效没被修改？不能为每个存入缓存的字节都打标记，所以 CPU 缓存会划分为固定大小的 Block 称为 Cache Line，作为存取数据的最小单位。大小都为 2 的整数幂，比如 16 字节，256 字节等。这样一个 cache line 这一整块内存能通过一个标记来记录是否在内存中，是否还有效，是否被修改等。一次存取一块数据也能充分利用总线带宽以及 CPU 访问的空间局部性。</p></blockquote><pre><code class="c"></code></pre><hr><p>实际上，对齐参数(MALLOC_ALIGNMENT)大小的设定需要满足以下两点：</p><ol><li><p>必须是2的幂</p></li><li><p>必须是void *的整数倍</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、cache line&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/130770773&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CPU Cache&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CPU</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>nginx单向链表</title>
    <link href="https://duwei19961021.github.io/2021/03/22/ngx_list/"/>
    <id>https://duwei19961021.github.io/2021/03/22/ngx_list/</id>
    <published>2021-03-22T03:15:43.000Z</published>
    <updated>2021-03-22T05:17:19.917Z</updated>
    
    <content type="html"><![CDATA[<h4 id="nginx数据类型：单向链表"><a href="#nginx数据类型：单向链表" class="headerlink" title="nginx数据类型：单向链表"></a>nginx数据类型：单向链表</h4><p><img src="https://img.3amupupup.online/ngx_list_1.png" alt="单向链表"></p><pre><code class="c">// 单向链表的子结点struct ngx_list_part_s {    void             *elts; // 数据区的首地址    ngx_uint_t        nelts;    //  指向第一个未使用过的元素    ngx_list_part_t  *next; //  指向下一个结点的指针};// 单向链表的父结点typedef struct {    ngx_list_part_t  *last; // 指向链表中的最后一个结点    ngx_list_part_t   part; //    size_t            size; // 元素大小    ngx_uint_t        nalloc;   //  指向最后一个使用过的元素    ngx_pool_t       *pool; //  指向内存池的指针，因为都是从内存池上分配的，所以需要保存指向内存池的指针} ngx_list_t;</code></pre><h5 id="单向链表提供的接口"><a href="#单向链表提供的接口" class="headerlink" title="单向链表提供的接口"></a>单向链表提供的接口</h5><pre><code class="c">ngx_list_t *ngx_list_create(ngx_pool_t *pool, ngx_uint_t n, size_t size);    // 创建链表结构(父结点)static ngx_inline ngx_int_t ngx_list_init(ngx_list_t *list, ngx_pool_t *pool, ngx_uint_t n, size_t size);    // 初始化操作void *ngx_list_push(ngx_list_t *list);    // 添加元素</code></pre><h5 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h5><ol><li><p>ngx_list_t *ngx_list_create(ngx_pool_t *pool, ngx_uint_t n, size_t size): 创建链表结构</p><pre><code class="c">ngx_list_t *ngx_list_create(ngx_pool_t *pool, ngx_uint_t n, size_t size){    ngx_list_t  *list;    list = ngx_palloc(pool, sizeof(ngx_list_t));      /*          在small链表上给链表的管理结构(父结点: ngx_list_t)分配内存      */    if (list == NULL) {        return NULL;    }    if (ngx_list_init(list, pool, n, size) != NGX_OK) { // 初始化数据区域        return NULL;    }    return list;}</code></pre></li><li><p>static ngx_inline ngx_int_t ngx_list_init(ngx_list_t *list, ngx_pool_t *pool, ngx_uint_t n, size_t size): 初始化链表</p><pre><code class="c">static ngx_inline ngx_int_tngx_list_init(ngx_list_t *list, ngx_pool_t *pool, ngx_uint_t n, size_t size){    list-&gt;part.elts = ngx_palloc(pool, n * size);      /*          分配在small还是large链表上取决于n*size      */    if (list-&gt;part.elts == NULL) {        return NGX_ERROR;    }    list-&gt;part.nelts = 0;      /*          指向最后一个使用过的元素      */    list-&gt;part.next = NULL;      /*          指向链表的下一个结点      */    list-&gt;last = &amp;list-&gt;part;      /*          指向当前链表的最后一个结点(初始化时指向自己)，便于尾插      */    list-&gt;size = size;      /*          元素的大小(占用内存的字节)      */    list-&gt;nalloc = n;      /*          元素个数      */    list-&gt;pool = pool;      /*          指向内存池      */    return NGX_OK;}</code></pre></li><li><p>void *ngx_list_push(ngx_list_t *list): 添加元素</p><pre><code class="c">void *ngx_list_push(ngx_list_t *l){    void             *elt;    ngx_list_part_t  *last;    last = l-&gt;last;      /*          拿到最后一个元素的指针，尾插时避免遍历链表从而导致效率低下      */    if (last-&gt;nelts == l-&gt;nalloc) {                /*                    说明空间用完了，需要扩容                */        /* the last part is full, allocate a new list part */        last = ngx_palloc(l-&gt;pool, sizeof(ngx_list_part_t));          /*              从内存池上给子结点结构分配内存          */        if (last == NULL) {              /*                  分配失败              */            return NULL;        }        last-&gt;elts = ngx_palloc(l-&gt;pool, l-&gt;nalloc * l-&gt;size);          /*              从内存池上给新结点分配数据区的内存，每个结点的数据区域都是一样大          */        if (last-&gt;elts == NULL) {              /*                  分配失败              */            return NULL;        }        last-&gt;nelts = 0;          /*              新扩容的链表没有使用过，nelts指向第一个元素          */        last-&gt;next = NULL;        l-&gt;last-&gt;next = last;          /*              将新添加的结点添加到链表末尾          */        l-&gt;last = last;          /*              链表的last指向也要修改          */    }    elt = (char *) last-&gt;elts + l-&gt;size * last-&gt;nelts;      /*          首地址加上已经使用的内存等于未使用内存的起始位置      */    last-&gt;nelts++;    return elt;}</code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;nginx数据类型：单向链表&quot;&gt;&lt;a href=&quot;#nginx数据类型：单向链表&quot; class=&quot;headerlink&quot; title=&quot;nginx数据类型：单向链表&quot;&gt;&lt;/a&gt;nginx数据类型：单向链表&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://img.</summary>
      
    
    
    
    <category term="Nginx" scheme="https://duwei19961021.github.io/categories/Nginx/"/>
    
    
    <category term="list" scheme="https://duwei19961021.github.io/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>nginx双向链表</title>
    <link href="https://duwei19961021.github.io/2021/03/21/ngx_queue/"/>
    <id>https://duwei19961021.github.io/2021/03/21/ngx_queue/</id>
    <published>2021-03-21T11:02:44.000Z</published>
    <updated>2021-03-22T02:50:53.399Z</updated>
    
    <content type="html"><![CDATA[<h4 id="nginx数据类型：双向链表"><a href="#nginx数据类型：双向链表" class="headerlink" title="nginx数据类型：双向链表"></a>nginx数据类型：双向链表</h4><pre><code class="c">struct ngx_queue_s {      /*          链表这个结构本身不带有任何数据，而是把这个链表结构挂载到业务数据结构上，实现了业务数据结构与链表结构的解耦      */    ngx_queue_t  *prev;    // 前驱指针    ngx_queue_t  *next;    // 后驱指针};</code></pre><p><img src="https://img.3amupupup.online/ngx_queue_2.png" alt="链表示例"></p><h5 id="双向链表提供的接口"><a href="#双向链表提供的接口" class="headerlink" title="双向链表提供的接口"></a>双向链表提供的接口</h5><pre><code class="c">ngx_queue_init(q);    // 初始化链表指向ngx_queue_empty(h);    // 判断链表是否为空ngx_queue_insert_head(h, x);    // 链表头插ngx_queue_insert_tail(h, x);    // 链表尾插ngx_queue_head(h);    // 获取链表第一个元素，h是哨兵位ngx_queue_last(h);    // 获取链表最后一个元素ngx_queue_sentinel(h);    // 获取哨兵结点ngx_queue_next(q);    // 获取结点q的下一个结qngx_queue_prev(q);    // 获取结点q的前一个结点ngx_queue_remove(x);    // 从链表中移除x结点ngx_queue_split(h, q, n);    // 切割链表ngx_queue_add(h, n);ngx_queue_data(q, type, link);// 以上都是宏函数ngx_queue_t *ngx_queue_middle(ngx_queue_t *queue);</code></pre><h5 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h5><ol><li><p>ngx_queue_init(q): 初始化链表</p><pre><code class="c">#define ngx_queue_init(q)                                                     \    (q)-&gt;prev = q;                                                            \    (q)-&gt;next = q/*    前驱、后驱指针都指向自己，当前结点是哨兵位*/</code></pre></li><li><p>ngx_queue_empty(h): 判断链表是否为空</p><pre><code class="c">#define ngx_queue_empty(h)                                                    \    (h == (h)-&gt;prev)/*    双向链表的前驱或者后驱指向的是自己时则为空(仅存在哨兵结点)*/</code></pre></li><li><p>ngx_queue_insert_head(h, x): 在头结点之后插入x结点(头插)</p><pre><code class="c">#define ngx_queue_insert_head(h, x)                                           \    (x)-&gt;next = (h)-&gt;next;                                                    \    (x)-&gt;next-&gt;prev = x;                                                      \    (x)-&gt;prev = h;                                                            \    (h)-&gt;next = x</code></pre></li><li><p>ngx_queue_insert_tail(h, x): 在链表的末尾添加新结点x(尾插)</p><pre><code class="c">#define ngx_queue_insert_tail(h, x)                                           \    (x)-&gt;prev = (h)-&gt;prev;                                                    \    (x)-&gt;prev-&gt;next = x;                                                      \    (x)-&gt;next = h;                                                            \    (h)-&gt;prev = x</code></pre></li><li><p>ngx_queue_head(h): 获取链表的第一个有效结点(除去哨兵位)</p><pre><code class="c">#define ngx_queue_head(h)                                                     \    (h)-&gt;next</code></pre></li><li><p>ngx_queue_last(h): 获取链表最后一个结点</p><pre><code>#define ngx_queue_last(h)                                                     \    (h)-&gt;prev</code></pre></li><li><p>ngx_queue_sentinel(h): 获取哨兵位</p><pre><code>#define ngx_queue_sentinel(h)                                                 \    (h)</code></pre></li><li><p>ngx_queue_next(q): 获取q的下一个结点</p><pre><code class="c">#define ngx_queue_next(q)                                                     \    (q)-&gt;next</code></pre></li><li><p>ngx_queue_prev(q): 获取q的前一个结点</p><pre><code class="c">#define ngx_queue_prev(q)                                                     \    (q)-&gt;prev</code></pre></li><li><p>ngx_queue_remove(x): 从链表中移除结点x</p><pre><code class="c">#define ngx_queue_remove(x)                                                   \    (x)-&gt;next-&gt;prev = (x)-&gt;prev;                                              \    (x)-&gt;prev-&gt;next = (x)-&gt;next;                                              \    (x)-&gt;prev = NULL;                                                         \    (x)-&gt;next = NULL</code></pre></li><li><p>ngx_queue_add</p><pre><code>#define ngx_queue_add(h, n)                                                   \    (h)-&gt;prev-&gt;next = (n)-&gt;next;                                              \    (n)-&gt;next-&gt;prev = (h)-&gt;prev;                                              \    (h)-&gt;prev = (n)-&gt;prev;                                                    \    (h)-&gt;prev-&gt;next = h;</code></pre></li><li><p>ngx_queue_data(q, type, link)</p><pre><code class="c">#define ngx_queue_data(q, type, link)                                         \    (type *) ((u_char *) q - offsetof(type, link))/*    可以通过业务结构体中ngx_queue_t数据结构的偏移量来得到业务主体的数据结构的指针地址，    实现了业务数据结构和链表结构的解耦*/</code></pre><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stddef.h&gt;/* #define ngx_queue_data(q, type, link)                                         \    (type *) ((u_char *) q - offsetof(type, link))*/struct data{    int* _a;    long _b;    char* _c;    float _d;    struct data* _e;};int main(){    printf(&quot;data结构中_a 偏移量 = %ld字节\n&quot;,offsetof(struct data, _a));    printf(&quot;data结构中_d 偏移量 = %ld字节\n&quot;,offsetof(struct data, _d));    struct data d;    int array[] = {1,2,3,4,5,6,7,8,9,10};    d._a = array;    d._b = 333;    d._c = &quot;duwei&quot;;    d._d = 3.14;    printf(&quot;d._c = %s\n&quot;,d._c);    printf(&quot;d._d = %f\n&quot;,d._d);    struct data *newP = (struct data*)((char*)&amp;(d._d) - offsetof(struct data, _d));    /*        将_d成员的地址转换成char*, 再减去_d相对data的偏移量(字节)，        再将得到的结果转换成struct data*就是d的首地址。    */    printf(&quot;newP-&gt;_c = %s\n&quot;,newP-&gt;_c);    printf(&quot;newP-&gt;_d = %f\n&quot;,newP-&gt;_d);    printf(&quot;d = %p, newP = %p\n&quot;,&amp;d,newP);    return 0;}</code></pre></li><li><p>ngx_queue_t *ngx_queue_middle(ngx_queue_t *queue): 获取链表的中间结点</p><pre><code class="c">/*    快慢指针获取中间结点*/ngx_queue_t *ngx_queue_middle(ngx_queue_t *queue){    ngx_queue_t  *middle, *next;    middle = ngx_queue_head(queue);      /*          头结点的下一个结点      */    if (middle == ngx_queue_last(queue)) {          /*              如果middle等于头结点的上一个结点，则链表只有两个元素 head 和 mid          */        return middle;    }    next = ngx_queue_head(queue);      /*          next保存链表的头结点之后的结点      */    for ( ;; ) {        middle = ngx_queue_next(middle);        next = ngx_queue_next(next);          /*              走到这里 middle、next都指向第二个有效结点          */        if (next == ngx_queue_last(queue)) {              /*                  当next走到末尾元素时，mid才走一半，所以mid是中间元素              */            return middle;        }        next = ngx_queue_next(next);          /*              next走的速度是middle的两倍          */        if (next == ngx_queue_last(queue)) {              /*                  走到末尾时，middle才走一半路程，此时指向中间位置              */            return middle;        }    }}</code></pre></li><li><p>void ngx_queue_sort(ngx_queue_t <em>queue, ngx_int_t (</em>cmp)(const ngx_queue_t *, const ngx_queue_t *)): 链表排序</p><pre><code class="c">voidngx_queue_sort(ngx_queue_t *queue,    ngx_int_t (*cmp)(const ngx_queue_t *, const ngx_queue_t *)){    ngx_queue_t  *q, *prev, *next;    q = ngx_queue_head(queue);    if (q == ngx_queue_last(queue)) {        return;    }    for (q = ngx_queue_next(q); q != ngx_queue_sentinel(queue); q = next) {        prev = ngx_queue_prev(q);        next = ngx_queue_next(q);        ngx_queue_remove(q);        do {            if (cmp(prev, q) &lt;= 0) {                break;            }            prev = ngx_queue_prev(prev);        } while (prev != ngx_queue_sentinel(queue));        ngx_queue_insert_after(prev, q);    }}</code></pre></li><li><p>ngx_queue_split(h, q, n): </p><p><img src="https://img.3amupupup.online/ngx_queue_2.png" alt="链表示例"></p><p><img src="https://img.3amupupup.online/ngx_queue_split_1.png" alt="切割链表"></p><pre><code class="c">#define ngx_queue_split(h, q, n)                                              \    (n)-&gt;prev = (h)-&gt;prev;                                                    \    (n)-&gt;prev-&gt;next = n;                                                      \    (n)-&gt;next = q;                                                            \    (h)-&gt;prev = (q)-&gt;prev;                                                    \    (h)-&gt;prev-&gt;next = h;                                                      \    (q)-&gt;prev = n;</code></pre><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>双向链表的数据结构中并未定义数据，而是通过将链表结构挂载到业务结构中通过offsetof计算出链表结构在业务结构中的偏移量，再减去偏移量就得到了业务结构的指针地址。实现了链表与数据的解耦。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;nginx数据类型：双向链表&quot;&gt;&lt;a href=&quot;#nginx数据类型：双向链表&quot; class=&quot;headerlink&quot; title=&quot;nginx数据类型：双向链表&quot;&gt;&lt;/a&gt;nginx数据类型：双向链表&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;stru</summary>
      
    
    
    
    <category term="Nginx" scheme="https://duwei19961021.github.io/categories/Nginx/"/>
    
    
    <category term="queue" scheme="https://duwei19961021.github.io/tags/queue/"/>
    
  </entry>
  
  <entry>
    <title>信息的表示和处理</title>
    <link href="https://duwei19961021.github.io/2021/03/20/information_representation_and_processing/"/>
    <id>https://duwei19961021.github.io/2021/03/20/information_representation_and_processing/</id>
    <published>2021-03-20T03:55:12.704Z</published>
    <updated>2021-03-20T03:55:12.704Z</updated>
    
    <content type="html"><![CDATA[<h4 id="2-1-信息存储"><a href="#2-1-信息存储" class="headerlink" title="2.1 信息存储"></a>2.1 信息存储</h4><ul><li>大多数计算机使用8位的块，或者字节(byte)，作为最小的可寻址的内存单位，而不是访问内存中单独的位。</li><li>C编译器把指针和类型联系起来，这样就可以根据指针值的类型，生成不同的机器级别代码来访问存储在指针所指向位置处的值。尽管C编译器维护着这个类型的信息，但是它生成的实际机器级程序不包含关于数据类型的信息。</li><li>机器级程序将内存视为一个非常大的字节数组，称为虚拟内存(virtual memory)。内存的每一个字节都是由唯一的数字标识的，称为地址(address)。所有地址的集合就称为虚拟地址空间(virtual address space)。</li></ul><h5 id="2-1-1-十六进制表示法"><a href="#2-1-1-十六进制表示法" class="headerlink" title="2.1.1 十六进制表示法"></a>2.1.1 十六进制表示法</h5><table><thead><tr><th align="center"></th><th align="left"></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td align="center">十六进制</td><td align="left">1</td><td>7</td><td>3</td><td>A</td><td>4</td></tr><tr><td align="center">二 进 制</td><td align="left">0001</td><td>0111</td><td>0011</td><td>1010</td><td>0100</td></tr></tbody></table><h5 id="2-1-2-字数据大小"><a href="#2-1-2-字数据大小" class="headerlink" title="2.1.2 字数据大小"></a>2.1.2 字数据大小</h5><ul><li><p>对于一个字长为w位的机器而言，虚拟地址的范围是0 ~ 2^w-1，程序最多访问2^w个字节。</p><p><img src="/image/image-20201023114928097.png" alt="image-20201023114928097"></p><p>举个例子：</p><p>32位操作系统，传输总线是32位，8bit为一个字节，那么在读或者写数据时一次就能传输32/8=4个字节。一个字长就是4字节。</p></li></ul><h5 id="2-1-3-寻址和字节顺序"><a href="#2-1-3-寻址和字节顺序" class="headerlink" title="2.1.3 寻址和字节顺序"></a>2.1.3 寻址和字节顺序</h5><ul><li>对于跨越多字节的程序对象，必须建立两个规则：① 这个对象的地址是什么，② 在内存上如何排列</li><li>多字节对象会被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。 </li></ul><p>排列表示一个对象的字节有两个通用规则：小端法 &amp; 大端法</p><p>低有效字节存储在低地址上，称为小端存储，反之则为大端存储。</p><p><img src="/image/image-20201023131136500.png" alt="image-20201023131136500"></p><p>C语言中字符串被编码为一个以null(其值为0)字符结尾的字符数组。</p><h5 id="2-1-6-布尔"><a href="#2-1-6-布尔" class="headerlink" title="2.1.6  布尔"></a>2.1.6  布尔</h5><ul><li><p>NOT: ~</p><pre><code class="c">int main(){    int a = 10; // 0000 0000 0000 0000 0000 0000 0000 1010    printf(&quot;%d\n&quot;,~a);  // 1111 1111 1111 1111 1111 1111 1111 0101 补                        // 1111 1111 1111 1111 1111 1111 1111 0100 反                        // 1000 0000 0000 0000 0000 0000 0000 1011 原}</code></pre></li><li><p>AND: &amp;</p><pre><code class="c">int main(){    int a = 10;         // 0000 0000 0000 0000 0000 0000 0000 1010    int b = 15;         // 0000 0000 0000 0000 0000 0000 0000 1111    printf(&quot;%d\n&quot;,a&amp;b); // 0000 0000 0000 0000 0000 0000 0000 1010}</code></pre></li><li><p>OR: |</p><pre><code class="c">int main(){    int a = 2;          // 0000 0000 0000 0000 0000 0000 0000 0010    int b = 11;         // 0000 0000 0000 0000 0000 0000 0000 1011    printf(&quot;%d\n&quot;,a|b); // 0000 0000 0000 0000 0000 0000 0000 1011}</code></pre></li><li><p>EXCLUSIVE-OR: ^</p><pre><code class="c">int main(){    int a = 10;         // 0000 0000 0000 0000 0000 0000 0000 1010    int b = 2;          // 0000 0000 0000 0000 0000 0000 0000 0010    printf(&quot;%d\n&quot;,a^b); // 0000 0000 0000 0000 0000 0000 0000 1000}</code></pre></li></ul><h5 id="2-1-9-移位运算"><a href="#2-1-9-移位运算" class="headerlink" title="2.1.9 移位运算"></a>2.1.9 移位运算</h5><pre><code class="c">int main(){    unsigned int a = 10;    // 0000 0000 0000 0000 0000 0000 0000 1010    a =  a &gt;&gt; 3;            // 0000 0000 0000 0000 0000 0000 0000 0001    printf(&quot;a = %d\n&quot;,a);   // 1,无符号右移补0    int b = -5;    // 原码: 1000 0000 0000 0000 0000 0000 0000 0101    // 反码: 1111 1111 1111 1111 1111 1111 1111 1010    // 补码: 1111 1111 1111 1111 1111 1111 1111 1011    b = b &lt;&lt; 3;    // 补码: 1111 1111 1111 1111 1111 1111 1101 1000    // 反码: 1111 1111 1111 1111 1111 1111 1101 0111    // 原码: 1000 0000 0000 0000 0000 0000 0010 1000    printf(&quot;b = %d\n&quot;,b);   // -40    int c = -5;    // 原码: 1000 0000 0000 0000 0000 0000 0000 0101    // 反码: 1111 1111 1111 1111 1111 1111 1111 1010    // 补码: 1111 1111 1111 1111 1111 1111 1111 1011    c = c &gt;&gt; 3;    // 补码: 1111 1111 1111 1111 1111 1111 1111 1111    // 反码: 1111 1111 1111 1111 1111 1111 1111 1110    // 补码: 1000 0000 0000 0000 0000 0000 0000 0001    printf(&quot;c = %d\n&quot;,c);   // -1,有符号数右移时补符号位}</code></pre><h4 id="2-2-整数表示"><a href="#2-2-整数表示" class="headerlink" title="2.2 整数表示"></a>2.2 整数表示</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;2-1-信息存储&quot;&gt;&lt;a href=&quot;#2-1-信息存储&quot; class=&quot;headerlink&quot; title=&quot;2.1 信息存储&quot;&gt;&lt;/a&gt;2.1 信息存储&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;大多数计算机使用8位的块，或者字节(byte)，作为最小的可寻址的内存单位，而不</summary>
      
    
    
    
    <category term="操作系统" scheme="https://duwei19961021.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://duwei19961021.github.io/2021/03/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>https://duwei19961021.github.io/2021/03/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-03-20T03:54:29.615Z</published>
    <updated>2021-03-20T03:54:29.615Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第九章：虚拟内存"><a href="#第九章：虚拟内存" class="headerlink" title="第九章：虚拟内存"></a>第九章：虚拟内存</h3><h6 id="1、什么是虚拟内存？"><a href="#1、什么是虚拟内存？" class="headerlink" title="1、什么是虚拟内存？"></a>1、什么是虚拟内存？</h6><p>虚拟内存是磁盘上(较低层)连续N个字节组成的数组，每个字节都有唯一的虚拟地址作为数组的索引，磁盘上数组的内容被缓存在主存中。(虚拟页存在于磁盘上)</p><p>物理内存被分隔成物理页(Physical Page,PP)。</p><p>VM系统将虚拟内存分隔成虚拟页(Virtual Page,VP)，虚拟页面的集合分为三个不相交的子集：</p><ol><li>未分配的(VM系统还未分配或者未创建的页，未分配的块没有任何数据和他们相关联，因为不占用任何磁盘空间)。</li><li>缓存的(已缓存在物理内存中的已分配页)。</li><li>未缓存的(未缓存在物理内存中的已分配页)。</li></ol><h6 id="2、DRAM缓存组织结构"><a href="#2、DRAM缓存组织结构" class="headerlink" title="2、DRAM缓存组织结构"></a>2、DRAM缓存组织结构</h6><ul><li>SRAM：表示位于cpu和主存之间的L1、L2、L3高速缓存。</li><li>DRAM：表示虚拟内存系统的缓存，它在主存中缓存虚拟页。</li><li>直   写：当 CPU 要将数据写入内存时 除了更新缓冲内存(高速缓存L1、L2、L3)上的数据外也将数据写在 DRAM 中 以维持主存与缓冲内存的一致性 当要写入内存的数据一多 速度自然就慢了下来 </li><li>回   写：每当 CPU 要将数据写入内存时 只会先更新缓冲内存(高速缓存L1、L2、L3)上的数据 随后再让缓冲内存在总线不塞车的时候 才把数据写回 DRAM 所以速度自然快得多</li></ul><h6 id="3、页表"><a href="#3、页表" class="headerlink" title="3、页表"></a>3、页表</h6><p>虚拟内存必须有某种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页(主存)。如果不命中还必须判断这个虚拟页存放在磁盘的哪个位置上，在物理页中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页。(操作系统为每个进程都维护一个独立的页表)</p><p>页表：将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表，操作系统负责维护页表的内容，以及在磁盘与DRAM之间来回传送页。</p><p><img src="/image/image-20201020134441586.png" alt="image-20201020134441586"></p><p>我们将假设每个PTE是由一个有效位(valid bit)和一个n位地址字段组成，有效位表明了该虚拟页当前是否被缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。 如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。否则，这个地址就指向该虚拟页在磁盘上的起始位置。</p><h6 id="4、缺页"><a href="#4、缺页" class="headerlink" title="4、缺页"></a>4、缺页</h6><p>DRAM缓存不命中称为缺页。</p><p>自己的理解：在cpu获取虚拟页中的数据时，地址翻译硬件去读页表的页表记录的有效位，如果有效位为0则推断出该虚拟页未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会在主存的PP(物理页)中选择一个被缓存的VP作为牺牲页，接下来将要缓存的vp从磁盘中加载出来缓存到主存上去(替换牺牲页)。</p><p><img src="/image/image-20201020140133328.png" alt="image-20201020140133328"></p><h6 id="5、地址翻译"><a href="#5、地址翻译" class="headerlink" title="5、地址翻译"></a>5、地址翻译</h6><p>当页面命中时，CPU硬件执行的步骤：</p><ol><li>处理器生成一个虚拟地址，并把它传送给MMU。</li><li>MMU生成PTE地址，并从高速缓存/主存请求得到它。</li><li>高速缓存/主存向MMU返回PTE。</li><li>MMU构造物理地址，并把它传给告诉缓存/主存。</li><li>高速缓存/主存返回所请求的数据字给处理器。</li></ol><p><img src="/image/image-20201020145055727.png" alt="image-20201020145055727"></p><p>缺页，CPU硬件执行步骤：</p><ol><li>处理器生成一个虚拟地址，并把它传送给MMU。</li><li>MMU生成PTE地址，并从高速缓存/主存请求得到它。</li><li>高速缓存/主存向MMU返回PTE。</li><li>PTE中的有效为是0，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。</li><li>缺页处理程序确定出物理内存中的牺牲页，如果这个页面修改了则把它换出到磁盘。</li><li>缺页处理程序页面调入新的页面，并更新内存中的PTE。</li><li>缺页处理程序返回到原来的进程，再次执行导致缺页的指令，CPU将引起缺页的虚拟地址重新发送给MMU。</li></ol><p><img src="/image/image-20201020145822292.png" alt="image-20201020145822292"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;第九章：虚拟内存&quot;&gt;&lt;a href=&quot;#第九章：虚拟内存&quot; class=&quot;headerlink&quot; title=&quot;第九章：虚拟内存&quot;&gt;&lt;/a&gt;第九章：虚拟内存&lt;/h3&gt;&lt;h6 id=&quot;1、什么是虚拟内存？&quot;&gt;&lt;a href=&quot;#1、什么是虚拟内存？&quot; class=&quot;</summary>
      
    
    
    
    <category term="操作系统" scheme="https://duwei19961021.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>虚拟内存</title>
    <link href="https://duwei19961021.github.io/2021/03/20/virtual_memory/"/>
    <id>https://duwei19961021.github.io/2021/03/20/virtual_memory/</id>
    <published>2021-03-20T03:51:57.552Z</published>
    <updated>2021-04-05T16:48:04.685Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第九章：虚拟内存"><a href="#第九章：虚拟内存" class="headerlink" title="第九章：虚拟内存"></a>第九章：虚拟内存</h3><h5 id="9-1-物理和虚拟寻址"><a href="#9-1-物理和虚拟寻址" class="headerlink" title="9.1 物理和虚拟寻址"></a>9.1 物理和虚拟寻址</h5><p>物理寻址：</p><p><img src="/Users/duwei/Desktop/source/image/image-20201023182237165.png" alt="image-20201023182237165"></p><p>该示例的上下文是一条加载指令。当cpu加载这条指令时，会生成一个有效物理地址，通过内存总线，把它传递给主存。主存取出从物理地址4开始的四个字节，并将它返回给cpu，cpu会将它存放在一个寄存器里。</p><p>虚拟寻址：</p><p><img src="/Users/duwei/Desktop/source/image/image-20201023182622615.png" alt="image-20201023182622615"></p><p>使用虚拟地址，cpu通过生成一个虚拟地址(Virtual Address,VA)来访问主存，这个虚拟地址在被送到主存之前先转换成适当的虚拟地址(Memory Manager Unit简称MMU：内存管理单元，利用存放在主存中的查询表来动态翻译虚拟地址)，主存收到翻译过的地址(物理地址)之后从物理内存上取出数据并返回给cpu。</p><h5 id="9-2-地址空间"><a href="#9-2-地址空间" class="headerlink" title="9.2 地址空间"></a>9.2 地址空间</h5><p>地址空间：一个非负整数地址的有序集合。为了简化讨论，总是假设使用的是线性地址空间。</p><p>在一个带虚拟内存的系统，CPU从一个有N=2^n个地址的空间中生成虚拟地址，称为虚拟地址空间。</p><p>{0, 1, 2, 3,…,N-1}</p><p>一个包含N=2^n个地址的虚拟地址空间叫做一个n位地址空间。例如32位操作系统(2^32)、64位操作系统(2^64)。</p><p>主存中的每个字节都有一个选自虚拟空间的地址和一个选自物理空间的地址。</p><table><thead><tr><th align="center">虚拟地址位数(n)</th><th align="center">虚拟地址数(N)</th><th align="center">最大的可能虚拟地址</th></tr></thead><tbody><tr><td align="center">8</td><td align="center">2^8=256 byte</td><td align="center">2^8-1=255</td></tr><tr><td align="center">16</td><td align="center">2^16=64 K</td><td align="center">2^16-1</td></tr><tr><td align="center">32</td><td align="center">2^32 = 4096M = 4G</td><td align="center">2^32-1</td></tr><tr><td align="center">48</td><td align="center">2^48 = 256T</td><td align="center">2^48-1</td></tr><tr><td align="center">64</td><td align="center">2^64 = 16E</td><td align="center">2^64-1</td></tr></tbody></table><h5 id="9-3-虚拟内存作为缓存工具"><a href="#9-3-虚拟内存作为缓存工具" class="headerlink" title="9.3 虚拟内存作为缓存工具"></a>9.3 虚拟内存作为缓存工具</h5><h6 id="1、什么是虚拟内存？"><a href="#1、什么是虚拟内存？" class="headerlink" title="1、什么是虚拟内存？"></a>1、什么是虚拟内存？</h6><p>虚拟内存是磁盘上(较低层)连续N个字节组成的数组，每个字节都有唯一的虚拟地址作为数组的索引，磁盘上数组的内容(指的是数据)被缓存在主存中。(虚拟页存在于磁盘上)</p><p>物理内存被分隔成物理页(Physical Page,PP)。</p><p>VM系统将虚拟内存分隔成虚拟页(Virtual Page,VP)。</p><p>虚拟页面的集合分为三个不相交的子集：</p><ol><li><p>未分配的(VM系统还未分配或者未创建的页，未分配的块没有任何数据和他们相关联，所以不占用任何磁盘空间，linux命令free在计算内存使用量时，未分配的 不会被记入)。</p></li><li><p>缓存的(已缓存在物理内存中的已分配页)。</p></li><li><p>未缓存的(未缓存在物理内存中的已分配页)。</p><p><img src="/image/image-20201026121811373.png" alt="image-20201026121811373"></p></li></ol><h6 id="2、DRAM缓存组织结构"><a href="#2、DRAM缓存组织结构" class="headerlink" title="2、DRAM缓存组织结构"></a>2、DRAM缓存组织结构</h6><ul><li>SRAM：表示位于cpu和主存之间的L1、L2、L3高速缓存。</li><li>DRAM：表示虚拟内存系统的缓存，它在主存中缓存虚拟页。</li><li>直   写：当 CPU 要将数据写入内存时 除了更新缓冲内存(高速缓存L1、L2、L3)上的数据外也将数据写在 DRAM 中 以维持主存与缓冲内存的一致性 当要写入内存的数据一多 速度自然就慢了下来 </li><li>回   写：每当 CPU 要将数据写入内存时 只会先更新缓冲内存(高速缓存L1、L2、L3)上的数据 随后再让缓冲内存在总线不塞车的时候 才把数据写回 DRAM 所以速度自然快得多</li></ul><h6 id="3、页表-将虚拟页映射到物理页"><a href="#3、页表-将虚拟页映射到物理页" class="headerlink" title="3、页表(将虚拟页映射到物理页)"></a>3、页表(将虚拟页映射到物理页)</h6><p>虚拟内存必须有某种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页(主存)。如果不命中还必须判断这个虚拟页存放在磁盘的哪个位置上，在物理页中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页。(操作系统为每个进程都维护一个独立的页表)</p><p>页表：将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表，操作系统负责维护页表的内容，以及在磁盘与DRAM之间来回传送页。</p><p><img src="/image/image-20201020134441586.png" alt="image-20201020134441586"></p><p>我们将假设每个PTE是由一个有效位(valid bit)和一个n位地址字段组成，有效位表明了该虚拟页当前是否被缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。 如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。否则，这个地址就指向该虚拟页在磁盘上的起始位置。</p><ul><li><p>确定虚拟地址大小(n)和页大小(P)的组合需要的PTE数量。</p><table><thead><tr><th align="center">n(位)</th><th align="center">P=2^p</th><th align="center">PTE数量</th></tr></thead><tbody><tr><td align="center">16</td><td align="center">4K</td><td align="center">2^16 / 2^12  = 16</td></tr><tr><td align="center">16</td><td align="center">8K</td><td align="center">2^16 / 2^13 = 8</td></tr><tr><td align="center">32</td><td align="center">4K</td><td align="center">2^32 / 2^12 = 2^20</td></tr><tr><td align="center">32</td><td align="center">8K</td><td align="center">2^32 / 2^13 = 2^19</td></tr></tbody></table></li></ul><h6 id="4、缺页"><a href="#4、缺页" class="headerlink" title="4、缺页"></a>4、缺页</h6><p>DRAM缓存不命中称为缺页。</p><p>自己的理解：在cpu获取虚拟页中的数据时，地址翻译硬件去读页表的页表记录的有效位，如果有效位为0则推断出该虚拟页未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会在主存的PP(物理页)中选择一个被缓存的VP作为牺牲页(如果牺牲页中的数据被修改过那么就会将数据写会磁盘)，接下来将要被缓存的vp从磁盘中加载出来缓存到主存上去(替换牺牲页)。</p><ul><li><p>CPU引用VP3中的一个字，地址翻译硬件将虚拟地址作为一个索引(虚拟地址分为两部分：虚拟页号[VPN:virtual page number]和虚拟页偏移量[VPO:virtual page offset]，使用虚拟页号作为索引)来定位PTE3，通过读取PTE3：有效为为0且地址不为null，所以得出VP3没有被缓存在物理内存中且得到了VP3的磁盘地址，此时触发缺页异常，缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页(PP3中的VP4，如果VP4的内容被修改了，那么内核就会将VP4的数据复制回磁盘)，无论哪种情况，内核都会修改VP4的页表条目，反映VP4不在缓存在主存中的事实。</p><p><img src="/image/image-20201020140133328.png" alt="image-20201020140133328"></p></li><li><p>随后，内核从磁盘复制VP3到内存PP3，并更新PTE3(将有效为设置为1，地址位设置为物理页号)，随后返回，当异常处理程序返回的时候，它会重启导致缺页的指令，该指令会把缺页的虚拟地址重新发送给地址翻译硬件，但是此时VP3已经缓存在物理内存中了，那么页命中就能由地址翻译硬件正常处理了。</p><p><img src="/image/image-20201026140413910.png" alt="image-20201026140413910"></p></li></ul><p>5、分配页面</p><ul><li><p>操作系统分配一个新的虚拟内存页时对页表的影响，例如：调用mallooc，在这个实例中，VP5的分配过程是在磁盘创建空间并更新PTE5，并使它指向磁盘上这个新创建的页面。此过程中并没有分配物理内存哦。</p><p><img src="/image/image-20201026141028175.png" alt="image-20201026141028175"></p></li></ul><hr><h5 id="9-6-地址翻译"><a href="#9-6-地址翻译" class="headerlink" title="9.6 地址翻译"></a>9.6 地址翻译</h5><ul><li><p>地址翻译符号</p><p><img src="/image/image-20201026153155106.png" alt="image-20201026153155106"></p></li><li><p>MMU利用虚拟地址包含的VPN寻找PTE，将页表条目中的PPN和VPO串联起来就得到响应的物理地址(因为vp和pp都是P字节，所以物理页和虚拟页的偏移量相同)</p><p><img src="/image/image-20201026153233283.png" alt="image-20201026153233283"></p></li></ul><p>当页面命中时，CPU硬件执行的步骤：</p><ol><li>处理器生成一个虚拟地址，并把它传送给MMU。</li><li>MMU生成PTE地址，并从高速缓存/主存请求得到它。</li><li>高速缓存/主存向MMU返回PTE。</li><li>MMU构造物理地址，并把它传给告诉缓存/主存。</li><li>高速缓存/主存返回所请求的数据字给处理器。</li></ol><p><img src="/image/image-20201020145055727.png" alt="image-20201020145055727"></p><p>缺页，CPU硬件执行步骤：</p><ol><li>处理器生成一个虚拟地址，并把它传送给MMU。</li><li>MMU生成PTE地址，并从高速缓存/主存请求得到它。</li><li>高速缓存/主存向MMU返回PTE。</li><li>PTE中的有效为是0，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。</li><li>缺页处理程序确定出物理内存中的牺牲页，如果这个页面修改了则把它换出到磁盘。</li><li>缺页处理程序页面调入新的页面，并更新内存中的PTE。</li><li>缺页处理程序返回到原来的进程，再次执行导致缺页的指令，CPU将引起缺页的虚拟地址重新发送给MMU。</li></ol><p><img src="/image/image-20201020145822292.png" alt="image-20201020145822292"></p><ul><li><p>给定一个32位的虚拟地址空间和一个24位的物理地址，对于下列页面大小P。</p><table><thead><tr><th align="center">P</th><th align="center">VPN位数</th><th align="center">VPO位数</th><th align="center">PPN位数</th><th align="center">PPO位数</th></tr></thead><tbody><tr><td align="center">1KB (2^p=1024,p=10)</td><td align="center">22</td><td align="center">10</td><td align="center">14</td><td align="center">10</td></tr><tr><td align="center">2KB(2^p=2048,p=11)</td><td align="center">21</td><td align="center">11</td><td align="center">13</td><td align="center">11</td></tr><tr><td align="center">4KB(2^p=4096,p=12)</td><td align="center">20</td><td align="center">12</td><td align="center">12</td><td align="center">12</td></tr><tr><td align="center">8KB(2^p=8192,p=13)</td><td align="center">19</td><td align="center">13</td><td align="center">11</td><td align="center">13</td></tr></tbody></table><p>(常说的32位和64位操作系统，指的就是页表条目PTE的长度。)</p></li></ul><h6 id="1、多级页表"><a href="#1、多级页表" class="headerlink" title="1、多级页表"></a>1、多级页表</h6><p>到目前为止，一直假设系统只用一个单独的页表进行地址翻译。但是如果我们有一个32位地址空间、4kb的页和一个4字节的PTE，那么即使应用所引用的只是虚拟空间中很小的一部分，也总是需要4MB的页表驻留内存。(32位地址空间，总共有2^32个内存地址，一个虚拟页的大小是4KB，那么总共有 2^32/2^12=2^20 个内存页，一个内存页需要一个PTE，一个PTE是4字节，那么页表总共大小是：2^20 * 2^12 = 2^32字节 = 2^32 / 2^10 KB = 2^12 / 2^10 MB = 4MB。在没有优化的情况下，一张独立页表在内存中要占用4M物理内存)</p><hr><h6 id="计算机中的字，双字以及存储"><a href="#计算机中的字，双字以及存储" class="headerlink" title="计算机中的字，双字以及存储"></a>计算机中的字，双字以及存储</h6><ul><li>字节(byte)：一个字节由8位二进制数组成</li><li>字(word)：</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;第九章：虚拟内存&quot;&gt;&lt;a href=&quot;#第九章：虚拟内存&quot; class=&quot;headerlink&quot; title=&quot;第九章：虚拟内存&quot;&gt;&lt;/a&gt;第九章：虚拟内存&lt;/h3&gt;&lt;h5 id=&quot;9-1-物理和虚拟寻址&quot;&gt;&lt;a href=&quot;#9-1-物理和虚拟寻址&quot; class</summary>
      
    
    
    
    <category term="操作系统" scheme="https://duwei19961021.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="内存" scheme="https://duwei19961021.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>nginx缓冲区</title>
    <link href="https://duwei19961021.github.io/2021/03/18/ngx_buf/"/>
    <id>https://duwei19961021.github.io/2021/03/18/ngx_buf/</id>
    <published>2021-03-18T07:14:01.000Z</published>
    <updated>2021-03-31T03:42:05.372Z</updated>
    
    <content type="html"><![CDATA[<h4 id="nginx缓冲区"><a href="#nginx缓冲区" class="headerlink" title="nginx缓冲区"></a>nginx缓冲区</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><pre><code class="c">struct ngx_buf_s {    u_char          *pos;           /* 待处理数据的开始标记  */    u_char          *last;          /* 待处理数据的结尾标记 */    off_t            file_pos;    off_t            file_last;    u_char          *start;         /* start of buffer */    u_char          *end;           /* end of buffer */    ngx_buf_tag_t    tag;    ngx_file_t      *file;    ngx_buf_t       *shadow;    /* the buf&#39;s content could be changed */    unsigned         temporary:1;   /* 标志位，为1时，内存可修改 */    /*     * the buf&#39;s content is in a memory cache or in a read only memory     * and must not be changed     */    unsigned         memory:1;    /* the buf&#39;s content is mmap()ed and must not be changed */    unsigned         mmap:1;    unsigned         recycled:1;    unsigned         in_file:1;    unsigned         flush:1;    unsigned         sync:1;    unsigned         last_buf:1;    unsigned         last_in_chain:1;    unsigned         last_shadow:1;    unsigned         temp_file:1;    /* STUB */ int   num;};</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;nginx缓冲区&quot;&gt;&lt;a href=&quot;#nginx缓冲区&quot; class=&quot;headerlink&quot; title=&quot;nginx缓冲区&quot;&gt;&lt;/a&gt;nginx缓冲区&lt;/h4&gt;&lt;h5 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Nginx" scheme="https://duwei19961021.github.io/categories/Nginx/"/>
    
    
    <category term="缓冲区" scheme="https://duwei19961021.github.io/tags/%E7%BC%93%E5%86%B2%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>nginx内存池</title>
    <link href="https://duwei19961021.github.io/2021/03/18/ngx_mem_pool/"/>
    <id>https://duwei19961021.github.io/2021/03/18/ngx_mem_pool/</id>
    <published>2021-03-18T07:14:01.000Z</published>
    <updated>2021-03-27T14:58:18.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="nginx内存池"><a href="#nginx内存池" class="headerlink" title="nginx内存池"></a>nginx内存池</h4><h5 id=""><a href="#" class="headerlink" title=""></a><img src="http://img.3amupupup.online/ngx_mem_pool_struct_3.png" alt="内存池结构"></h5><p><img src="https://img.3amupupup.online/ngx_mem_pool_5.png" alt="内存池结构"></p><pre><code class="c">typedef struct {    u_char               *last;     /* 内存池中未使用内存的开始节点地址 */    u_char               *end;      /* 内存池的结束地址 */    ngx_pool_t           *next;     /* 指向下一个内存池,组成链表 */    ngx_uint_t            failed;   /* 失败次数 */} ngx_pool_data_t;// typedef struct ngx_pool_s ngx_pool_t;struct ngx_pool_s {    ngx_pool_data_t       d;        /* 内存池的数据区域(小块数据) */    size_t                max;      /* 最大每次可分配内存,大于这个值将被添加到大块数据链表上,小于这个值将被添加到小块数据链表上 */    ngx_pool_t           *current;  /* 指向当前的内存池指针地址。ngx_pool_t链表上最后一个缓存池结构 */    ngx_chain_t          *chain;    /* 缓冲区链表 */    ngx_pool_large_t     *large;    /* 存储大块数据的链表 */    ngx_pool_cleanup_t   *cleanup;  /* 可自定义回调函数，清除内存块分配的内存 */    ngx_log_t            *log;      /* 日志 */};// typedef struct ngx_pool_cleanup_s  ngx_pool_cleanup_t;struct ngx_pool_cleanup_s {    ngx_pool_cleanup_pt   handler;  /* 清理的回调函数 */    void                 *data;     /* 指向存储的数据地址 */    ngx_pool_cleanup_t   *next;     /* 下一个ngx_pool_cleanup_t */};</code></pre><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><ol><li><p>ngx_calloc: 分配内存并初始化，底层调用的是malloc和memset。</p><pre><code class="c">void *ngx_calloc(size_t size, ngx_log_t *log){    void  *p;    p = ngx_alloc(size, log);    if (p) {        ngx_memzero(p, size);          /*              ngx_memzero是个宏函数，底层实际调用memset，src/core/ngx_string.h              #define ngx_memzero(buf, n)       (void) memset(buf, 0, n)          */    }    return p;}</code></pre></li></ol><ol start="2"><li><p>ngx_alloc: 分配内存，底层调用的是malloc。</p><pre><code class="c">void *   ngx_alloc(size_t size, ngx_log_t *log)   {       void  *p;       p = malloc(size);         /*              底层去调用malloc分配内存         */       if (p == NULL) {           ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,                         &quot;malloc(%uz) failed&quot;, size);       }       ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, log, 0, &quot;malloc: %p:%uz&quot;, p, size);       return p;   }</code></pre></li><li><p>ngx_create_pool: 创建内存池结点</p><pre><code class="c">ngx_pool_t *ngx_create_pool(size_t size, ngx_log_t *log){    ngx_pool_t  *p;    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, log);      /*          #define ngx_memalign(alignment, size, log)  ngx_alloc(size, log)，          而ngx_alloc实际上是去调用malloc      */    if (p == NULL) {        return NULL;    }    p-&gt;d.last = (u_char *) p + sizeof(ngx_pool_t);      /*          p是通过malloc申请得到的内存的首地址，前sizeof(ngx_pool_t)字节的内存要留给内存池的管理结构(我也叫他控制中心)，          控制中心之后的内存是给申请者使用的。last是申请者能够使用内存的起始位置，end是结束位置(由数据结构得知)      */    p-&gt;d.end = (u_char *) p + size;      /*          end指向申请得到的内存的末尾位置，          p是首地址，加上size就是结束地址即end的指向位置，          内存的申请者总共申请了size个字节的内存，能够使用的内存为：size - sizeof(ngx_pool_t)      */    p-&gt;d.next = NULL;      /*          内存池通过指针相连，组成一个链表，下一个结点在创建时应当指向NULL      */    p-&gt;d.failed = 0;    size = size - sizeof(ngx_pool_t);    p-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;      /*     NGX_MAX_ALLOC_FROM_POOL should be (ngx_pagesize - 1), i.e. 4095 on x86.     On Windows NT it decreases a number of locked pages in a kernel.     max取size和操作系统弄内存页二者中较小的值     */    p-&gt;current = p;    p-&gt;chain = NULL;    p-&gt;large = NULL;    p-&gt;cleanup = NULL;    p-&gt;log = log;      /*          只有缓存池的父节点，才会用到这几个成员  ，子节点只挂载在p-&gt;d.next,并且只负责p-&gt;d的数据内容      */    return p;}</code></pre></li><li><p>ngx_destroy_pool: 销毁内存池结点</p><pre><code class="c">voidngx_destroy_pool(ngx_pool_t *pool){    ngx_pool_t          *p, *n;    ngx_pool_large_t    *l;    ngx_pool_cleanup_t  *c;    for (c = pool-&gt;cleanup; c; c = c-&gt;next) {        if (c-&gt;handler) {            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0,                           &quot;run cleanup: %p&quot;, c);            c-&gt;handler(c-&gt;data);        }    }      /*          只有父结点才有cleanup链表，          cleanup链表的结点结构有三个成员：清理函数handler、指向存储数据的data、指向下一个结点的next          这里遍历cleanup链表，调用handler清理data      */#if (NGX_DEBUG)    // 编译debug级别，如果为true，会打印日志    /*     * we could allocate the pool-&gt;log from this pool     * so we cannot use this log while free()ing the pool     */    for (l = pool-&gt;large; l; l = l-&gt;next) {        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0, &quot;free: %p&quot;, l-&gt;alloc);    }    for (p = pool, n = pool-&gt;d.next; /* void */; p = n, n = n-&gt;d.next) {        ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0,                       &quot;free: %p, unused: %uz&quot;, p, p-&gt;d.end - p-&gt;d.last);        if (n == NULL) {            break;        }    }#endif    for (l = pool-&gt;large; l; l = l-&gt;next) {        if (l-&gt;alloc) {            ngx_free(l-&gt;alloc);        }    }      /*          只有父结点才有large链表，          遍历large(大块数据链表)链表，释放alloc指针指向的存储数据的内存          #define ngx_free          free          由此可知ngx_free是个宏，底层调用的还是free，这里直接将大块数据内存还给了操作系统      */    for (p = pool, n = pool-&gt;d.next; /* void */; p = n, n = n-&gt;d.next) {        ngx_free(p);          /*              至此，父结点上的large链表以及cleanup链表都被清理了，然后循环清理内存池结点，              小块数据内存是分配在内存池结点上的，和其控制中心(ngx_pool_t)是连续的，              释放时直接释放当前结点就行了          */          /*              至此清理工作结束。              但是有个小疑问：chain(缓冲区)链表为啥没有被清理？          */        if (n == NULL) {            break;        }    }}</code></pre></li><li><p>ngx_reset_pool: 清理内存池结点</p><pre><code class="c">voidngx_reset_pool(ngx_pool_t *pool){    ngx_pool_t        *p;    ngx_pool_large_t  *l;    for (l = pool-&gt;large; l; l = l-&gt;next) {        if (l-&gt;alloc) {            ngx_free(l-&gt;alloc);        }    }      /*          清理large链表      */    for (p = pool; p; p = p-&gt;d.next) {        p-&gt;d.last = (u_char *) p + sizeof(ngx_pool_t);        p-&gt;d.failed = 0;    }      /*          重置小数据块区域的内存，注意这里是修改last的指向，将last重新指向起始位置，          内存并没有被擦除，因为是小数据块内存，这里没有将其归还给操作系统，          目的是避免频繁的malloc和free产生内存碎片问题，频繁调用这两个函数也会给          操作系统带来额外的消耗。      */    pool-&gt;current = pool;    pool-&gt;chain = NULL;    pool-&gt;large = NULL;}</code></pre></li><li><p>ngx_palloc: 向内存池申请内存的函数</p><pre><code class="c">void *ngx_palloc(ngx_pool_t *pool, size_t size){#if !(NGX_DEBUG_PALLOC)      /*          这里是个条件编译，如果没开启ngx palloc debug就会根据size决定调用ngx_palloc_small还是                              ngx_palloc_large，如果开启了debug则一律调用ngx_palloc_large      */    if (size &lt;= pool-&gt;max) {        return ngx_palloc_small(pool, size, 1);    }#endif    return ngx_palloc_large(pool, size);}</code></pre></li><li><p>ngx_palloc_small: 分配小块数据内存的函数，调用这个函数所分配的内存都是在内存池结点上</p><pre><code class="c">static ngx_inline void *ngx_palloc_small(ngx_pool_t *pool, size_t size, ngx_uint_t align){    u_char      *m;    ngx_pool_t  *p;    p = pool-&gt;current;    do {        m = p-&gt;d.last;          /*              m保存了last的指向，last &lt;-&gt; end 之间是未被使用的内存          */        if (align) {            m = ngx_align_ptr(m, NGX_ALIGNMENT);        }          /*              align，暂时不懂是啥意思          */        if ((size_t) (p-&gt;d.end - m) &gt;= size) {            p-&gt;d.last = m + size;            return m;        }          /*              如果end到m(即last)之间的字节数大于size，那么这个内存池结点上的足够申请者使用，              则将last后移size个字节并返回之前last的指向的内存的地址供调用者使用          */        p = p-&gt;d.next;    } while (p);    return ngx_palloc_block(pool, size);      /*          走到这里说明内存池的所有结点上都没有足够的空间分配出去，          此时则调用ngx_palloc_block新开一个内存池的节点(扩容)      */}</code></pre></li><li><p>ngx_palloc_large: 分配大块数据内存的函数，调用这个函数所分配的内存都是在large链表上</p><pre><code class="c">static void *ngx_palloc_large(ngx_pool_t *pool, size_t size){    void              *p;    ngx_uint_t         n;    ngx_pool_large_t  *large;    p = ngx_alloc(size, pool-&gt;log);      /*          底层调用malloc分配内存      */        if (p == NULL) {        return NULL;    }    n = 0;    for (large = pool-&gt;large; large; large = large-&gt;next) {        if (large-&gt;alloc == NULL) {            large-&gt;alloc = p;            return p;        }          /*              遍历large链表，寻找空闲结点，找到了则将large链表上的空闲结点的alloc指向刚刚申请的内存p          */        if (n++ &gt; 3) {            break;        }          /*              如果找了三次还没找到那就不找了，避免链表过长时查找效率低          */    }    large = ngx_palloc_small(pool, sizeof(ngx_pool_large_t), 1);      /*          在内存池结点的小块数据内存上给large的控制中心结构ngx_pool_large_t分配一块内存      */    if (large == NULL) {        ngx_free(p);          /*              如果large分配失败p是要释放的，避免内存泄露          */        return NULL;    }    large-&gt;alloc = p;    large-&gt;next = pool-&gt;large;    pool-&gt;large = large;      /*          新开的large结点变为large链表的头结点。      */    return p;}</code></pre></li><li><p>ngx_palloc_block: 添加新的内存池结点</p><pre><code class="c">static void *ngx_palloc_block(ngx_pool_t *pool, size_t size){    u_char      *m;    size_t       psize;    ngx_pool_t  *p, *new;    psize = (size_t) (pool-&gt;d.end - (u_char *) pool);      /*          要新创建的内存池的结点的size是根据头结点的size创建的      */    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool-&gt;log);      /*          申请psize大小的内存块      */    if (m == NULL) {        return NULL;    }    new = (ngx_pool_t *) m;      /*          类型转换      */    new-&gt;d.end = m + psize;      /*          end指向末尾      */    new-&gt;d.next = NULL;      /*          下一个结点指针 指向NULL避免野指针      */    new-&gt;d.failed = 0;    m += sizeof(ngx_pool_data_t);      /*          前sizeof(ngx_pool_data_t)个字节留给ngx_pool_data_t结构使用，          这里用的比较巧妙，细品细品，此时有点惊叹设计者的做法。          因为创建的是子节点，所以max、current指针、缓冲区链表指针、large链表指针、          cleanup链表指针，这几个成员所占的内存都可以分配出去给调用者使用(子结点用不到这几个成员)，          避免了空间浪费。      */    m = ngx_align_ptr(m, NGX_ALIGNMENT);    new-&gt;d.last = m + size;      /*          移动last size个字节，标识这段内存已经被分配出去了      */    for (p = pool-&gt;current; p-&gt;d.next; p = p-&gt;d.next) {        if (p-&gt;d.failed++ &gt; 4) {            pool-&gt;current = p-&gt;d.next;        }    }      /*          每遍历一个结点failed++，当failed超过了4时，current会指向新子结点，          这么做可以避免遍历整个链表(如果链表足够长，遍历一次效率比较低)      */    p-&gt;d.next = new;    return m;}</code></pre></li><li><p>ngx_pnalloc: 开辟内存的函数，根据size去调用不同的函数</p><pre><code class="c">void *ngx_pnalloc(ngx_pool_t *pool, size_t size){#if !(NGX_DEBUG_PALLOC)    if (size &lt;= pool-&gt;max) {        return ngx_palloc_small(pool, size, 0);    }#endif    return ngx_palloc_large(pool, size);}</code></pre></li><li><p>ngx_pcalloc: 申请一块内存并初始化为0值</p><pre><code class="c">void *ngx_pcalloc(ngx_pool_t *pool, size_t size){    void *p;    p = ngx_palloc(pool, size);    if (p) {        ngx_memzero(p, size);    }    return p;}</code></pre></li><li><p>ngx_pmemalign:</p><pre><code class="c">void *ngx_pmemalign(ngx_pool_t *pool, size_t size, size_t alignment){    void              *p;    ngx_pool_large_t  *large;    p = ngx_memalign(alignment, size, pool-&gt;log);    if (p == NULL) {        return NULL;    }    large = ngx_palloc_small(pool, sizeof(ngx_pool_large_t), 1);    if (large == NULL) {        ngx_free(p);        return NULL;    }    large-&gt;alloc = p;    large-&gt;next = pool-&gt;large;    pool-&gt;large = large;    return p;}</code></pre></li><li><p>ngx_pfree: 释放large链表上的内存p</p><pre><code class="c">ngx_int_tngx_pfree(ngx_pool_t *pool, void *p){    ngx_pool_large_t  *l;    for (l = pool-&gt;large; l; l = l-&gt;next) {        if (p == l-&gt;alloc) {              /*                  遍历large链表，查找p所在的节点，如果large链表足够长时，这个函数的效率偏低              */            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0,                           &quot;free: %p&quot;, l-&gt;alloc);            ngx_free(l-&gt;alloc);              /*                  实际调用的还是free              */            l-&gt;alloc = NULL;            return NGX_OK;        }    }    return NGX_DECLINED;}</code></pre></li><li><p>ngx_pool_cleanup_add: cleanup机制设计的比较灵活，pool-&gt;cleanup是一个链表，每个ngx_pool_cleanup_t的数据结构上保存这指向的内存地址和回调清理函数，通过这个机制可以很方便的管理一些特殊的内存类型，比如文件描述符、自定义类型。</p><pre><code class="c">ngx_pool_cleanup_t *ngx_pool_cleanup_add(ngx_pool_t *p, size_t size){    ngx_pool_cleanup_t  *c;    c = ngx_palloc(p, sizeof(ngx_pool_cleanup_t));      /*          给cleanup的控制中心结构分配内存，分配在内存池小块数据内存上的。      */    if (c == NULL) {        return NULL;    }    if (size) {        c-&gt;data = ngx_palloc(p, size);        if (c-&gt;data == NULL) {            return NULL;        }    } else {        c-&gt;data = NULL;    }      /*          根据size决定是否分配数据区，数据区分配的内存在哪据size的大小而定，          可能在小数据块内存上也可能在large链表上      */    c-&gt;handler = NULL;    c-&gt;next = p-&gt;cleanup;    p-&gt;cleanup = c;      /*          头插进cleanup链表      */    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, p-&gt;log, 0, &quot;add cleanup: %p&quot;, c);    return c;}</code></pre><ol><li>ngx_pool_run_cleanup_file: 清理cleanup链表上的文件描述符fd，时间复杂度O(n)，链表过长时效率偏低</li></ol><pre><code class="c">voidngx_pool_run_cleanup_file(ngx_pool_t *p, ngx_fd_t fd){    ngx_pool_cleanup_t       *c;    ngx_pool_cleanup_file_t  *cf;    for (c = p-&gt;cleanup; c; c = c-&gt;next) {        if (c-&gt;handler == ngx_pool_cleanup_file) {            cf = c-&gt;data;            if (cf-&gt;fd == fd) {                c-&gt;handler(cf);                c-&gt;handler = NULL;                return;            }        }    }}</code></pre><ol><li>ngx_pool_cleanup_file: 关闭文件回调函数</li></ol><pre><code class="c">voidngx_pool_cleanup_file(void *data){    ngx_pool_cleanup_file_t  *c = data;    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, c-&gt;log, 0, &quot;file cleanup: fd:%d&quot;,                   c-&gt;fd);    if (ngx_close_file(c-&gt;fd) == NGX_FILE_ERROR) {        ngx_log_error(NGX_LOG_ALERT, c-&gt;log, ngx_errno,                      ngx_close_file_n &quot; \&quot;%s\&quot; failed&quot;, c-&gt;name);    }}</code></pre></li><li><p>ngx_pool_delete_file: 删除文件回调函数</p><pre><code class="c">voidngx_pool_delete_file(void *data){    ngx_pool_cleanup_file_t  *c = data;    ngx_err_t  err;    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, c-&gt;log, 0, &quot;file cleanup: fd:%d %s&quot;,                   c-&gt;fd, c-&gt;name);    if (ngx_delete_file(c-&gt;name) == NGX_FILE_ERROR) {        err = ngx_errno;        if (err != NGX_ENOENT) {            ngx_log_error(NGX_LOG_CRIT, c-&gt;log, err,                          ngx_delete_file_n &quot; \&quot;%s\&quot; failed&quot;, c-&gt;name);        }    }    if (ngx_close_file(c-&gt;fd) == NGX_FILE_ERROR) {        ngx_log_error(NGX_LOG_ALERT, c-&gt;log, ngx_errno,                      ngx_close_file_n &quot; \&quot;%s\&quot; failed&quot;, c-&gt;name);    }}</code></pre></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>内存池的所有结点上，只有父结点才存在cleanup链表、large链表、buf链表，子节点上只有ngx_pool_data_t结构(pool-&gt;d)和用户内存区域。如果子节点上也能存在着三个链表，说实话结构会变得异常复杂。</li><li>申请小数据内存(size &lt; pool-&gt;max)时不一定是向操作系统申请内存，会先遍历内存池的结点，判断其data区是否能满足分配的需求，能满足则在其结点上分配(移动last的指向)。如果没有满足的结点，则新建一个结点并将其假如内存池链表。</li><li>申请大数据内存(size &gt;= poo-&gt;max)，large的控制中心结构ngx_pool_large_t所需要的内存是在ngx_pool_data_t管理的区域上分配的，size大小的内存是直接向操作系统申请的(malloc)，然后用alloc指针保存分配的内存的地址。</li><li>cleanup设计灵活，能自定义清理工作，便于我们在内存池申请自定义或者特殊类型的内存，申请的数据区域存在于large链表或内存池结点的小块数据区域。</li></ol><h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><ol><li><p>关于current指针</p><p>current在内存池初始化时时指向父节点本身的，但是随着内存的不断分配出去其指向会不断的从small链表的头结点向尾结点方向移动。在分配小块内存时，会遍历small链表的结点，然后判断结点上是否有足够的空间满足申请者的需求，如果有则在已存在的结点上分配内存，如果没有则添加新的结点并在新结点上分配内存。随着内存不断的分配，结点上的内存空间可能会被分配完或者接近分配完(只剩下小块的内存，无法满足申请者的需求，类似内存碎片)，因此就要去扩容了，随着结点个数不断增加链表越来越长，遍历结点的效率会越来越低，而且链表中很多结点上的空间可能已经被分配完了，重复的遍历时没有任何意义的。nginx巧妙的借助current指针来解决这个问题，</p><pre><code class="c">static void *ngx_palloc_block(ngx_pool_t *pool, size_t size){    u_char      *m;    size_t       psize;    ngx_pool_t  *p, *new;    psize = (size_t) (pool-&gt;d.end - (u_char *) pool);    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool-&gt;log);    if (m == NULL) {        return NULL;    }    new = (ngx_pool_t *) m;    new-&gt;d.end = m + psize;    new-&gt;d.next = NULL;    new-&gt;d.failed = 0;    m += sizeof(ngx_pool_data_t);    m = ngx_align_ptr(m, NGX_ALIGNMENT);    new-&gt;d.last = m + size;    // 重点部分    for (p = pool-&gt;current; p-&gt;d.next; p = p-&gt;d.next) {        if (p-&gt;d.failed++ &gt; 4) {            pool-&gt;current = p-&gt;d.next;        }    }    p-&gt;d.next = new;    return m;}</code></pre><p>这部分代码是nginx扩容small链表的逻辑，关于current指针的部分我已经标出。根据代码得知：在链表上已存在的结点上的空间都无法满足分配内存的需求时就会新建一个结点然后分配内存，新结点采用的是尾插，因此要遍历链表拿到尾结点，但是如果链表过长就会导致效率低下。因此每增加一个结点时，就会从current指向的结点开始遍历(最开始时指向父节点本身的)，对其结点的failed字段进行判断(还要增加1，因为扩容就意味着此前的所有结点不能满足分配需求)，如果某个结点四次以上不满足分配内存的需求，就将current指向这个结点的下一个结点(找你这个结点要了四次内存都要不到，我就认为你没有可分配的内存了，下次再找内存池要内存，直接跳过你，从你后面的结点开始要内存)。这样就可以避免每次都遍历整个链表以及其中空间已经分配完的结点。</p><p><img src="source/image/ngx_current_1-20210327225636357.png" alt="内存池结构"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;nginx内存池&quot;&gt;&lt;a href=&quot;#nginx内存池&quot; class=&quot;headerlink&quot; title=&quot;nginx内存池&quot;&gt;&lt;/a&gt;nginx内存池&lt;/h4&gt;&lt;h5 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;</summary>
      
    
    
    
    <category term="Nginx" scheme="https://duwei19961021.github.io/categories/Nginx/"/>
    
    
    <category term="mem_pool" scheme="https://duwei19961021.github.io/tags/mem-pool/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://duwei19961021.github.io/2021/03/18/%E6%8E%92%E5%BA%8F/"/>
    <id>https://duwei19961021.github.io/2021/03/18/%E6%8E%92%E5%BA%8F/</id>
    <published>2021-03-18T03:09:52.078Z</published>
    <updated>2021-03-18T03:09:52.078Z</updated>
    
    <content type="html"><![CDATA[<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ol><li><p>排序思想</p><p>一个无序数列，从第一个数开始，循环比较相邻两个数的大小，如果前一个数大于后一个数则交换它们的位置(升序)。</p></li><li><p>示意图</p><p>一个数列：10 9 8 7 6 5 4 3 2 1</p><p><img src="http://img.3amupupup.online/BoubleSort.png" alt="冒泡排序"></p><p><img src="http://img.3amupupup.online/BubbleSort.gif" alt="冒泡排序"></p></li></ol><ol start="3"><li><p>实现</p><pre><code class="c">void BubbleSort(int* arr, int arrSize){    for (int i = 0; i &lt; arrSize-1; ++i)    {        int flag = 0;        for (int j = 0; j &lt; arrSize-i-1; ++j) // 每循环一次意味着一个最大的数被移动到了数组末尾，在下一次循环时最后一个数没必要参与比较        {            if(arr[j] &gt; arr[j+1])            {                flag = 1; // 判断循环时是否发生交换，没有发生交换则说明已经有序，直接退出。                int temp = arr[j];                arr[j] = arr[j+1];                arr[j+1] = temp;            }        }        if (!flag)            return;    }}</code></pre></li><li><p>理解</p><p>冒泡排序每迭代一次数组，最大数会被冒到最后，在下一次迭代时排除掉之前迭代冒的大数。</p><p>时间复杂度：N-1 + N-2 + …… + 1 即 O(N^2)。</p><p>空间复杂度：在排序过程中无需借助其它空间保存数据，即O(1)。</p></li></ol><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><ol><li><p>排序思想</p><p>一个无序数列，假设前n个数是有序的，依次取出n之后的数字与 n=&gt;0 进行比较，如果小于n则插入到n之前(升序)。</p></li><li><p>示意图</p><p><img src="http://img.3amupupup.online/InsertSort.png" alt="插入排序"></p><p><img src="http://img.3amupupup.online/InsertSort.gif" alt="插入排序"></p></li><li><p>实现</p><pre><code class="c">void InsertSort(int* arr, int arrSize){    for (int i = 0; i &lt; arrSize-1; ++i)    {        int end = i; // 假设 0-end是有序数列，第一次end就是0,拿arr[1]和arr[0]比较        int temp = arr[end+1]; // 选出end之后的第一个数        while (end &gt;= 0)        {            if(temp &lt; arr[end]) // 升序            {                arr[end+1] = arr[end]; // 如果temp小于arr[end]，则说明要将end往后挪一次                end--; // 然后end继续往前走,继续判断temp是否小于arr[end]            }            else            {                break; // 不小于arr[end]时直接跳出循环            }        }        arr[end+1] = temp;    }}</code></pre></li></ol><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><ol><li><p>排序思想</p><p>希尔排序是在插入排序的基础上做的优化。插入排序中，如果值大小分布越不均匀，在选择一个数与有序序列比较时需要移动end的次数会越多，序列越接近有序，需要移动end的次数就会越少。希尔排序在此基础上，将序列分成不连续多个组，然后进行插入排序，这会使得序列能更快的接近有序。直至间隔为1时就是插入排序，此时数组接近有序，效率会更高。</p></li><li><p>示意图</p><p><img src="http://img.3amupupup.online/ShellSort.png" alt="希尔排序"></p><p><img src="http://img.3amupupup.online/ShellSort.gif" alt="希尔排序"></p><p>图中，2、5、13为一组，5、3、3为一组，升序情况下：间隔越大，那么排在靠后位置的数就更加容易的被插入在数组靠前的位置，比如arr[1]=5、arr[5]=3、arr[9]=3，如果是插入排序，arr[9]=3 end需要移动6次才能使arr[9]到达靠前的位置，使用希尔排序，end移动两次就靠前了。会使数组更容易的接近有序。</p></li><li><p>实现</p><pre><code class="c">void ShellSort(int* arr, int arrSize){    int gap = arrSize;    while(gap &gt; 1)    {        gap = gap/3+1; // 2/3=0,会导致排序提前结束(gap还没等于1就结束了),所以每次给gap加上个1。        for(int i = 0;i &lt; arrSize-gap;i++)        // arrSize为什么要减去gap: 假如数组长度是10,gap第一次循环为4。        // 循环开始之后，temp的下标(也就是end+gap)不能超出数组范围即:i+gap &lt; arrsize,也就是i&lt;arrSize-gap        {            int end = i;            int temp = arr[end+gap];            while(end &gt;= 0)            {                if(temp &lt; arr[end])                {                    arr[end+gap] = arr[end];                    end-=gap;                }                else                {                    break;                }            }            arr[end+gap] = temp;        }    }}</code></pre></li></ol><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><ol><li><p>排序思想</p><p>有序数列(数组)的在内存上存储形式是线性的(一段连续的内存)，其逻辑结构是二叉树(完全二叉树)。利用这个特性可以将数组看成一个二叉树，然后进行建堆操作。（大堆的父结点大于左右孩子结点，小堆的父结点小于左右孩子结点），然后每次取出堆顶的数再重新建堆。(升序建大堆，降序建小堆)。leftChild = parent*2+1，rightChile = parent*2+2。</p></li><li><p>示意图</p><p><img src="http://img.3amupupup.online/BuildBigHeap.png" alt="建大堆"></p><p><img src="http://img.3amupupup.online/BuildArrayToHeap.png" alt="建堆完成后的效果"></p><p><img src="http://img.3amupupup.online/SortByHeap.png" alt="利用堆特性排序"></p><p><img src="http://img.3amupupup.online/HeapSort.gif" alt="堆排序"></p></li><li><p>实现</p><pre><code class="c">void Swap(int* a, int* b){    int temp = *a;    *a = *b;    *b= temp;}void AdJustDown(int* arr, int root, int arrSize) // 建堆{    int parent = root;    int child = parent*2 + 1;    while (child &lt; arrSize)    {        if (child+1 &lt; arrSize &amp;&amp; arr[child+1] &gt; arr[child])        {            child++;        }        if(arr[parent] &lt; arr[child])        {            Swap(&amp;arr[parent],&amp;arr[child]);            parent = child;            child = parent*2+1;        }        else        {            break;        }    }}void HeapSort(int* arr, int arrSize){    for (int i = (arrSize-1-1)/2; i &gt;=0 ; --i)    {        AdJustDown(arr,i,arrSize);    }    int end = arrSize-1;    while (end &gt; 0)    {        Swap(&amp;arr[end],&amp;arr[0]);        AdJustDown(arr,0,end);        end--;    }}</code></pre></li></ol><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ol><li><p>排序思想(升序)</p><p>左右两个指针left、right，取一个key值。左右开始向右向左遍历，左指针遇见比key大的数停止移动，右指针遇见比key小的数停止移动，此时交换左右指针对应的值，直到左右指针重合。此时key左边的值全比key小，右边的值全比key大。再通过分治思想对key左右两边的区间进行递归操作。</p></li><li><p>示意图</p><p><img src="http://img.3amupupup.online/QuickSortt.png" alt="快速排序"></p><p><img src="http://img.3amupupup.online/RecursionForQuickSort.png" alt="分治思想"></p><p><img src="http://img.3amupupup.online/QuickSortTime1.png" alt="时间复杂度"></p><p><img src="http://img.3amupupup.online/QuickSOrt.gif" alt="快速排序"></p></li><li><p>代码实现</p><pre><code class="c">/* * 三数取中 * 在数组有序时(假设是降序),keyIndex每次都是最小的数的下标 * 会导致快排变成一个N^2的算法,三数取中能有效避免这个缺陷。 */int GetMidIdx(int* arr ,int left, int right){    int mid = (left+right)/2;    if (arr[left] &lt; arr[mid])    {        if (arr[mid] &lt; arr[right])            return mid;        else if (arr[left] &gt; arr[right])            return left;        else            return right;    }    else    {        if (arr[mid] &gt; arr[right])            return mid;        else if (arr[left] &lt; arr[right])            return left;        else            return right;    }}int Part(int* arr, int left, int right){    int midIndex = GetMidIdx(arr,left,right); // 找出中位数    Swap(&amp;arr[midIndex],&amp;arr[right]);    int keyIndex = right;    while(left &lt; right)    {        while(left &lt; right &amp;&amp; arr[left] &lt;= arr[keyIndex]) // 因为是left先移动,所以left的最终停留位置的数一定比keyIndex大            left++;        while(left &lt; right &amp;&amp; arr[right] &gt;= arr[keyIndex])            right--;        Swap(&amp;arr[left], &amp;arr[right]); // 循环走到这里时,left位置的数比keyIndex大,right位置的数比keyIndex小,对它们进行交换    }    Swap(&amp;arr[keyIndex], &amp;arr[left]); // left最终停止的位置和keyIndex进行交换,此时left的左边全是比选出的keyIndex小的数,右边全是比keyIndex大的数。    return left; // 必须返回left,下一次排序时就可以排除掉left，对left左右的两边的数进行排序}void QuickSort(int* arr, int left, int right){    if(left &lt; right)    {        int div = Part(arr,left,right);        QuickSort(arr,left,div-1);        QuickSort(arr,div+1,right);    }}void QuickSortNoR(int* arr, int left, int right){    Stack st;    StackInit(&amp;st);    StackPush(&amp;st,left); // 注意进栈顺序,先进的后被取出来    StackPush(&amp;st,right);    while(!StackEmpty(&amp;st)) // 栈不为空说明还存在没被排序的区间则要继续循环    {        int _right = StackTop(&amp;st);        StackPop(&amp;st);        int _left = StackTop(&amp;st);        StackPop(&amp;st);        int div = Part(arr,_left,_right);        if(div+1 &lt; _right)        {            StackPush(&amp;st,div+1); // 保证入栈顺序和第一次一致            StackPush(&amp;st,_right);        }        if(_left &lt; div-1)        {            StackPush(&amp;st,_left);            StackPush(&amp;st,div-1);        }    }    StackDestory(&amp;st);}</code></pre></li></ol><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><ol><li><p>排序思想</p><p>合并有序数组</p></li><li><p>示意图</p><p><img src="http://img.3amupupup.online/MergeSort.png" alt="归并排序"></p><p><img src="http://img.3amupupup.online/MergeSortNoR.png" alt="非递归"></p><p><img src="http://img.3amupupup.online/MergeSort.gif" alt="归并排序"></p></li><li><p>实现</p><pre><code class="c">// 将数组分割成N个有序小区间(1个数的区间，一个数也算有序)，再合并有序的数组void _MergeSort(int* arr,int left, int right, int* tmp){    if(left&gt;=right) // 分割退出的条件        return;    int mid = (left+right)/2; // 拿到中间位置的索引，下一步递归分割，直到不可分为止(分割到只有一个数)    _MergeSort(arr,left,mid,tmp); // 递归分割左半边    _MergeSort(arr,mid+1,right,tmp); // 递归分割右半边    int begin1 = left, end1 = mid; // 走到这里说明已经分割完了，分成了right+1个一个元素的数组    int begin2 = mid+1, end2 = right;    int index = begin1; // tmp区间起始位置    while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) // 归并有序数组    {        if (arr[begin1] &lt; arr[begin2])        {            tmp[index++] = arr[begin1++];        }        else        {           tmp[index++] = arr[begin2++];        }    }    while (begin1&lt;=end1)        tmp[index++] = arr[begin1++];    while (begin2&lt;=end2)        tmp[index++] = arr[begin2++];    for (int i = left; i &lt;= right; ++i) // 拷贝回原数组，拷贝一定是 &lt;= 闭区间，因为right传入的是闭区间    {        arr[i] = tmp[i];    }}// 归并，递归实现void MergeSort(int* arr, int arrSize){    int* tmp = malloc(sizeof(int)*arrSize);    _MergeSort(arr,0,arrSize-1,tmp);    free(tmp);}// 归并，非递归实现void _MergeSortNoR(int* arr, int begin1, int end1, int begin2, int end2, int* tmp){    PrintArr(arr,10);    int left = begin1,right = end2; // 这里必须使用新变量记录数组的起始结束位置，因为经过迭代后begin1会自增    int index = begin1; // tmp区间起始位置    while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) // 归并有序数组    {        if (arr[begin1] &lt; arr[begin2])        {            tmp[index++] = arr[begin1++];        }        else        {            tmp[index++] = arr[begin2++];        }    }    while (begin1&lt;=end1)        tmp[index++] = arr[begin1++];    while (begin2&lt;=end2)        tmp[index++] = arr[begin2++];    for (int i = left; i &lt;= right; ++i)    {        arr[i] = tmp[i];    }}void MergeSortNoR(int* arr, int arrSize){    int* tmp = (int*)malloc(sizeof(int)*arrSize);    int gap = 1;    while (gap&lt;arrSize)    {        for (int i = 0; i &lt; arrSize; i+=2*gap)        {            // [i,i+gap-1] [i+gap, i+2*gap-1]            int begin1 = i, end1 = i+gap-1, begin2 = i+gap, end2 =i+gap*2-1;            if (begin2 &gt;= arrSize) // begin2大于等于数组长度时说明只存在一组数据(无法分割成两组)                break;            if (end2&gt;=arrSize) // end2大于等于数组长度则说明无法分割成均等的两组，end2超出了数组的范围                end2 = arrSize-1; // 所以需要调整end2的位置，使其不能超出数组范围            _MergeSortNoR(arr,begin1,end1,begin2,end2,tmp);        }        gap*=2;    }    free(tmp);}</code></pre></li></ol><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><ol><li><p>思想</p><p>记录一个序列中数字出现的次数。</p><p>找出序列中的最大值 max 然后创建一个size为max+1的tmp数组，遍历数据序列，拿序列中的值做tmp数组的下标，tmp对应下标的值进行++ 计数。遍历结束后，依次从tmp中取值拷贝到原序列中，tmp的下标作为序列的值，tmp下标对应的值作为拷贝的次数。</p></li><li><p>示意图</p><p><img src="http://img.3amupupup.online/CountSort.png" alt="计数排序"></p><p><img src="http://img.3amupupup.online/849589-20171015231740840-6968181.gif" alt="计数排序"></p></li><li><p>实现</p><pre><code class="c">void CountSort(int* arr, int arrSize){    int min = arr[0];     int max = arr[0]; // 找出最大最小的值    for (int i = 0; i &lt; arrSize; ++i)    {        if (arr[i] &gt; max)        {            max = arr[i];        }        if (arr[i] &lt; min)        {            min = arr[i];        }    }    int range = max-min+1; // 创建一个range+1大小的数组，利用相对位置存储计数，还原时tmp数组下标加上min就是原数组的值    int* countArray = (int*)malloc(sizeof(int)*range);    if (!countArray)    {        printf(&quot;malloc failed.\n&quot;);        exit(-1);    }    memset(countArray,0,sizeof(int)*range);    for (int i = 0; i &lt; arrSize; ++i)    {        countArray[arr[i]-min]++;    }    int index = 0;    for (int i = 0; i &lt; range; ++i)    {        while (countArray[i]--)        {            arr[index++] = i+min;        }    }    free(countArray);}</code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;排序思想&lt;/p&gt;
&lt;p&gt;一个无序数列，从第一个数开始，循环比较相邻两个数的大小，如果前一个数大于后一个数则</summary>
      
    
    
    
    <category term="C语言" scheme="https://duwei19961021.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="排序" scheme="https://duwei19961021.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins结合sonar代码检测流水线</title>
    <link href="https://duwei19961021.github.io/2021/03/18/Jenkins%E7%BB%93%E5%90%88sonar%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    <id>https://duwei19961021.github.io/2021/03/18/Jenkins%E7%BB%93%E5%90%88sonar%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E6%B5%81%E6%B0%B4%E7%BA%BF/</id>
    <published>2021-03-18T03:09:52.078Z</published>
    <updated>2021-03-18T03:09:52.078Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1、jenkins所需插件"><a href="#1、jenkins所需插件" class="headerlink" title="1、jenkins所需插件"></a>1、jenkins所需插件</h5><p><a href="https://plugins.jenkins.io/workflow-aggregator" target="_blank" rel="noopener">Pipeline</a>、<a href="https://plugins.jenkins.io/sonar-quality-gates" target="_blank" rel="noopener">Sonar Quality Gates Plugin</a>、<a href="https://plugins.jenkins.io/sonar" target="_blank" rel="noopener">SonarQube Scanner</a>、<a href="https://plugins.jenkins.io/generic-webhook-trigger" target="_blank" rel="noopener">Generic Webhook Trigger Plugin</a></p><h5 id="2、jenkins配置"><a href="#2、jenkins配置" class="headerlink" title="2、jenkins配置"></a>2、jenkins配置</h5><ul><li><p>Dashboard =&gt; 系统管理 =&gt; 全局工具配置</p><p><img src="/image/image-20201227165338711.png" alt="sonar scanner安装"></p></li><li><p>Dashboard =&gt; 系统管理 =&gt; 系统配置</p><p><img src="/image/image-20201227165501679.png" alt="sonarqube servers配置"></p></li></ul><p>  <img src="/image/image-20201227165627390.png" alt="token配置"></p><p>  这个token是在sonar web上生成的，然后在jenkins上创建一个secret text类型凭据。</p><p>  <img src="/image/image-20201227165828644.png" alt="gitlab"></p><p>  配置连接gitlab，要生成gitlab api token</p><p>  <img src="/image/image-20201227165956042.png" alt="获取gitlab Private token"></p><p>  生成private token。在sonar检测代码所有条件都通过时，要通过这个private token去操作gitlab的api来自动接受合并请求。</p><p>  <img src="/image/image-20201227170513752.png" alt="private token 凭据"></p><p>  生成凭据，记住这里的id 为12，一会pipeline脚本要用</p><ul><li><p>在gitlab项目下配置触发器，只勾选Merge Request Events (这个token随机生成一个就好了)</p><p><img src="/image/image-20201227170841973.png" alt="gitlab webhook"></p></li></ul><h5 id="3、pipiline脚本"><a href="#3、pipiline脚本" class="headerlink" title="3、pipiline脚本"></a>3、pipiline脚本</h5><pre><code class="pipeline">pipeline {   agent any   environment {        PrivateToken= credentials(&#39;12&#39;) // 获取private token，之前在凭据里配置过，这样比较安全，不需要在脚本里明文使用token    }   options {      gitLabConnection(&#39;gitlab&#39;)    }       triggers {        GenericTrigger(            genericVariables: [            [key: &#39;source_branch&#39;, value: &#39;$.object_attributes.source_branch&#39;], // 获取merge的源分支,只检测源分支，源分支的代码检测成功才能合并到目标分支            [key: &#39;url&#39;, value: &#39;$.object_attributes.url&#39;], // 获取gitlab merge请求的url            [key: &#39;action&#39;, value: &#39;$.object_attributes.action&#39;], // 获取merge动作 [reopen,close,open],只在reopen和open时才出发流水线检测            [key: &#39;source_project_id&#39;, value: &#39;$.object_attributes.source_project_id&#39;],            [key: &#39;iid&#39;, value: &#39;$.object_attributes.iid&#39;],            [key: &#39;name&#39;, value: &#39;$.user.name&#39;], // 获取合并请求的发起人            [key: &#39;project_name&#39;, value: &#39;$.project.name&#39;], // 或者项目名            [key: &#39;target_branch&#39;, value: &#39;$.object_attributes.target_branch&#39;], // 获取目标分支，我这里的需求是：合并到release.test分支的请求才进行质检、自动合并，所以我需要拿到这个变量            [key: &#39;object_kind&#39;, value: &#39;$.object_kind&#39;]            ],            token: &#39;fc161920aa6f1886e7417416edc85500&#39; , // 这是webhook上填写的token            causeString: &#39; Triggered on $ref&#39; ,            printContributedVariables: true,            printPostContent: true        )    }   stages {    stage(&quot;select branch&quot;){        steps{                script{                    if((env.source_branch =~ &#39;release.*&#39;).matches() || (env.action!=&quot;open&quot;  &amp;&amp; env.action!=&quot;update&quot;) || env.target_branch != &quot;release.test&quot;){ // 触发流水线检测代码的条件                        stage(&quot;exit with 0&quot;){                            ansiColor(&#39;gnome-terminal&#39;) {                                echo &quot;\033[32m Jump Sonar\n user:$name\nproject_name:$project_name\nobject_kind:$object_kind\naction:$action\nsource_branch:$source_branch\n target_branch:$target_branch \033[0m&quot;                            }                                   }                    }else{                        stage(&#39;pull branch&#39;) {                            checkout([$class: &#39;GitSCM&#39;, branches: [[name: &quot;*/$source_branch&quot;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: &#39;11&#39;, url: &#39;http://gitlab.xxxxxx.com:8888/xubin/xxxxxxxx.git&#39;]]])                        }                        stage(&#39;SonarQubeanalysis&#39;) {                                script {                                    scannerHome = tool &#39;sonar-scanner&#39;                                }                            withSonarQubeEnv(&#39;sonar&#39;) {                            sh &quot;echo ${scannerHome}&quot;                            sh &quot;${scannerHome}/bin/sonar-scanner -Dsonar.projectKey=$JOB_BASE_NAME -Dsonar.sources=./app&quot;                            }                    }                       stage(&quot;SonarQube Quality Gate&quot;) {                                    timeout(time: 1, unit: &#39;HOURS&#39;) {                                    def qg = waitForQualityGate(&#39;sonar&#39;)                                    if (qg.status != &#39;OK&#39;) {                                    echo &quot;Status: ${qg.status}&quot;                                    error &quot;Pipeline aborted due to quality gate failure: ${qg.status}&quot; // 质检没通过直接让流水线失败退出                                    }                                }                                ansiColor(&#39;gnome-terminal&#39;) {                                echo &quot;\033[32m Jump Sonar\n user:$name\nproject_name:$project_name\nobject_kind:$object_kind\naction:$action\nsource_branch:$source_branch\n target_branch:$target_branch \033[0m&quot;                            }                    }                         stage(&quot;Merge&quot;){ // 如果检测通过自动合并请求                                script{                                    httpRequest authentication: &#39;11&#39;, customHeaders: [[maskValue: false, name: &#39;PRIVATE-TOKEN&#39;, value: &quot;$PrivateToken&quot;]], httpMode: &#39;PUT&#39;, responseHandle: &#39;NONE&#39;, url: &quot;http://gitlab.xxxxxx.com:8888/api/v4/projects/$source_project_id/merge_requests/$iid/merge&quot;                                }                        }                    }                }            }        }    }}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;1、jenkins所需插件&quot;&gt;&lt;a href=&quot;#1、jenkins所需插件&quot; class=&quot;headerlink&quot; title=&quot;1、jenkins所需插件&quot;&gt;&lt;/a&gt;1、jenkins所需插件&lt;/h5&gt;&lt;p&gt;&lt;a href=&quot;https://plugins.j</summary>
      
    
    
    
    <category term="运维" scheme="https://duwei19961021.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="sonar" scheme="https://duwei19961021.github.io/tags/sonar/"/>
    
  </entry>
  
  <entry>
    <title>带环链表</title>
    <link href="https://duwei19961021.github.io/2021/03/18/%E5%B8%A6%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    <id>https://duwei19961021.github.io/2021/03/18/%E5%B8%A6%E7%8E%AF%E9%93%BE%E8%A1%A8/</id>
    <published>2021-03-18T03:09:52.077Z</published>
    <updated>2021-03-18T03:09:52.077Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、判断链表是否带环"><a href="#1、判断链表是否带环" class="headerlink" title="1、判断链表是否带环"></a>1、<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">判断链表是否带环</a></h4><h5 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h5><ol><li><p>给链表设置两个指针，slow移动一步，fast移动两步。</p><p><img src="/image/image-20201227013251253.png" alt="初始状态"></p></li><li><p>fast和slow指针都进入环之后</p><p><img src="/image/image-20201227013617501.png" alt="fast、slow进环"></p></li><li><p>fast和slow指针重合</p><p>在slow和fast都进环之后，fast开始追slow。slow移动一步，fast移动两步。</p><p><img src="/image/image-20201227014743194.png" alt="指针追赶"></p><p>每一次移动fast和slow之间的距离缩短一步，最终重合，则证明有环。如果fast指针在经过若干次移动之后为NULL(循环结束)，则说明不带环。</p><p><img src="/image/image-20201227013919844.png" alt="指针重合"></p></li><li><p>代码：</p><pre><code class="c">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     struct ListNode *next; * }; */bool hasCycle(struct ListNode *head) {    struct ListNode *slow = head;    struct ListNode *fast = head;    while(fast &amp;&amp; fast-&gt;next)    {        slow = slow-&gt;next;        fast = fast-&gt;next-&gt;next;        if (slow == fast)        {            return true;        }    }    return false;}</code></pre></li></ol><h4 id="2、带环链表的入环结点"><a href="#2、带环链表的入环结点" class="headerlink" title="2、带环链表的入环结点"></a>2、<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">带环链表的入环结点</a></h4><h5 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h5><ol><li><p>给链表设置两个指针，slow移动一步，fast移动两步。</p><p><img src="/image/image-20201227132753055.png" alt="初始状态"></p></li><li><p>slow在进入环之后，在一个C之内就会被fast追上(fast的速度是slow的两倍)。</p><p>slow走的距离是：L+X</p><p>fast走的距离是 ：L+N*C+X (如果L足够长环足够小，fast进环且绕环N次之后slow才会进入)</p><p>2*(L+X) = L+N*C+X =&gt; L = N*C -X</p><p>然后同时从head和fast位置开始遍历，找到相同的节点。</p><p><img src="/image/image-20201227154937844.png" alt="slow、fast重合"></p></li><li><p>代码：</p><pre><code class="c">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     struct ListNode *next; * }; */struct ListNode *detectCycle(struct ListNode *head) {    struct ListNode *slow = head;    struct ListNode *fast = head;    while(fast &amp;&amp; fast-&gt;next) // 遍历链表，找到slow与fast重合的点    {        slow = slow-&gt;next;        fast = fast-&gt;next-&gt;next;        if(fast == slow)        {            break;        }    }    if(!fast || !fast-&gt;next) // 判断上一步循环时因为遍历到NULL结束的还是因为 fast==slow 结束的    {        return NULL; // 如果fast或者fast-&gt;next为NULL说明链表不带环，直接返回NULL    }    while(fast &amp;&amp; head) // 遍历寻找相交结点    {        if(fast == head)        {            return fast;        }        fast = fast-&gt;next;        head = head-&gt;next;    }    return NULL;}</code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1、判断链表是否带环&quot;&gt;&lt;a href=&quot;#1、判断链表是否带环&quot; class=&quot;headerlink&quot; title=&quot;1、判断链表是否带环&quot;&gt;&lt;/a&gt;1、&lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-</summary>
      
    
    
    
    <category term="C语言" scheme="https://duwei19961021.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="数据结构" scheme="https://duwei19961021.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ECS磁盘扩容</title>
    <link href="https://duwei19961021.github.io/2021/03/18/ECS%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/"/>
    <id>https://duwei19961021.github.io/2021/03/18/ECS%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/</id>
    <published>2021-03-18T03:09:52.075Z</published>
    <updated>2021-03-18T03:09:52.076Z</updated>
    
    <content type="html"><![CDATA[<h6 id="1、通过-df-h-知根分区大小为40G。"><a href="#1、通过-df-h-知根分区大小为40G。" class="headerlink" title="1、通过 df -h 知根分区大小为40G。"></a>1、通过 df -h 知根分区大小为40G。</h6><p><img src="/image/image-20200512133700547.png" alt="image-20200512133700547"></p><h6 id="2、在阿里云后台对当前ECS实例的磁盘进行在线扩容。"><a href="#2、在阿里云后台对当前ECS实例的磁盘进行在线扩容。" class="headerlink" title="2、在阿里云后台对当前ECS实例的磁盘进行在线扩容。"></a>2、在阿里云后台对当前ECS实例的磁盘进行在线扩容。</h6><p><img src="/image/image-20200512134218782.png" alt="image-20200512134218782"></p><h6 id="3、扩容后登陆ECS使用fdisk-l查看磁盘大小，磁盘已经扩容到100G。"><a href="#3、扩容后登陆ECS使用fdisk-l查看磁盘大小，磁盘已经扩容到100G。" class="headerlink" title="3、扩容后登陆ECS使用fdisk -l查看磁盘大小，磁盘已经扩容到100G。"></a>3、扩容后登陆ECS使用fdisk -l查看磁盘大小，磁盘已经扩容到100G。</h6><p><img src="/image/image-20200512134102595.png" alt="image-20200512134102595"></p><h6 id="4、安装growpart"><a href="#4、安装growpart" class="headerlink" title="4、安装growpart"></a>4、安装growpart</h6><pre><code class="shell">[root@iZbp1e8z3uz7pmqbsis8bkZ ~]# yum -y install cloud-utils-growpartLoaded plugins: fastestmirrorbase                                                     | 3.6 kB     00:00epel                                                     | 4.7 kB     00:00extras                                                   | 2.9 kB     00:00updates                                                  | 2.9 kB     00:00(1/7): base/7/x86_64/group_gz                              | 153 kB   00:00(2/7): extras/7/x86_64/primary_db                          | 190 kB   00:00(3/7): epel/x86_64/group_gz                                |  95 kB   00:00(4/7): updates/7/x86_64/primary_db                         | 176 kB   00:00(5/7): epel/x86_64/updateinfo                              | 1.0 MB   00:00(6/7): base/7/x86_64/primary_db                            | 6.1 MB   00:00(7/7): epel/x86_64/primary_db                              | 6.8 MB   00:00Determining fastest mirrors * base: mirrors.cloud.aliyuncs.com * epel: mirrors.cloud.aliyuncs.com * extras: mirrors.cloud.aliyuncs.com * updates: mirrors.cloud.aliyuncs.comResolving Dependencies--&gt; Running transaction check---&gt; Package cloud-utils-growpart.noarch 0:0.29-5.el7 will be installed--&gt; Finished Dependency ResolutionDependencies Resolved================================================================================ Package                     Arch          Version            Repository   Size================================================================================Installing: cloud-utils-growpart        noarch        0.29-5.el7         base         27 kTransaction Summary================================================================================Install  1 PackageTotal download size: 27 kInstalled size: 61 kDownloading packages:cloud-utils-growpart-0.29-5.el7.noarch.rpm                 |  27 kB   00:00Running transaction checkRunning transaction testTransaction test succeededRunning transaction  Installing : cloud-utils-growpart-0.29-5.el7.noarch                       1/1  Verifying  : cloud-utils-growpart-0.29-5.el7.noarch                       1/1Installed:  cloud-utils-growpart.noarch 0:0.29-5.el7Complete!</code></pre><h6 id="5、扩展-dev-vda1分区（命名含义为扩展-dev-vda磁盘的第一个分区）。"><a href="#5、扩展-dev-vda1分区（命名含义为扩展-dev-vda磁盘的第一个分区）。" class="headerlink" title="5、扩展/dev/vda1分区（命名含义为扩展/dev/vda磁盘的第一个分区）。"></a>5、扩展/dev/vda1分区（命名含义为扩展/dev/vda磁盘的第一个分区）。</h6><pre><code class="shell">[root@iZbp1e8z3uz7pmqbsis8bkZ ~]# growpart /dev/vda 1CHANGED: partition=1 start=2048 old: size=83881984 end=83884032 new: size=209713119 end=209715167</code></pre><p>​     若报错unexpected output in sfdisk –version……..则运行LANG=en_US.UTF-8切换ECS实例的字符编码类型。</p><p>6、运行resize2fs <PartitionName> 命令调用resize2fs扩容文件系统。</p><pre><code class="shell">[root@iZbp1e8z3uz7pmqbsis8bkZ ~]# resize2fs /dev/vda1resize2fs 1.42.9 (28-Dec-2013)Filesystem at /dev/vda1 is mounted on /; on-line resizing requiredold_desc_blocks = 3, new_desc_blocks = 7The filesystem on /dev/vda1 is now 26214139 blocks long.[root@iZbp1e8z3uz7pmqbsis8bkZ ~]# df -hFilesystem      Size  Used Avail Use% Mounted on/dev/vda1        99G  1.5G   93G   2% /devtmpfs        487M     0  487M   0% /devtmpfs           497M     0  497M   0% /dev/shmtmpfs           497M  308K  496M   1% /runtmpfs           497M     0  497M   0% /sys/fs/cgrouptmpfs           100M     0  100M   0% /run/user/0</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;1、通过-df-h-知根分区大小为40G。&quot;&gt;&lt;a href=&quot;#1、通过-df-h-知根分区大小为40G。&quot; class=&quot;headerlink&quot; title=&quot;1、通过 df -h 知根分区大小为40G。&quot;&gt;&lt;/a&gt;1、通过 df -h 知根分区大小为40G。</summary>
      
    
    
    
    <category term="运维" scheme="https://duwei19961021.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="ecs" scheme="https://duwei19961021.github.io/tags/ecs/"/>
    
  </entry>
  
  <entry>
    <title>linux性能优化实战笔记</title>
    <link href="https://duwei19961021.github.io/2021/03/18/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/"/>
    <id>https://duwei19961021.github.io/2021/03/18/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-18T03:09:52.075Z</published>
    <updated>2021-03-18T03:09:52.075Z</updated>
    
    <content type="html"><![CDATA[<h4 id="01、平均负载"><a href="#01、平均负载" class="headerlink" title="01、平均负载"></a>01、平均负载</h4><p>平均负载：系统出于可运行状态<font size=2 color=red>（正在使用cpu或者正在等待cpu的进程，也就是ps命令看到的Running 或 Runnable状态的进程）</font>和不可中断状态<font size=2 color=red>（进程正在处于内核态关键流程中的进程，这些流程是不可打断的，例如等待硬件设备的I/O响应，也就是ps命令看到的D状态。比如，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程就处于不可中断状态。如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。所以，不可中断状态实际上是系统对进程和硬件设备的一种保护机制。）</font>的平均进程数，也就是平均活跃进程数。</p><pre><code class="shell">#观察进程的cpu使用情况，间隔一秒输出一次pidstat  -u 1#观察cpu使用情况，观察各状态占比mpstat -P ALL  1</code></pre><h4 id="02、CPU-上下文切换"><a href="#02、CPU-上下文切换" class="headerlink" title="02、CPU 上下文切换"></a>02、CPU 上下文切换</h4><p>CPU 寄存器：是 CPU 内置的容量小、但速度极快的内存。</p><p>程序计数器：则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。</p><p>它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做 CPU 上下文。</p><p>CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p><p>上下文切换情景：</p><p>① 系统调用，cpu寄存器里原来用户态的指令位置，需要先保存起来，接着为了执行内核态的代码，cpu寄存器需要更新为内核态指令的最新位置，最后才是跳转到内核态运行内核任务，系统调用结束后cpu需要恢复到原来保存的用户态，继续运行进程。so，一次系统调用发生了两次cpu上下文切换。（<font size=2 color=red>系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的</font>）</p><p>进程上下文切换，是指从一个进程切换到另一个进程运行。而系统调用过程中一直是同一个进程在运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;01、平均负载&quot;&gt;&lt;a href=&quot;#01、平均负载&quot; class=&quot;headerlink&quot; title=&quot;01、平均负载&quot;&gt;&lt;/a&gt;01、平均负载&lt;/h4&gt;&lt;p&gt;平均负载：系统出于可运行状态&lt;font size=2 color=red&gt;（正在使用cpu或者正在等</summary>
      
    
    
    
    <category term="运维" scheme="https://duwei19961021.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="linux性能优化实战笔记" scheme="https://duwei19961021.github.io/tags/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
