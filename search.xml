<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统</title>
      <link href="2021/05/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/05/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="第九章：虚拟内存"><a href="#第九章：虚拟内存" class="headerlink" title="第九章：虚拟内存"></a>第九章：虚拟内存</h3><h6 id="1、什么是虚拟内存？"><a href="#1、什么是虚拟内存？" class="headerlink" title="1、什么是虚拟内存？"></a>1、什么是虚拟内存？</h6><p>虚拟内存是磁盘上(较低层)连续N个字节组成的数组，每个字节都有唯一的虚拟地址作为数组的索引，磁盘上数组的内容被缓存在主存中。(虚拟页存在于磁盘上)</p><p>物理内存被分隔成物理页(Physical Page,PP)。</p><p>VM系统将虚拟内存分隔成虚拟页(Virtual Page,VP)，虚拟页面的集合分为三个不相交的子集：</p><ol><li>未分配的(VM系统还未分配或者未创建的页，未分配的块没有任何数据和他们相关联，因为不占用任何磁盘空间)。</li><li>缓存的(已缓存在物理内存中的已分配页)。</li><li>未缓存的(未缓存在物理内存中的已分配页)。</li></ol><h6 id="2、DRAM缓存组织结构"><a href="#2、DRAM缓存组织结构" class="headerlink" title="2、DRAM缓存组织结构"></a>2、DRAM缓存组织结构</h6><ul><li>SRAM：表示位于cpu和主存之间的L1、L2、L3高速缓存。</li><li>DRAM：表示虚拟内存系统的缓存，它在主存中缓存虚拟页。</li><li>直   写：当 CPU 要将数据写入内存时 除了更新缓冲内存(高速缓存L1、L2、L3)上的数据外也将数据写在 DRAM 中 以维持主存与缓冲内存的一致性 当要写入内存的数据一多 速度自然就慢了下来 </li><li>回   写：每当 CPU 要将数据写入内存时 只会先更新缓冲内存(高速缓存L1、L2、L3)上的数据 随后再让缓冲内存在总线不塞车的时候 才把数据写回 DRAM 所以速度自然快得多</li></ul><h6 id="3、页表"><a href="#3、页表" class="headerlink" title="3、页表"></a>3、页表</h6><p>虚拟内存必须有某种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页(主存)。如果不命中还必须判断这个虚拟页存放在磁盘的哪个位置上，在物理页中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页。(操作系统为每个进程都维护一个独立的页表)</p><p>页表：将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表，操作系统负责维护页表的内容，以及在磁盘与DRAM之间来回传送页。</p><p><img src="/image/image-20201020134441586.png" alt="image-20201020134441586"></p><p>我们将假设每个PTE是由一个有效位(valid bit)和一个n位地址字段组成，有效位表明了该虚拟页当前是否被缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。 如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。否则，这个地址就指向该虚拟页在磁盘上的起始位置。</p><h6 id="4、缺页"><a href="#4、缺页" class="headerlink" title="4、缺页"></a>4、缺页</h6><p>DRAM缓存不命中称为缺页。</p><p>自己的理解：在cpu获取虚拟页中的数据时，地址翻译硬件去读页表的页表记录的有效位，如果有效位为0则推断出该虚拟页未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会在主存的PP(物理页)中选择一个被缓存的VP作为牺牲页，接下来将要缓存的vp从磁盘中加载出来缓存到主存上去(替换牺牲页)。</p><p><img src="/image/image-20201020140133328.png" alt="image-20201020140133328"></p><h6 id="5、地址翻译"><a href="#5、地址翻译" class="headerlink" title="5、地址翻译"></a>5、地址翻译</h6><p>当页面命中时，CPU硬件执行的步骤：</p><ol><li>处理器生成一个虚拟地址，并把它传送给MMU。</li><li>MMU生成PTE地址，并从高速缓存/主存请求得到它。</li><li>高速缓存/主存向MMU返回PTE。</li><li>MMU构造物理地址，并把它传给告诉缓存/主存。</li><li>高速缓存/主存返回所请求的数据字给处理器。</li></ol><p><img src="/image/image-20201020145055727.png" alt="image-20201020145055727"></p><p>缺页，CPU硬件执行步骤：</p><ol><li>处理器生成一个虚拟地址，并把它传送给MMU。</li><li>MMU生成PTE地址，并从高速缓存/主存请求得到它。</li><li>高速缓存/主存向MMU返回PTE。</li><li>PTE中的有效为是0，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。</li><li>缺页处理程序确定出物理内存中的牺牲页，如果这个页面修改了则把它换出到磁盘。</li><li>缺页处理程序页面调入新的页面，并更新内存中的PTE。</li><li>缺页处理程序返回到原来的进程，再次执行导致缺页的指令，CPU将引起缺页的虚拟地址重新发送给MMU。</li></ol><p><img src="/image/image-20201020145822292.png" alt="image-20201020145822292"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> no </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="2021/05/22/BSTree/"/>
      <url>2021/05/22/BSTree/</url>
      
        <content type="html"><![CDATA[<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>中序是有序的。</p><p><img src="BSTree.png" alt="BSTree"></p><h5 id="搜索二叉树的删除"><a href="#搜索二叉树的删除" class="headerlink" title="搜索二叉树的删除"></a>搜索二叉树的删除</h5><p>插入和查找相对简单，略过。</p><p>删除首先分为三种情况：</p><ol><li><p>被删除的结点有左右孩子结点。</p><p>例：要删除3结点，先在3结点的右子树种找到值最小的结点（最左的结点）—– 4结点，将3结点的值修改为4，再删除4。</p><p>要删除5，先将5结点的值修改为6，再删除6结点。</p><p><img src="https://img.3amupupup.online/delNodeWhoHasTwoChild.png" alt="delNodeWhoHasTwoChild"></p></li><li><p>被删除的结点没有孩子结点。</p><p>例：要删除上图中值为0的结点，直接使0结点的父结点1的left指针为空即可。</p></li><li><p>被删除的结点有一个孩子结点。</p><p>例：要删除上图中值为8的结点，使8结点的父结点7的right指针指向8结点的右孩子即可。</p></li></ol><p>通过观察可知：2、3情况可归纳为一种情况。比如：如果要删除0结点，使其父结点1的left指针指向0结点的left，即1-&gt;left = 0-&gt;left，而0结点的left为空，所以最终1结点的left指向空。如果要删除结点8，使其父结点7的right结点指向结点8的右结点，即7-&gt;right = 8-&gt;right。</p><p><img src="https://img.3amupupup.online/delNodeWhoHasOneOrZeroChild.png" alt="delNodeWhoHasOneOrZeroChild"></p><p>因此最终要删除一个结点分为两大种情况：</p><ol><li>被删除的结点有两个孩子。</li><li>被删除的结点有一个或零个孩子。</li></ol><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><pre class=" language-c++"><code class="language-c++">#pragma once#include <iostream>template<class T>struct BSTreeNode{    T _key;    struct BSTreeNode<T>* _left;    struct BSTreeNode<T>* _right;    BSTreeNode(const T &key):_key(key), _left(nullptr), _right(nullptr)    {}};template<class T>class BSTree{    typedef BSTreeNode<T> Node;private:    Node* _root = nullptr;    void _InOrder(Node* _root)    {        if(_root == nullptr)        {            return;        }        _InOrder(_root->_left);        std::cout << _root->_key << " ";        _InOrder(_root->_right);    }public:    bool Erase(const T &k)    {        Node* parent = nullptr;        Node* current = _root;        while(current)        {            if(k > current->_key)            {                parent = current;                current = current->_right;            }            else if(k < current->_key)            {                parent = current;                current = current->_left;            }            else // 找到了，此时current就是要删除的结点            {                if(current->_left == nullptr) // 情况2-1                {                    if(current == _root) // 特殊情况：current等于_root说明整个二叉树没有左子树且要删除的结点是根结点                    {                        _root = current->_right;                    }                    else                    {                        if(current == parent->_left) // 情况2-1-1                        {                            parent->_left = current->_right;                        }                        else // 情况2-1-2                        {                            parent->_right = current->_right;                        }                    }                    delete current;                }                else if(current->_right == nullptr) // 情况2-2                {                    if(current == _root) // 特殊情况：current等于_root说明整个二叉树没有右子树且要删除的结点是根结点                    {                        _root = current->_left;                    }                    else                    {                        if(current = parent->_left) // 情况2-2-1                        {                            parent->_left = current->_left;                        }                        else // 情况2-2-2                        {                            parent->_right = current->_left;                        }                    }                    delete current;                }                else // 情况2-3，左右孩子均不为空                {                    Node* smParent = current;                    Node* subMin = current->_right; // 寻找右树的最小结点（右树的最左结点）                    while(subMin->_left)                    {                        smParent = subMin;                        subMin = subMin->_left; // subMin一定是一个左为空的结点                    }                    current->_key = subMin->_key;                    if(subMin == smParent->_left)                    {                        smParent->_left = subMin->_right;                    }                    else                    {                        smParent->_right = subMin->_right;                    }                    delete subMin;                }                return true;            }        }        return false;    }    Node* Find(const T &k)    {        Node* current = _root;        while(current)        {            if(k > current->_key)            {                current = current->_right;            }            else if(k < current->_key)            {                current = current->_left;            }            else            {                return current;            }        }        return nullptr;    }    bool Insert(const T &k)    {        if(_root == nullptr)        {            _root = new Node(k);            return true;        }        Node* parent = nullptr;        Node* current = _root;        while(current)        {            if(k > current->_key)            {                parent = current;                current = current->_right;            }            else if(k < current->_key)            {                parent = current;                current = current->_left;            }            else            {                return false;            }        }        Node* newnode = new Node(k);        if(k > parent->_key)        {            parent->_right = newnode;        }        else        {            parent->_left = newnode;        }        return true;    }    void InOrder()    {        _InOrder(_root);        std::cout << std::endl;    }};</code></pre><h6 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h6><p>情况2-1-1：current左孩子为空且为父结点的左孩子</p><p><img src="https://img.3amupupup.online/delNode-2-1-1.png" alt="情况2-1-1"></p><p>情况2-1-2：current左孩子为空且为父结点的右孩子</p><p><img src="https://img.3amupupup.online/delNode-2-1-2.png" alt="情况2-1-2"></p><p>情况2-2-1：current左孩子不为空右孩子为空，且为父结点的左孩子</p><p><img src="https://img.3amupupup.online/delNode-2-2-1.png" alt="情况2-2-1"></p><p>情况2-2-2：current左孩子不为空右孩子为空，且为父结点的右孩子</p><p><img src="https://img.3amupupup.online/delNode-2-2-2.png" alt="情况2-2-2"></p><p> 情况2-3-1：subMin为smParent左孩子</p><p><img src="https://img.3amupupup.online/delNode-2-3-1.png" alt="情况2-3-1"></p><p>情况2-3-2：subMin为smParent右孩子</p><p><img src="https://img.3amupupup.online/delNode-2-3-2.png" alt="情况2-3-2"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>socket</title>
      <link href="2021/05/12/socket/"/>
      <url>2021/05/12/socket/</url>
      
        <content type="html"><![CDATA[<h4 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h4><p>内存分为大端存储和小端存储，网络数据同样有大小端之分。</p><blockquote><p>发送主机通常将发送缓冲区中的数据按照内存地址从低到高的顺序发出。</p><p>接收主机把从网络上收到的字节依次保存在接收缓冲区中，也是按照内存从低到高的顺序保存。</p><p>因此，网络数据流的地址应该规定：先发出的数据是低地址，后发出的数据是高地址。</p><p>TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节。</p><p>不管是大端机还是小端机，都会按照TCP/IP规定的网络字节序来发送/接受数据。</p><p>如果当前发送主机是小端，就需要先将数据转换为大端，否则就忽略直接发送。</p></blockquote><h6 id="小端机-amp-大端机"><a href="#小端机-amp-大端机" class="headerlink" title="小端机 &amp; 大端机"></a>小端机 &amp; 大端机</h6><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0x11223344</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-shell"><code class="language-shell">☁  exercise  gcc small.c -g☁  exercise  gdb a.outGNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-120.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type "show copying"and "show warranty" for details.This GDB was configured as "x86_64-redhat-linux-gnu".For bug reporting instructions, please see:<http://www.gnu.org/software/gdb/bugs/>...Reading symbols from /root/exercise/a.out...done.(gdb) l1    #include <stdio.h>23    int main()4    {5        int a = 0x11223344;6        return 0;7    }(gdb) b 6Breakpoint 1 at 0x4004d8: file small.c, line 6.(gdb) rStarting program: /root/exercise/a.outBreakpoint 1, main () at small.c:66        return 0;(gdb) x/16xb &a # x：查看内存，8：显示连续16个单元，x：以16进制方式显示，b：一个字节为一个单元0x7fffffffe35c:    0x44    0x33    0x22    0x11    0x00    0x00    0x00    0x000x7fffffffe364:    0x00    0x00    0x00    0x00    0x85    0x1a    0xa5    0xf7(gdb)</code></pre><h6 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h6><p>通过gdb查看内存可知：a值为：0x11223344，但是其在内存上的表示为：44 33 22 11，低权重为存储在低地址处，高权重位存储在高低地址处，这样的存储方式称为小端存储法。反之则为大端存储。</p><p>按照TCP/IP协议规定，如果要将a的内容通过网络发送给另一台主机：因为我这里是小端机，a在内存上为：44 33 22 11，发送之前需要将其转换为大端：11 22 33 44，然后按照低地址到高地址的方式发送，接受主机接收到的顺序为：11 22 33 44，接收主机保存时会按照低地址到高地址的方式保存在内存中：11 22 33 44</p><h6 id="C语言接口"><a href="#C语言接口" class="headerlink" title="C语言接口"></a>C语言接口</h6><p>为了使网络具有可移植性，使同样的代码在大端机和小端机编译后都能正常运行，可以调用库函数做网络字节序和主机字节序的转换。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h></span></span>uint32_t <span class="token function">htonl</span><span class="token punctuation">(</span>uint32_t hostlong<span class="token punctuation">)</span><span class="token punctuation">;</span>uint16_t <span class="token function">htons</span><span class="token punctuation">(</span>uint16_t hostshort<span class="token punctuation">)</span><span class="token punctuation">;</span>uint32_t <span class="token function">ntohl</span><span class="token punctuation">(</span>uint32_t netlong<span class="token punctuation">)</span><span class="token punctuation">;</span>uint16_t <span class="token function">ntohs</span><span class="token punctuation">(</span>uint16_t netshort<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// h表示host，n表示net，l表示32位长整数，s表示16位短整数 (32位系统)</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// /usr/include/linux/in.h</span><span class="token keyword">struct</span> sockaddr_in <span class="token punctuation">{</span>  __kernel_sa_family_t  sin_family<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Address family       */</span>  __be16        sin_port<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* Port number          */</span>  <span class="token keyword">struct</span> in_addr    sin_addr<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* Internet address     */</span>  <span class="token comment" spellcheck="true">/* Pad to size of `struct sockaddr'. */</span>  <span class="token keyword">unsigned</span> <span class="token keyword">char</span>     __pad<span class="token punctuation">[</span>__SOCK_SIZE__ <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">short</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-</span>            <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> in_addr<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* Internet address. */</span><span class="token keyword">struct</span> in_addr <span class="token punctuation">{</span>    __be32  s_addr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><h6 id="server"><a href="#server" class="headerlink" title="server"></a>server</h6><pre class=" language-c++"><code class="language-c++">#pragma once#include <iostream>#include <string>#include <sys/types.h>#include <sys/socket.h>#include <netinet/in.h>#include <arpa/inet.h>#include <unistd.h>#include <stdlib.h>class udpServer{private:    std::string _ip;    short _port;    int _sock;public:    udpServer(std::string ip = "127.0.0.1", short port = 8080)    {        _ip = ip;        _port = port;    }    void initServer()    {        _sock = socket(AF_INET, SOCK_DGRAM, 0);        std::cout << "sock: " << _sock << std::endl;        struct sockaddr_in local;        local.sin_family = AF_INET;        local.sin_port = htons(_port); // 将主机序列转换为网络序列（解决大小端问题）        local.sin_addr.s_addr = inet_addr(_ip.c_str()); // 将字符串类型的ip地址转换成4字节的整形（ip地址可以用四个字节表示）        if(bind(_sock, (struct sockaddr*)&local, sizeof(local)) < 0)        {            std::cerr << "bind error" << std::endl;            exit(-1);        }    }    void start()    {        char buf[64];        for(;;)        {            buf[0] = '\0';            struct sockaddr_in end_point;            socklen_t len = sizeof(end_point);            ssize_t s = recvfrom(_sock, buf, sizeof(buf)-1, 0,(struct sockaddr*)&end_point, &len); // 接收：套接字fd，接收存放的缓冲区，缓冲区的大小，阻塞或非阻塞方式，成员有协议、目的端口、目的端口的结构体（输出型参数），结构体大小            if(s > 0)            {                buf[s] = '\0';                std::cout << "client# " << buf << std::endl;                sendto(_sock, buf, s, 0, (struct sockaddr*)&end_point, len); // 发送：end_point是输入型参数            }        }    }    ~udpServer()    {        close(_sock);    }};</code></pre><h6 id="client"><a href="#client" class="headerlink" title="client"></a>client</h6><pre class=" language-c++"><code class="language-c++">#pragma once#include <iostream>#include <string>#include <sys/types.h>#include <sys/socket.h>#include <netinet/in.h>#include <arpa/inet.h>#include <unistd.h>#include <stdlib.h>class udpClient{private:    std::string _ip;    short _port;    int _sock;public:    udpClient(std::string ip = "127.0.0.1", short port = 8080)    {        _ip = ip;        _port = port;    }    void initServer()    {        _sock = socket(AF_INET, SOCK_DGRAM, 0); // 创建套接字        std::cout << "sock: " << _sock << std::endl;    }    void start()    {        struct sockaddr_in peer;        peer.sin_family = AF_INET;        peer.sin_port = htons(_port);        peer.sin_addr.s_addr = inet_addr(_ip.c_str());        std::string msg;        for(;;)        {            std::cout << "Please Enter: ";            std::cin >> msg;            sendto(_sock, msg.c_str(), msg.size(), 0, (struct sockaddr*)&peer,  sizeof(peer));            char recvMsg[64];            ssize_t s = recvfrom(_sock, recvMsg, sizeof(recvMsg)-1, 0, NULL, NULL);            if(s > 0)            {                recvMsg[s] = '\0';                std::cout << "Server# " << recvMsg << std::endl;            }        }    }    ~udpClient()    {        close(_sock);    }};</code></pre><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><h5 id="server-1"><a href="#server-1" class="headerlink" title="server"></a>server</h5><h6 id="单进程"><a href="#单进程" class="headerlink" title="单进程"></a>单进程</h6><p>一次只能处理一个请求。</p><pre class=" language-c++"><code class="language-c++">#ifndef __TCP_SERVER_#define __TCP_SERVER_#include <iostream>#include <string>#include <cstdlib>#include <sys/types.h>#include <sys/socket.h>#include <netinet/in.h>#include <cstring>#include <unistd.h>#include <signal.h>#include <pthread.h>#define BACKLOG 5class tcpServer{private:    int _port; // 端口    int listen_sock; // 套接字（文件描述符）public:    tcpServer(int port = 8080):_port(port), listen_sock(-1)    {    }    void initServer()    {        signal(SIGCHLD, SIG_IGN); // 父进程注册sigchild信号，子进程自行退出，父进程不关心        listen_sock = socket(AF_INET, SOCK_STREAM, 0);        if(listen_sock < 0)        {            std::cerr << "socket error" << std::endl;            exit(2);        }        struct sockaddr_in local;        local.sin_family = AF_INET;        local.sin_port = htons(_port);        local.sin_addr.s_addr = INADDR_ANY;        if(bind(listen_sock, (struct sockaddr*)&local, sizeof(local)) < 0)        {            std::cerr << "bind error" << std::endl;            exit(3);        }        if(listen(listen_sock, BACKLOG) < 0)        {            std::cerr << "listen error" << std::endl;            exit(4);        }    }    void service(int sock)    {        char buf[128];        while(true)        {            buf[0] = '\0';            ssize_t s = recv(sock, buf, sizeof(buf)-1, 0);            std::cout << s << std::endl;            if(s > 0)            {                buf[s] = '\0';                std::cout << "client # " << buf << std::endl;                send(sock, buf, strlen(buf), 0);            }            if(s == 0)            {                close(sock);                std::cout << "client quit" << std::endl;                break;            }        }    }    void start()    {        struct sockaddr_in endpoint;        while(true)        {            socklen_t len = sizeof(endpoint);            int sock = accept(listen_sock, (struct sockaddr*)&endpoint, &len);            if(sock < 0)            {                std::cerr << "accept error" << std::endl;                continue;            }            std::cout << "get a link" << std::endl;      service(sock);        }    }    ~tcpServer()    {    }};#endif</code></pre><h6 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h6><p>效率不会高，创建进程开销很大，另外进程比较占用系统资源。</p><pre class=" language-c++"><code class="language-c++">#ifndef __TCP_SERVER_#define __TCP_SERVER_#include <iostream>#include <string>#include <cstdlib>#include <sys/types.h>#include <sys/socket.h>#include <netinet/in.h>#include <cstring>#include <unistd.h>#include <signal.h>#include <pthread.h>#define BACKLOG 5class tcpServer{private:    int _port; // 端口    int listen_sock; // 套接字（文件描述符）public:    tcpServer(int port = 8080):_port(port), listen_sock(-1)    {    }    void initServer()    {        signal(SIGCHLD, SIG_IGN); // 父进程注册sigchild信号，子进程自行退出，父进程不关心        listen_sock = socket(AF_INET, SOCK_STREAM, 0);        if(listen_sock < 0)        {            std::cerr << "socket error" << std::endl;            exit(2);        }        struct sockaddr_in local;        local.sin_family = AF_INET;        local.sin_port = htons(_port);        local.sin_addr.s_addr = INADDR_ANY;        if(bind(listen_sock, (struct sockaddr*)&local, sizeof(local)) < 0)        {            std::cerr << "bind error" << std::endl;            exit(3);        }        if(listen(listen_sock, BACKLOG) < 0)        {            std::cerr << "listen error" << std::endl;            exit(4);        }    }    void service(int sock)    {        char buf[128];        while(true)        {            buf[0] = '\0';            ssize_t s = recv(sock, buf, sizeof(buf)-1, 0);            std::cout << s << std::endl;            if(s > 0)            {                buf[s] = '\0';                std::cout << "client # " << buf << std::endl;                send(sock, buf, strlen(buf), 0);            }            if(s == 0)            {                close(sock);                std::cout << "client quit" << std::endl;                break;            }        }    }    void start()    {        struct sockaddr_in endpoint;        while(true)        {            socklen_t len = sizeof(endpoint);            int sock = accept(listen_sock, (struct sockaddr*)&endpoint, &len);            if(sock < 0)            {                std::cerr << "accept error" << std::endl;                continue;            }            std::cout << "get a link" << std::endl;      pid_t id = fork();      if(id == 0)      {            close(listen_sock); // 子进程只关心sock，listen_sock子进程不关心，可以关闭            service(sock);            exit(0);       }       close(sock); // 父进程不关心sock，sock交给子进程，而父进程只关心接收请求然后交给子进程处理。sock必须关掉：父进程不断接收连接，不断创建套接字，然后子进程继承了被创建的套接字，如果不关闭，父进程打开的fd会越来越多        }    }    ~tcpServer()    {    }};#endif</code></pre><h6 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h6><pre class=" language-c++"><code class="language-c++">#ifndef __TCP_SERVER_#define __TCP_SERVER_#include <iostream>#include <string>#include <cstdlib>#include <sys/types.h>#include <sys/socket.h>#include <netinet/in.h>#include <cstring>#include <unistd.h>#include <signal.h>#include <pthread.h>#define BACKLOG 5class tcpServer{private:    int _port; // 端口    int listen_sock; // 套接字（文件描述符）public:    tcpServer(int port = 8080):_port(port), listen_sock(-1)    {    }    void initServer()    {        signal(SIGCHLD, SIG_IGN); // 父进程注册sigchild信号，子进程自行退出，父进程不关心        listen_sock = socket(AF_INET, SOCK_STREAM, 0);        if(listen_sock < 0)        {            std::cerr << "socket error" << std::endl;            exit(2);        }        struct sockaddr_in local;        local.sin_family = AF_INET;        local.sin_port = htons(_port);        local.sin_addr.s_addr = INADDR_ANY;        if(bind(listen_sock, (struct sockaddr*)&local, sizeof(local)) < 0)        {            std::cerr << "bind error" << std::endl;            exit(3);        }        if(listen(listen_sock, BACKLOG) < 0)        {            std::cerr << "listen error" << std::endl;            exit(4);        }    }    static void* service(void* p)    {        int sock = *(int*)p;        pthread_detach(pthread_self()); // 线程分离，主线程无需等待子线程，子线程指向完成自行退出        char buf[128];        while(true)        {            buf[0] = '\0';            ssize_t s = recv(sock, buf, sizeof(buf)-1, 0);            std::cout << s << std::endl;            if(s > 0)            {                buf[s] = '\0';                std::cout << "client # " << buf << std::endl;                send(sock, buf, strlen(buf), 0);            }            if(s == 0)            {                close(sock);                std::cout << "client quit" << std::endl;                break;            }        }    }    void start()    {        struct sockaddr_in endpoint;        while(true)        {            socklen_t len = sizeof(endpoint);            int sock = accept(listen_sock, (struct sockaddr*)&endpoint, &len);            if(sock < 0)            {                std::cerr << "accept error" << std::endl;                continue;            }            std::cout << "get a link" << std::endl;            pthread_t tid;            int* p = new int;            *p = sock;            pthread_create(&tid, NULL, service, (void*)p);        }    }    ~tcpServer()    {    }};#endif</code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> net </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx线程池</title>
      <link href="2021/05/04/ngx_thread_pool/"/>
      <url>2021/05/04/ngx_thread_pool/</url>
      
        <content type="html"><![CDATA[<h4 id="nginx线程池"><a href="#nginx线程池" class="headerlink" title="nginx线程池"></a>nginx线程池</h4><pre class=" language-c++"><code class="language-c++">// task链表struct ngx_thread_task_s {    ngx_thread_task_t   *next; // 指向下一个task结构    ngx_uint_t          id; // 起标识作用的id    void                *ctx; // 传给handler的参数    void                (*handler)(void *data, ngx_log_t *log); // 要执行的任务(函数指针)    ngx_event_t         event;};// 存取任务的数据结构(链表实现的队列)typedef struct {    ngx_thread_task_t        *first; // 队尾    ngx_thread_task_t       **last; // 队头} ngx_thread_pool_queue_t;struct ngx_thread_pool_s {    ngx_thread_mutex_t        mtx; // 互斥锁：其本质是 pthread_mutex_t，使用的pthread库    ngx_thread_pool_queue_t   queue; // 通过这个数据结构的两个指针，添加task，取task交给线程执行    ngx_int_t                 waiting;    ngx_thread_cond_t         cond; // 条件变量：其本质是 pthread_cond_t，使用的pthread库    ngx_log_t                *log;    ngx_str_t                 name; // 线程池名字，默认default    ngx_uint_t                threads; // 线程池中线程的数量    ngx_int_t                 max_queue; // 队列中task最大数量    u_char                   *file;    ngx_uint_t                line;};</code></pre><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><ol><li><p>static ngx_int_t ngx_thread_pool_init(ngx_thread_pool_t *tp, ngx_log_t *log, ngx_pool_t *pool): 初始化线程池</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> ngx_int_t  <span class="token function">ngx_thread_pool_init</span><span class="token punctuation">(</span>ngx_thread_pool_t <span class="token operator">*</span>tp<span class="token punctuation">,</span> ngx_log_t <span class="token operator">*</span>log<span class="token punctuation">,</span> ngx_pool_t <span class="token operator">*</span>pool<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span>             err<span class="token punctuation">;</span>    pthread_t       tid<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 线程id</span> ngx_uint_t      n<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 线程个数</span>    pthread_attr_t  attr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设置线程属性的对象</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_notify <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_log_error</span><span class="token punctuation">(</span>NGX_LOG_ALERT<span class="token punctuation">,</span> log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>               <span class="token string">"the configured event method cannot be used with thread pools"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">ngx_thread_pool_queue_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tp<span class="token operator">-></span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*        #define ngx_thread_pool_queue_init(q)                                         \          (q)->first = NULL;                                                        \          (q)->last = &amp;(q)->first      初始化ngx_thread_pool_queue_t：空队列    */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_thread_mutex_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tp<span class="token operator">-></span>mtx<span class="token punctuation">,</span> log<span class="token punctuation">)</span> <span class="token operator">!=</span> NGX_OK<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*        ngx_int_t ngx_thread_mutex_create(ngx_thread_mutex_t *mtx, ngx_log_t *log)        {            ngx_err_t            err;            pthread_mutexattr_t  attr; // 设置互斥锁属性的结构            err = pthread_mutexattr_init(&amp;attr); // 初始化锁属性结构            if (err != 0) {                ngx_log_error(NGX_LOG_EMERG, log, err,                              "pthread_mutexattr_init() failed");                return NGX_ERROR;            }            err = pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK);            // 通过：man pthread_mutexattr_settype 查询手册得知，这个函数功能是设置锁的类型。            // PTHREAD_MUTEX_ERRORCHECK：这种类型的互斥锁提供错误检查，一个线程试图重新锁            // 互斥锁而不首先解锁它将返回一个错误。试图解锁另一个线程已锁定的互斥锁的线程将返回            // 一个错误。一个线程尝试解锁已解锁的互斥锁将返回一个错误。            // 出现上述三种情况时就会范湖错误。            // 由此可知：生产者将task初始化好之后放入ngx_thread_pool_queue_t，线程池的线程再去这个链表中获取task，            // 获取task时如果发现有其它线程已经在操作这个链表了，线程不会进入阻塞，会直接return，因此线程处理task这            // 个过程是异步非阻塞的            if (err != 0) {                ngx_log_error(NGX_LOG_EMERG, log, err,                              "pthread_mutexattr_settype"                              "(PTHREAD_MUTEX_ERRORCHECK) failed");                return NGX_ERROR;            }            err = pthread_mutex_init(mtx, &amp;attr); // 这一步才是真正的初始化锁并给锁设置属性            if (err != 0) {                ngx_log_error(NGX_LOG_EMERG, log, err,                              "pthread_mutex_init() failed");                return NGX_ERROR;            }            err = pthread_mutexattr_destroy(&amp;attr); // 销毁attr，属性已经设置完，可以释放，避免内存泄露            if (err != 0) {                ngx_log_error(NGX_LOG_ALERT, log, err,                              "pthread_mutexattr_destroy() failed");            }            return NGX_OK;        }    */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_thread_cond_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tp<span class="token operator">-></span>cond<span class="token punctuation">,</span> log<span class="token punctuation">)</span> <span class="token operator">!=</span> NGX_OK<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 初始条件变量，如果初始化失败则线程池的初始化就是有问题的，之前创建的互斥锁资源需要释放</span>        <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">ngx_thread_mutex_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tp<span class="token operator">-></span>mtx<span class="token punctuation">,</span> log<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*      ngx_int_t ngx_thread_cond_create(ngx_thread_cond_t *cond, ngx_log_t *log)      {          ngx_err_t  err;          err = pthread_cond_init(cond, NULL);          if (err == 0) {              return NGX_OK;          }          ngx_log_error(NGX_LOG_EMERG, log, err, "pthread_cond_init() failed");          return NGX_ERROR;      }    */</span>    tp<span class="token operator">-></span>log <span class="token operator">=</span> log<span class="token punctuation">;</span>    err <span class="token operator">=</span> <span class="token function">pthread_attr_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化给线程设置属性的结构</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_log_error</span><span class="token punctuation">(</span>NGX_LOG_ALERT<span class="token punctuation">,</span> log<span class="token punctuation">,</span> err<span class="token punctuation">,</span>                      <span class="token string">"pthread_attr_init() failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    err <span class="token operator">=</span> <span class="token function">pthread_attr_setdetachstate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">,</span> PTHREAD_CREATE_DETACHED<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 线程分离，这种属性的线程在运行结束后会自动释放所有资源，无需等待，而无需使用pthread_join进行回收，避免阻塞主线程。这里仅仅初始化attr结构，并未真正意义上给线程设置属性。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_log_error</span><span class="token punctuation">(</span>NGX_LOG_ALERT<span class="token punctuation">,</span> log<span class="token punctuation">,</span> err<span class="token punctuation">,</span>                      <span class="token string">"pthread_attr_setdetachstate() failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">if</span> 0</span>    err <span class="token operator">=</span> <span class="token function">pthread_attr_setstacksize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">,</span> PTHREAD_STACK_MIN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_log_error</span><span class="token punctuation">(</span>NGX_LOG_ALERT<span class="token punctuation">,</span> log<span class="token punctuation">,</span> err<span class="token punctuation">,</span>                      <span class="token string">"pthread_attr_setstacksize() failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> tp<span class="token operator">-></span>threads<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 创建n个线程</span>        err <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>attr<span class="token punctuation">,</span> ngx_thread_pool_cycle<span class="token punctuation">,</span> tp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 线程执行的函数是ngx_thread_pool_cycle，给ngx_thread_pool_cycle函数的参数是tp(线程池本身)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ngx_log_error</span><span class="token punctuation">(</span>NGX_LOG_ALERT<span class="token punctuation">,</span> log<span class="token punctuation">,</span> err<span class="token punctuation">,</span>                          <span class="token string">"pthread_create() failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 此时n个线程已经创建完毕，它们都执行同一个工作：执行ngx_thread_pool_cycle函数（获取任务，执行任务）</span>    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">pthread_attr_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 销毁设置线程属性的结构，避免内存泄露</span>    <span class="token keyword">return</span> NGX_OK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>static void * ngx_thread_pool_cycle(void *data)</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">ngx_thread_pool_cycle</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_thread_pool_t <span class="token operator">*</span>tp <span class="token operator">=</span> data<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 线程池指针</span>    <span class="token keyword">int</span>                 err<span class="token punctuation">;</span>    sigset_t            set<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 线程的信号集</span>    ngx_thread_task_t  <span class="token operator">*</span>task<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// task组成队列（叫链表也行）中的元素，元素结构中有个函数指针，也就是要执行的任务函数的指针</span><span class="token macro property">#<span class="token directive keyword">if</span> 0</span>    <span class="token function">ngx_time_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token function">ngx_log_debug1</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_CORE<span class="token punctuation">,</span> tp<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                   <span class="token string">"thread in pool \"%V\" started"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>tp<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 所有信号对应的bitmap上都设置为1</span>    <span class="token function">sigdelset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>set<span class="token punctuation">,</span> SIGILL<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 执行了非法指令</span>    <span class="token function">sigdelset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>set<span class="token punctuation">,</span> SIGFPE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 发生致命的算数运算错误 </span>    <span class="token function">sigdelset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>set<span class="token punctuation">,</span> SIGSEGV<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 段错误</span>    <span class="token function">sigdelset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>set<span class="token punctuation">,</span> SIGBUS<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 非法地址</span>    err <span class="token operator">=</span> <span class="token function">pthread_sigmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>set<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 除去以上四个信号加上SIGKILL信号(SIGKILL不可被阻塞)，其它信号都会被阻塞（block）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_log_error</span><span class="token punctuation">(</span>NGX_LOG_ALERT<span class="token punctuation">,</span> tp<span class="token operator">-></span>log<span class="token punctuation">,</span> err<span class="token punctuation">,</span> <span class="token string">"pthread_sigmask() failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_thread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tp<span class="token operator">-></span>mtx<span class="token punctuation">,</span> tp<span class="token operator">-></span>log<span class="token punctuation">)</span> <span class="token operator">!=</span> NGX_OK<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 给mtx上锁，如果mtx已经被锁了则会报错（因为之前设置过锁属性--PTHREAD_MUTEX_ERRORCHECK），这个线程执行结束，走到</span>            <span class="token comment" spellcheck="true">// 这一步链表上的task并没有被取下来。如果线程获取task时发现task队列正有其它线程在从中获取任务则直接结束，不进行阻塞。</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 有一点没想明白：如果return那么这个线程就结束了，线程池里的线程数量会减少</span>              <span class="token comment" spellcheck="true">// 在线程们刚启动的时候可能会出现多个线程争抢一把锁的问题，ngx这里是直接将争抢锁的线程结束掉而不是阻塞，虽然可能会造成某些线程退出，</span>              <span class="token comment" spellcheck="true">// 造成线程池中线程数量减少，但是这里不阻塞选择结束，带来了性能上的提升，且并不是会持续减少，当所有线程都在cond条件变量下等待时，</span>              <span class="token comment" spellcheck="true">// 线程的运行就是有序的了，就不会出现争抢锁导致锁退出的情况了。虽然线程数量会减少，但是也并不是会一直减少，在所有线程进入cond条件变量下</span>              <span class="token comment" spellcheck="true">// 时，便不会再发生争抢锁的情况，且效率比互斥锁要更高。</span>              <span class="token comment" spellcheck="true">// 在此过程中生产者是worker进程，生产者只有一个！！！，线程多个，所以消费起来，消费者必然比生产者快。</span>        <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">// 上锁成功，进入临界区！！！</span>        <span class="token comment" spellcheck="true">/* the number may become negative */</span>        tp<span class="token operator">-></span>waiting<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 未知</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>tp<span class="token operator">-></span>queue<span class="token punctuation">.</span>first <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果task队列空（没有任务取），则线程在cond条件变量下休眠，直到被唤醒。使用while：如果醒来发现任务队列还是为空继续休眠</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_thread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tp<span class="token operator">-></span>cond<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tp<span class="token operator">-></span>mtx<span class="token punctuation">,</span> tp<span class="token operator">-></span>log<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 阻塞在当前位置</span>                <span class="token operator">!=</span> NGX_OK<span class="token punctuation">)</span>               <span class="token comment" spellcheck="true">// pthread_cond_wait函数在进入休眠时会将锁释放，重新被唤醒时再加锁。如果wait失败则锁不会被释放，所以在这里是用while而不是if，ngx_thread_cond_wait执行失败会释放锁</span>            <span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">ngx_thread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tp<span class="token operator">-></span>mtx<span class="token punctuation">,</span> tp<span class="token operator">-></span>log<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 解锁</span>                <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        task <span class="token operator">=</span> tp<span class="token operator">-></span>queue<span class="token punctuation">.</span>first<span class="token punctuation">;</span>         tp<span class="token operator">-></span>queue<span class="token punctuation">.</span>first <span class="token operator">=</span> task<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 取出一个task</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tp<span class="token operator">-></span>queue<span class="token punctuation">.</span>first <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 判断是否取完，取完则将task队列恢复至初始状态</span>            tp<span class="token operator">-></span>queue<span class="token punctuation">.</span>last <span class="token operator">=</span> <span class="token operator">&amp;</span>tp<span class="token operator">-></span>queue<span class="token punctuation">.</span>first<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_thread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tp<span class="token operator">-></span>mtx<span class="token punctuation">,</span> tp<span class="token operator">-></span>log<span class="token punctuation">)</span> <span class="token operator">!=</span> NGX_OK<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 取到task之后是没必要等task中的任务执行完毕之后再释放锁，取出之后就可以立马释放锁了，让其它线程取，提高线程协作的效率。</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">if</span> 0</span>        <span class="token function">ngx_time_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>        <span class="token function">ngx_log_debug2</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_CORE<span class="token punctuation">,</span> tp<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                       <span class="token string">"run task #%ui in thread pool \"%V\""</span><span class="token punctuation">,</span>                       task<span class="token operator">-></span>id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tp<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        task<span class="token operator">-></span><span class="token function">handler</span><span class="token punctuation">(</span>task<span class="token operator">-></span>ctx<span class="token punctuation">,</span> tp<span class="token operator">-></span>log<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 此时可以执行task中的任务了</span>        <span class="token function">ngx_log_debug2</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_CORE<span class="token punctuation">,</span> tp<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                       <span class="token string">"complete task #%ui in thread pool \"%V\""</span><span class="token punctuation">,</span>                       task<span class="token operator">-></span>id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tp<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        task<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token function">ngx_spinlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ngx_thread_pool_done_lock<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2048</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// task执行完需要将task添加到done链表上去，添加这个操作执行的时间非常短，所以这里采用的自旋锁而不是互斥锁，提高效率，减少线程切换带来的开销。</span>        <span class="token operator">*</span>ngx_thread_pool_done<span class="token punctuation">.</span>last <span class="token operator">=</span> task<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将task添加到链表末尾</span>        ngx_thread_pool_done<span class="token punctuation">.</span>last <span class="token operator">=</span> <span class="token operator">&amp;</span>task<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token function">ngx_memory_barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ngx_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ngx_thread_pool_done_lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 解锁队列</span>        <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">ngx_notify</span><span class="token punctuation">(</span>ngx_thread_pool_handler<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 暂时没看懂，貌似和事件驱动模型有关</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token function">ngx_thread_pool_handler</span><span class="token punctuation">(</span>ngx_event_t <span class="token operator">*</span>ev<span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_event_t        <span class="token operator">*</span>event<span class="token punctuation">;</span>    ngx_thread_task_t  <span class="token operator">*</span>task<span class="token punctuation">;</span>    <span class="token function">ngx_log_debug0</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_CORE<span class="token punctuation">,</span> ev<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"thread pool handler"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ngx_spinlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ngx_thread_pool_done_lock<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2048</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用的自旋锁，将已完成的task加入至ngx_thread_pool_done链表，操作步骤少，需要的时间也少，使用自旋锁是最合适的，避免进入阻塞，线程切换带来的开销</span>    task <span class="token operator">=</span> ngx_thread_pool_done<span class="token punctuation">.</span>first<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// task保存头结点，这一段代码：一次取出done链表上的多个task</span>    ngx_thread_pool_done<span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    ngx_thread_pool_done<span class="token punctuation">.</span>last <span class="token operator">=</span> <span class="token operator">&amp;</span>ngx_thread_pool_done<span class="token punctuation">.</span>first<span class="token punctuation">;</span>    <span class="token function">ngx_memory_barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ngx_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ngx_thread_pool_done_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>task<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 遍历从done链表上取下来的多个结点</span>        <span class="token function">ngx_log_debug1</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_CORE<span class="token punctuation">,</span> ev<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                       <span class="token string">"run completion handler for task #%ui"</span><span class="token punctuation">,</span> task<span class="token operator">-></span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        event <span class="token operator">=</span> <span class="token operator">&amp;</span>task<span class="token operator">-></span>event<span class="token punctuation">;</span>        task <span class="token operator">=</span> task<span class="token operator">-></span>next<span class="token punctuation">;</span>        event<span class="token operator">-></span>complete <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 标记为已经完成</span>        event<span class="token operator">-></span>active <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        event<span class="token operator">-></span><span class="token function">handler</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>ngx_thread_pool_t <em>ngx_thread_pool_add*</em>(<strong>ngx_conf_t *cf</strong>,** ngx_str_t *name)：添加一个内存池</p><pre class=" language-c"><code class="language-c">ngx_thread_pool_t <span class="token operator">*</span><span class="token function">ngx_thread_pool_add</span><span class="token punctuation">(</span>ngx_conf_t <span class="token operator">*</span>cf<span class="token punctuation">,</span> ngx_str_t <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_thread_pool_t       <span class="token operator">*</span>tp<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span>tpp<span class="token punctuation">;</span>    ngx_thread_pool_conf_t  <span class="token operator">*</span>tcf<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没定义线程池的名字默认为 "default"</span>        name <span class="token operator">=</span> <span class="token operator">&amp;</span>ngx_thread_pool_default<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    tp <span class="token operator">=</span> <span class="token function">ngx_thread_pool_get</span><span class="token punctuation">(</span>cf<span class="token operator">-></span>cycle<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 先查找线程池的集合，判断其中是否已经创建过，有则直接返回其指针</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> tp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    tp <span class="token operator">=</span> <span class="token function">ngx_pcalloc</span><span class="token punctuation">(</span>cf<span class="token operator">-></span>pool<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ngx_thread_pool_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在内存池上给线程池的结构申请内存</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    tp<span class="token operator">-></span>name <span class="token operator">=</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>    tp<span class="token operator">-></span>file <span class="token operator">=</span> cf<span class="token operator">-></span>conf_file<span class="token operator">-></span>file<span class="token punctuation">.</span>name<span class="token punctuation">.</span>data<span class="token punctuation">;</span>    tp<span class="token operator">-></span>line <span class="token operator">=</span> cf<span class="token operator">-></span>conf_file<span class="token operator">-></span>line<span class="token punctuation">;</span>    tcf <span class="token operator">=</span> <span class="token punctuation">(</span>ngx_thread_pool_conf_t <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">ngx_get_conf</span><span class="token punctuation">(</span>cf<span class="token operator">-></span>cycle<span class="token operator">-></span>conf_ctx<span class="token punctuation">,</span>                                                  ngx_thread_pool_module<span class="token punctuation">)</span><span class="token punctuation">;</span>    tpp <span class="token operator">=</span> <span class="token function">ngx_array_push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tcf<span class="token operator">-></span>pools<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tpp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">*</span>tpp <span class="token operator">=</span> tp<span class="token punctuation">;</span>    <span class="token keyword">return</span> tp<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>ngx_thread_pool_t <em>ngx_thread_pool_get*</em>(<strong>ngx_cycle_t *cycle</strong>,** ngx_str_t *name)：通过name获取内存池指针</p><pre class=" language-c"><code class="language-c">ngx_thread_pool_t <span class="token operator">*</span><span class="token function">ngx_thread_pool_get</span><span class="token punctuation">(</span>ngx_cycle_t <span class="token operator">*</span>cycle<span class="token punctuation">,</span> ngx_str_t <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_uint_t                i<span class="token punctuation">;</span>    ngx_thread_pool_t       <span class="token operator">*</span><span class="token operator">*</span>tpp<span class="token punctuation">;</span>    ngx_thread_pool_conf_t   <span class="token operator">*</span>tcf<span class="token punctuation">;</span>    tcf <span class="token operator">=</span> <span class="token punctuation">(</span>ngx_thread_pool_conf_t <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">ngx_get_conf</span><span class="token punctuation">(</span>cycle<span class="token operator">-></span>conf_ctx<span class="token punctuation">,</span>                                                  ngx_thread_pool_module<span class="token punctuation">)</span><span class="token punctuation">;</span>    tpp <span class="token operator">=</span> tcf<span class="token operator">-></span>pools<span class="token punctuation">.</span>elts<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tcf<span class="token operator">-></span>pools<span class="token punctuation">.</span>nelts<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tpp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>name<span class="token punctuation">.</span>len <span class="token operator">==</span> name<span class="token operator">-></span>len            <span class="token operator">&amp;&amp;</span> <span class="token function">ngx_strncmp</span><span class="token punctuation">(</span>tpp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>name<span class="token punctuation">.</span>data<span class="token punctuation">,</span> name<span class="token operator">-></span>data<span class="token punctuation">,</span> name<span class="token operator">-></span>len<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> tpp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>static void ngx_thread_pool_destroy<strong>(</strong>ngx_thread_pool_t *tp)：销毁线程池</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token function">ngx_thread_pool_destroy</span><span class="token punctuation">(</span>ngx_thread_pool_t <span class="token operator">*</span>tp<span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_uint_t           n<span class="token punctuation">;</span>    ngx_thread_task_t    task<span class="token punctuation">;</span>    <span class="token keyword">volatile</span> ngx_uint_t  lock<span class="token punctuation">;</span>    <span class="token function">ngx_memzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>task<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ngx_thread_task_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    task<span class="token punctuation">.</span>handler <span class="token operator">=</span> ngx_thread_pool_exit_handler<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 修改task的handler指针，指向退出线程的函数</span>    task<span class="token punctuation">.</span>ctx <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>lock<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> tp<span class="token operator">-></span>threads<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lock <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_thread_task_post</span><span class="token punctuation">(</span>tp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>task<span class="token punctuation">)</span> <span class="token operator">!=</span> NGX_OK<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 判断当前task是否能退出，能退出则会解锁lock</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ngx_sched_yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        task<span class="token punctuation">.</span>event<span class="token punctuation">.</span>active <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">ngx_thread_cond_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tp<span class="token operator">-></span>cond<span class="token punctuation">,</span> tp<span class="token operator">-></span>log<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 销毁条件变量</span>    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">ngx_thread_mutex_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tp<span class="token operator">-></span>mtx<span class="token punctuation">,</span> tp<span class="token operator">-></span>log<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 销毁互斥锁</span><span class="token punctuation">}</span></code></pre></li><li><p>ngx_int_t ngx_thread_task_post(ngx_thread_pool_t *tp, ngx_thread_task_t *task)：添加task进入task队列</p><pre class=" language-c"><code class="language-c">ngx_int_t<span class="token function">ngx_thread_task_post</span><span class="token punctuation">(</span>ngx_thread_pool_t <span class="token operator">*</span>tp<span class="token punctuation">,</span> ngx_thread_task_t <span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token operator">-></span>event<span class="token punctuation">.</span>active<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token function">ngx_log_error</span><span class="token punctuation">(</span>NGX_LOG_ALERT<span class="token punctuation">,</span> tp<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                     <span class="token string">"task #%ui already active"</span><span class="token punctuation">,</span> task<span class="token operator">-></span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_thread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tp<span class="token operator">-></span>mtx<span class="token punctuation">,</span> tp<span class="token operator">-></span>log<span class="token punctuation">)</span> <span class="token operator">!=</span> NGX_OK<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>tp<span class="token operator">-></span>waiting <span class="token operator">>=</span> tp<span class="token operator">-></span>max_queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">ngx_thread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tp<span class="token operator">-></span>mtx<span class="token punctuation">,</span> tp<span class="token operator">-></span>log<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">ngx_log_error</span><span class="token punctuation">(</span>NGX_LOG_ERR<span class="token punctuation">,</span> tp<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                     <span class="token string">"thread pool \"%V\" queue overflow: %i tasks waiting"</span><span class="token punctuation">,</span>                     <span class="token operator">&amp;</span>tp<span class="token operator">-></span>name<span class="token punctuation">,</span> tp<span class="token operator">-></span>waiting<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   task<span class="token operator">-></span>event<span class="token punctuation">.</span>active <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   task<span class="token operator">-></span>id <span class="token operator">=</span> ngx_thread_pool_task_id<span class="token operator">++</span><span class="token punctuation">;</span>   task<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_thread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tp<span class="token operator">-></span>cond<span class="token punctuation">,</span> tp<span class="token operator">-></span>log<span class="token punctuation">)</span> <span class="token operator">!=</span> NGX_OK<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 有task入队事件发生，唤醒线程处理，奇怪的是为什么是先唤醒消费者线程，再把task放入队列</span>       <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">ngx_thread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tp<span class="token operator">-></span>mtx<span class="token punctuation">,</span> tp<span class="token operator">-></span>log<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token operator">*</span>tp<span class="token operator">-></span>queue<span class="token punctuation">.</span>last <span class="token operator">=</span> task<span class="token punctuation">;</span>   tp<span class="token operator">-></span>queue<span class="token punctuation">.</span>last <span class="token operator">=</span> <span class="token operator">&amp;</span>task<span class="token operator">-></span>next<span class="token punctuation">;</span>   tp<span class="token operator">-></span>waiting<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">ngx_thread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tp<span class="token operator">-></span>mtx<span class="token punctuation">,</span> tp<span class="token operator">-></span>log<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">ngx_log_debug2</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_CORE<span class="token punctuation">,</span> tp<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                  <span class="token string">"task #%ui added to thread pool \"%V\""</span><span class="token punctuation">,</span>                  task<span class="token operator">-></span>id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tp<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> NGX_OK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><img src="../../../Desktop/source/image/ngx_task_queue.png" alt="ngx_task_queue"></p><p>线程从task队列获取任务时，尽可能的多获取任务多执行任务，而不是多个线程同步式的去从task队列获取，减少线程的切换。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thread_pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++多态</title>
      <link href="2021/05/03/c++polymorphic/"/>
      <url>2021/05/03/c++polymorphic/</url>
      
        <content type="html"><![CDATA[<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;class Person{public:    virtual void ByTicket()    {        cout << "正常排队----全价格买票" << endl;    }};class Student: public Person{public:    virtual void ByTicket()    {        cout << "正常排队----半价格买票" << endl;    }};// 1、继承类中，虚函数的重写。//    重写的条件：//          a. 父子类中的函数都必须是虚函数。//          b. 函数名、参数、返回值都要相同。// 2、基类指针或者指针去调用这个虚函数。//    指向谁，调用谁的虚函数void Buy(Person& p){      // 不满足多态：跟类型有关，也就是说p是什么类型，就调用这个类型的成员函数。      // 满足多态：跟对象有关，也就是说指向的是哪个对象就调用哪个的虚函数。    p.ByTicket();}int main(){    Person p;    Buy(p);    Student s;    Buy(s);    return 0;}</code></pre><h5 id="虚函数重写的两个例外"><a href="#虚函数重写的两个例外" class="headerlink" title="虚函数重写的两个例外"></a>虚函数重写的两个例外</h5><h6 id="1、协变"><a href="#1、协变" class="headerlink" title="1、协变"></a>1、协变</h6><p>基类与派生类虚函数返回值类型不同。</p><p>派生类重写基类虚函数时，与基类虚函数返回值类型不同。即基类虚函数返回基类对象的指针或引用，派生类虚函数返回派生类对象的指针或引用。</p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;class A{};class B: public A{};class Person{public:    virtual A* ByTicket()    {        cout << "正常排队----全价格买票" << endl;        return new A;    }};class Student: public Person{public:    virtual B* ByTicket()    {        cout << "正常排队----半价格买票" << endl;        return new B;    }};void Buy(Person& p){    p.ByTicket();}int main(){    Person p;    Buy(p);    Student s;    Buy(s);    return 0;}</code></pre><h6 id="2、析构函数的重写"><a href="#2、析构函数的重写" class="headerlink" title="2、析构函数的重写"></a>2、析构函数的重写</h6><p>基类与派生类的析构函数名不同</p><p>如果基类的析构函数为虚函数，此时派生类析构函数只要定义，无论是否加关键字virtual，都与基类的析构函数构成重写。虽然基类与派生类的析构函数名字不同，违背了重写的规则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名字统一处理成destructor。</p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;class Person{public:    virtual ~Person()    {        cout << "~Person" << endl;    }};class Student: public Person{public:    ~Student()    {        cout << "~Student" << endl;    }};int main(){    /*    Person p1;    Student s1;output:    ~Student // s1后入栈后销毁，销毁时先调用自己的析构函数    ~Person // 因为Student继承了Person类，所以派生类在销毁时还需要调用父类的析构函数去销毁属于父类的那部分数据    ~Person // 最后调用父类的析构函数    */    /*    1、如果父子类的析构函数不构成多态    Person *p1 = new Person;    Person *p2 = new Student;    delete p1; // p1.destructor()    delete p2; // p2.destructor() // 不构成多态就会按照类型去调用output:    ~Person // 父类调用析构函数    ~Person    // 由于编译器的处理，析构函数名会被处理成destructor，delete父类指针，会调用父类的析构函数(屏蔽了子类函数的析构函数，它们是同名成员destructor)，此时Student类对象中属于父类的数据被析构函数销毁，但是子类的析构函数没有被调用，造成内存泄露。    */    /*    2、如果父子类的析构函数构成多态    Person *p1 = new Person;    Person *p2 = new Student;    delete p1;    delete p2;output:    ~Person // 父类析构    ~Student // delete时，调用对象对应的析构函数    ~Person    */    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++继承</title>
      <link href="2021/04/25/c++inheritance/"/>
      <url>2021/04/25/c++inheritance/</url>
      
        <content type="html"><![CDATA[<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h5 id="1、什么是继承？"><a href="#1、什么是继承？" class="headerlink" title="1、什么是继承？"></a>1、什么是继承？</h5><p>继承是面向对象程序设计使代码可以复用的重要手段，允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生的新类叫派生类。继承是类设计层次的复用。</p><pre class=" language-c++"><code class="language-c++">class Person{public:    void speak()    {        ;    }    void sleep()    {        ;    }public:    int age;    string name;private:    float weight;};class boy: public Person{};class girl: public Person{};</code></pre><p>boy类和girl类都具有speak()、sleep()行为，以及年龄、名字属性，它们都可以从Person类中继承，而没有必要在他们自己的类中再次声明定义。在这个例子中：Person类称为父类或者基类，boy、girl类称为子类或者派生类。</p><h5 id="2、继承定义"><a href="#2、继承定义" class="headerlink" title="2、继承定义"></a>2、继承定义</h5><h6 id="继承关系和访问限定符"><a href="#继承关系和访问限定符" class="headerlink" title="继承关系和访问限定符"></a>继承关系和访问限定符</h6><p>继承方式：</p><ul><li>public 继承</li><li>protected 继承</li><li>private 继承</li></ul><h6 id="继承父类，子类访问父类成员的变化。"><a href="#继承父类，子类访问父类成员的变化。" class="headerlink" title="继承父类，子类访问父类成员的变化。"></a>继承父类，子类访问父类成员的变化。</h6><table><thead><tr><th align="left">类成员/继承方式</th><th align="center">public继承</th><th align="center">protected继承</th><th align="center">private继承</th></tr></thead><tbody><tr><td align="left">基类的public成员</td><td align="center">派生类的public成员</td><td align="center">派生类的protected成员</td><td align="center">派生类的private成员</td></tr><tr><td align="left">基类的protected成员</td><td align="center">派生类的protected成员</td><td align="center">派生类的protected成员</td><td align="center">派生类的private成员</td></tr><tr><td align="left">基类的private成员</td><td align="center">在派生类中不可见</td><td align="center">在派生类中不可见</td><td align="center">在派生类中不可见</td></tr></tbody></table><p>1、在子类中的访问方式 = min(基类访问方式，继承方式)。</p><p>2、基类private成员，在子类中不可见。(不可见，但是任然被继承)。</p><pre class=" language-c++"><code class="language-c++">#include <string>#include <iostream>using namespace std;class Person{public:    void speak()    {        ;    }    void sleep()    {        ;    }public:    int age;    string name;private:    float weight;};class boy: public Person{};class girl: public Person{};int main(){    cout << "sizeof(Person) = " << sizeof(Person) << endl; // 24    cout << "sizeof(boy) = " << sizeof(boy) << endl; // 24    cout << "sizeof(girl) = " << sizeof(girl) << endl; // 24      // Person、boy、girl类的大小相同    boy b;    cout << b.Person::weight << endl; // error,父类的private成员，派生类无法访问    return 0;}</code></pre><h4 id="基类和派生类对象赋值转换（只存在于public继承）"><a href="#基类和派生类对象赋值转换（只存在于public继承）" class="headerlink" title="基类和派生类对象赋值转换（只存在于public继承）"></a>基类和派生类对象赋值转换（只存在于public继承）</h4><ul><li>派生类可以赋值给 基类的对象 / 基类的指针 / 基类的引用，有个形象的说法叫做切片或者切割。</li><li>基类对象不能赋值给派生类对象。</li><li>基类的指针可以通过强制类型转换赋值给派生类的指针，但是必须是基类的指针是指向派生类对象时才是安全的。</li></ul><p><img src="https://img.3amupupup.online/CppInheritance.png" alt="切片"></p><pre class=" language-c++"><code class="language-c++">#include <string>#include <iostream>using namespace std;class Person{public:    Person()    {        _name = "duwei";        _sex = "man";        _age = 24;    }public:    string _name;    string _sex;    int _age;};class Student: public Person{public:    int _No;};int main(){    Person p;    Student stu;    p = stu;      cout << p._name << "," << p._sex << "," << p._age << endl; // duwei,man,24    cout << p._NO << endl; // 错误：‘class Person’没有名为‘_NO’的成员。如图所示，发生了切片    return 0;}</code></pre><h5 id="3、继承中的作用域"><a href="#3、继承中的作用域" class="headerlink" title="3、继承中的作用域"></a>3、继承中的作用域</h5><blockquote><ol><li><p>在继承体系中基类和派生类都有独立的作用域。</p></li><li><p>子类和父类中存在同名成员，子类成员将屏蔽对父类中同名成员的直接访问，这种情况叫隐藏，也叫重定义。</p><pre class=" language-c++"><code class="language-c++">#include <string>#include <iostream>using namespace std;class Person{public:    string _name = "duwei";    int _age = 24;    string _city = "hz";};class Student:public Person{public:    string _name = "zhangsan";    int _age = 25;    string _home = "hunan";};int main(){    Student stu;    cout << stu._name << endl; // zhangsan    cout << stu.Person::_name << endl; // duwei 如果需要访问父类中的同名成员，需要加上作用域。    return 0;}</code></pre></li><li><p>如果是成员函数的隐藏，只需要函数名相同就构成隐藏。</p></li><li><p>在实际继承体系中，最好不要定义同名的成员。</p></li></ol></blockquote><h5 id="4、派生类的默认成员函数"><a href="#4、派生类的默认成员函数" class="headerlink" title="4、派生类的默认成员函数"></a>4、派生类的默认成员函数</h5><ol><li><p>派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。<strong>如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段显示调用。</strong></p><pre class=" language-c++"><code class="language-c++">#include <string>#include <iostream>using namespace std;class Person{public:    Person()    {        _name = "duwei";        _sex = "man";        _age = 24;    }public:    string _name;    string _sex;    int _age;};class Student: public Person{public:    Student(int No)    : Person() // 继承下来的父类部分成员，要使用父类的构造函数去初始化，不能自己显示的初始化。    , _No(No)    {}public:    int _No;};int main(){    Student s(20);    cout << s._name << "," << s._sex << "," << s._age << endl; // duwei,man,24    cout << s._No << endl; // 20    return 0;}</code></pre></li><li><p>派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化。</p><pre class=" language-c++"><code class="language-c++">#include <string>#include <iostream>using namespace std;class Person{public:   Person()   {       _name = "duwei";       _sex = "man";       _age = 24;   }public:   string _name;   string _sex;   int _age;};class Student: public Person{public:   Student(int No)   : Person()   , _No(No)   {}   Student(const Student &s)   : Person(s) // 存在切片行为，派生类对象赋值给基类对象   , _No(s._No)   {}public:   int _No;};int main(){   Student s(20);   Student s2(s);   return 0;}</code></pre></li><li><p>派生类的operator=必须要调用基类的operator=完成基的复制。</p><pre class=" language-c++"><code class="language-c++">#include <string>#include <iostream>using namespace std;class Person{public:    Person()    {        _name = "duwei";        _sex = "man";        _age = 24;    }public:    string _name;    string _sex;    int _age;};class Student: public Person{public:    Student(int No)    : Person()    , _No(No)    {}    Student(const Student &s)    : Person(s)    , _No(s._No)    {}    Student& operator=(const Student &s)    {        if(this != &s)        {            Person::operator=(s); // 需要加上作用域，否则会和子类中的 operator= 产生歧义            _No = s._No;        }        return *this;    }public:    int _No;};int main(){    Student s(20);    Student s2(s);    Student s3 = s2;    return 0;}</code></pre></li><li><p>派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员。因为这样才能保证派生对象先清理派生类成员再清理基类成员的顺序。（先创建的后销毁）</p></li><li><p>派生类对象初始化先调用基类构造再调派生类构造。</p></li><li><p>派生类对象析构清理先调用派生类析构再调基类的析构。</p></li></ol><h5 id="5、继承与友元"><a href="#5、继承与友元" class="headerlink" title="5、继承与友元"></a>5、继承与友元</h5><p>友元关系不能继承，也就是说基类友元不能访问子类私有和保护成员。</p><h5 id="6、继承和静态成员"><a href="#6、继承和静态成员" class="headerlink" title="6、继承和静态成员"></a>6、继承和静态成员</h5><p>基类定义了static静态成员，则整个继承体系里面只有一个这样的成员。无论派生出多少个子类，都只有一 个static成员实例 。</p><h5 id="7、菱形继承"><a href="#7、菱形继承" class="headerlink" title="7、菱形继承"></a>7、菱形继承</h5><h6 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h6><p>一个子类只有一个直接父类时称这个继承关系为单继承。</p><p>![单继承](../Library/Application Support/typora-user-images/image-20210429205858101.png)</p><h6 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h6><p>一个子类有两个或以上直接父类时称这个继承关系为多继承。</p><p>![多继承](../Library/Application Support/typora-user-images/image-20210429210815054.png)</p><h6 id="棱形继承"><a href="#棱形继承" class="headerlink" title="棱形继承"></a>棱形继承</h6><p>多继承的特殊情况</p><p>![棱形继承](../Library/Application Support/typora-user-images/image-20210429210855540.png)</p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;class Person{public:    string name;};class Teacher : public Person{    int _id; // 职工编号};class Student : public Person{public:    int _num; // 学号};class Assistant:public Student, public Teacher{    string _course; // 课程名};int main(){    Assistant a;    // a.name = "duwei"; // 错误：对成员‘name’的请求有歧义    a.Student::name = "duwei"; // 指定父类可以解决二义性，但是数据会存在冗余    a.Teacher::name = "duwei";    return 0;}</code></pre><h6 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h6><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;class Person{public:    string name;};class Teacher : virtual public Person{    int _id; // 职工编号};class Student : virtual public Person{public:    int _num; // 学号};class Assistant:public Student, public Teacher{    string _course; // 课程名};int main(){    Assistant a;    a.name = "duwei";    cout << a.name << endl; // duwei    a.Student::name = "zhangsan";    cout << a.name << endl; // zhangsan    a.Teacher::name = "lisi";    cout << a.name << endl; // lisi    return 0;}</code></pre><h6 id="虚拟继承分析"><a href="#虚拟继承分析" class="headerlink" title="虚拟继承分析"></a>虚拟继承分析</h6><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;class A{public:    int _a;};class B : public A{public:    int _b;};class C : public A{public:    int _c; // 学号};class D: public B, public C{public:    int _d;};int main(){    D d;    cout << sizeof(d) << endl;    d.B::_a = 1;    d.C::_a = 2;    d._b = 3;    d._d = 4;    return 0;}</code></pre><p>使用虚拟继承之后只有一份公共的虚基类成员 A，解决了数据冗余和二义性 </p><p><img src="../image/image-20210502155450341.png" alt="image-20210502155450341"></p><blockquote><p>set p pertty &lt;on/off&gt;: 按照层次打印结构体</p><p>set p obj &lt;on/off&gt;: 在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是off。 使用show print object查看对象选项的设置。</p></blockquote><h5 id="8、linux系统上的继承内存模型"><a href="#8、linux系统上的继承内存模型" class="headerlink" title="8、linux系统上的继承内存模型"></a>8、linux系统上的继承内存模型</h5><h6 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h6><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;class A{public:    int _a;};class B: public A{public:    int _b;};int main(){    B b;    b._a = 1;    b._b = 2;    return 0;}</code></pre><p><img src="../image/image-20210512222839783.png" alt="image-20210512222839783"></p><h6 id="虚继承-1"><a href="#虚继承-1" class="headerlink" title="虚继承"></a>虚继承</h6><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;class A{public:    int _a;};class B: virtual public A{public:    int _b;};int main(){    B b;    b._a = 1;    b._b = 2;    return 0;}</code></pre><p><img src="../image/image-20210512223758389.png" alt="image-20210512223758389"></p><hr><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;class A{public:    int _a;};class B: public A{public:    int _a;};int main(){    B b;    b.A::_a = 3;    b._a = 4;    return 0;}</code></pre><p><img src="../image/image-20210512224541654.png" alt="image-20210512224541654"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thread</title>
      <link href="2021/04/20/thread/"/>
      <url>2021/04/20/thread/</url>
      
        <content type="html"><![CDATA[<h5 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h5><ul><li>在一个程序里的一个执行路线就叫做线程。更准确的定义是：线程是“一个进程的内部序列”。</li><li>一个进程至少有一个线程。</li><li>线程在进程内部运行，本质是在进程地址空间运行。</li><li>透过进程虚拟地址空间，可以看到进程大部分的资源，将进程资源合理的分配给每个执行流，就形成了线程执行流。</li></ul><p>进程：承担系统分配资源的基本实体。为了承担资源操作系统为进程提供了大批数据结构和内存块，以承担程序的数据和代码。</p><p>线程：调度的基本单位，是进程内部的执行流。（线程在进程的地址空间内运行）</p><h5 id="线程优点"><a href="#线程优点" class="headerlink" title="线程优点"></a>线程优点</h5><ul><li><p>创建一个新线程的代价比创建一个新进程代价要小的多。</p><p>进程是承担系统分配资源的基本实体，只有当资源创建好了，这个进程才算是被创建好；而线程只需要创建一个pcb，然后将已分配的部分资源指派给线程就好了。</p></li><li><p>与进程之间的切换相比，线程之间切换需要操作系统做的工作要少很多。（地址空间、页表不需要更换，只需要更换tss）</p><p>线程切换理论上只需要切换tss。线程只对应了进程部分资源。</p></li><li><p>线程占用的资源少</p></li><li><p>能充分利用多处理器的可并行数量</p></li><li><p>在等待慢I/O操作结束时，程序可执行其它计算任务。</p></li><li><p>计算密集型应用，为了能在多处理器系统上运行，将计算分割到多个线程中实现</p></li><li><p>I/O密集应用，为了提高性能，将I/O操作重叠，线程可以同时等待不同的I/O操作。</p></li></ul><h5 id="线程有点"><a href="#线程有点" class="headerlink" title="线程有点"></a>线程有点</h5><ul><li><p>性能损失</p><p>一个很少被外部事件阻塞的计算密集型线程往往无法与其它线程共享一个处理器。如果计算密集型线程的数量比可用处理器多，那么可能会有较大的性能损失，这里性能的损失指的是增加了额外的同步和调度开销，而可用的资源不变。</p></li><li><p>健壮性降低</p><p>编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的偏差或者共享了不该共享的变量而造成的不良影响的可能性是很大的，换句话说线程之间缺乏保护。</p></li><li><p>缺乏访问控制</p><p>进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响。</p></li><li><p>编程难度提高</p></li></ul><h5 id="线程异常"><a href="#线程异常" class="headerlink" title="线程异常"></a>线程异常</h5><p>线程时进程的执行分支，线程出现异常，就类似进程出现异常，进而触发信号机制，终止进程，进程终止，该进程内的所有线程也就随即退出。</p><h5 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h5><ul><li>进程是资源分配的基本单位</li><li>线程时调度的基本单位</li><li>线程共享进程数据，但也拥有自己的一部分数据：<ul><li>线程ID</li><li>*一组寄存器(独立的硬件上下文)</li><li>*栈</li><li>errno</li><li>信号屏蔽字</li><li>调度优先级</li></ul></li></ul><h5 id="进程的多个线程共享"><a href="#进程的多个线程共享" class="headerlink" title="进程的多个线程共享"></a>进程的多个线程共享</h5><p>同一地址空间，因此Text Segment(代码段)、Data Segment(数据区)都是共享的，如果定义一个函数，在各线程中都可以调用，如果定义一个全局变量，在各个线程中都可以访问，除此之外，线程还共享以下进程资源和环境：</p><ul><li>文件描述符</li><li>每种信号的处理方式(SIG_IGN、SIG_DFL)</li><li>当前工作目录</li><li>用户id和组id</li></ul><h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><h6 id="牛刀小试"><a href="#牛刀小试" class="headerlink" title="牛刀小试"></a>牛刀小试</h6><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">thread_run</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am %s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    pthread_t tid<span class="token punctuation">;</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thread_run<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"thread 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建线程，成功返回0，失败返回相对应的错误码。</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am thread!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-shell"><code class="language-shell">☁  ~  ps aux |grep testroot     27491  0.0  0.0  14568   380 pts/0    Sl+  21:41   0:00 ./test☁  ~  ps -alF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD0 S     0 27491 26311  0  80   0 -  3642 hrtime pts/0    00:00:00 test0 R     0 27537 27501  0  80   0 - 38265 -      pts/1    00:00:00 ps☁  ~  ps -aL  PID   LWP TTY          TIME CMD27491 27491 pts/0    00:00:00 test27491 27492 pts/0    00:00:00 test27543 27543 pts/1    00:00:00 ps# LWP ———— 轻量级进程</code></pre><h6 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h6><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">thread_run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"thread 1: %lu, pid: %d\n"</span><span class="token punctuation">,</span><span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//    pthread_exit((void*)99); // 终止线程</span><span class="token comment" spellcheck="true">//    return (void*)10;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    pthread_t tid<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thread_run<span class="token punctuation">,</span> <span class="token string">"thread 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"main thread: %lu, pid: %d\n"</span><span class="token punctuation">,</span><span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pthread_cancel</span><span class="token punctuation">(</span>tid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使线程退出</span>    <span class="token keyword">void</span><span class="token operator">*</span> ret <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>tid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取线程的退出码</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"thread return number: %d\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h6 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h6><blockquote><ul><li>默认情况下，新创建的进程是joinable的，线程退出后，需要对其进行pthread_join操作，否则无法释放资源，从而导致系统资源泄露。</li><li>如果不关心线程的返回值，join是一种负担，这个时候可以告诉操作系统，当线程退出时，自动释放线程资源。</li></ul></blockquote><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">thread_run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">pthread_detach</span><span class="token punctuation">(</span><span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"thread 1: %lu, pid: %d\n"</span><span class="token punctuation">,</span><span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    pthread_t tid<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thread_run<span class="token punctuation">,</span> <span class="token string">"thread 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"main thread: %lu, pid: %d\n"</span><span class="token punctuation">,</span><span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pthread_cancel</span><span class="token punctuation">(</span>tid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token operator">*</span> ret <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>tid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"thread return number: %d\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*  main thread: 140614304589568, pid: 9352  thread 1: 140614296327936, pid: 9352  thread return number: 0*/</span></code></pre><h6 id="多线程抢票"><a href="#多线程抢票" class="headerlink" title="多线程抢票"></a>多线程抢票</h6><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> N 10</span><span class="token keyword">int</span> tickets <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>pthread_mutex_t lock<span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>tickets <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"thread %d get ticket: %d\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">,</span> tickets<span class="token punctuation">)</span><span class="token punctuation">;</span>            tickets<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    pthread_t arr<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">pthread_create</span><span class="token punctuation">(</span>arr<span class="token operator">+</span>i<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> get<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">pthread_join</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h6 id="锁的本质"><a href="#锁的本质" class="headerlink" title="锁的本质"></a>锁的本质</h6><ol><li><p>对临界区进行保护，所有执行的线程都必须遵守这个规则。</p></li><li><p>lock -&gt; 访问临界区 -&gt; unlock。</p></li><li><p>所有线程必须看到同一把锁，所以说：锁本身就是临界资源！锁必须保证自身安全！申请锁的过程，不能有中间状态，lock -&gt; 原子性，unlock -&gt; 原子性。</p></li><li><p>lock -&gt; 访问临界区(花时间) -&gt; unlock，在特定线程/进程拥有锁的时候，期间有新线程/进程过来申请锁，一定申请不到！新线程该如何？阻塞，本质：将进程/线程对应的pcb投入到操作系统的进程等待队列，unlock之后进行进程/线程的唤醒操作！</p></li><li><p>如何理解锁</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> mutex<span class="token punctuation">{</span>    <span class="token keyword">int</span> lock<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0/1</span>    wait_queue <span class="token operator">*</span>head<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre></li><li><p>对锁的相关操作</p><pre class=" language-c"><code class="language-c">pthread_mutex_init：初始化锁pthread_mutex_destroy：释放锁，锁也是资源pthread_mutex_unlock：上锁pthread_mutex_unlock：解锁</code></pre></li><li><p>一次保证只有一个线程进入临界区，访问临界资源，就叫做互斥。</p></li><li><p>加锁为什么一般效率比较低，或者影响效率？所有任务都串行了；线程切换会带来cpu的消耗，上下文切换。</p></li></ol><h6 id="互斥量本质研究"><a href="#互斥量本质研究" class="headerlink" title="互斥量本质研究"></a>互斥量本质研究</h6><blockquote><p>为了实现互斥锁，大多数体系结构都提供了swap或者exchange指令，该指令的作用是把寄存器和内存单元数据交换，由于只有一条指令，保证了原子性。</p></blockquote><pre><code>lock:    move $0, $al    xchgb $al, mutex    if(al &gt; 0)    {        return 0;    }    else    {        挂起等待;    }    goto lock;    unlock:        move $1, mutex        唤醒等待mutex线程        return 0;</code></pre><h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><h6 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h6><blockquote><ul><li>当一个线程互斥的访问某个变量时，它可能发现在其它线程改变状态之前，什么也做不了。</li><li>例如一个线程访问队列时，当它发现队列为空，它只能等待，直到其它线程将数据添加到队列中。这种情况需要用到条件变量，当它发现队列为空时应当去通知生产者往队列里投放数据。</li></ul></blockquote><h6 id="同步概念与竞态条件"><a href="#同步概念与竞态条件" class="headerlink" title="同步概念与竞态条件"></a>同步概念与竞态条件</h6><blockquote><p>同步：在保证数据安全的前提下，让线程能够按照某种特定的顺序访问临界资源，从而有效避免饥饿问题，叫做同步。</p><p>竞态条件：因为时序问题而导致程序异常，称之为竞态条件。</p></blockquote><h6 id="为什么要同步？"><a href="#为什么要同步？" class="headerlink" title="为什么要同步？"></a>为什么要同步？</h6><p>互斥能够保证线程之间访问资源不出错，但是不能保证高效。同步的目的是让多线程同步高效的完成某些任务。</p><ol><li>如果条件不满足，等待，释放锁</li><li>通知机制</li></ol><h6 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h6><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 初始化条件变量</span><span class="token keyword">int</span> <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>restrict cond<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_condattr_t <span class="token operator">*</span>restrict attr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 销毁条件变量</span><span class="token keyword">int</span> <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 等待条件满足</span><span class="token keyword">int</span> <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>restrict cond<span class="token punctuation">,</span> pthread_mutex_t <span class="token operator">*</span>restrict mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 通知cond条件下wait的线程</span><span class="token keyword">int</span> <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="牛刀小试-1"><a href="#牛刀小试-1" class="headerlink" title="牛刀小试"></a>牛刀小试</h6><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>pthread_cond_t cond<span class="token punctuation">;</span>pthread_mutex_t lock<span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">thread_run1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">,</span> <span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 程序执行到这里，使当前线程加入cond结构下的某个成员里，猜测是个数组或者链表</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s, activing....\n"</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">thread_run2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 唤醒cond条件下等待的线程。（个人理解：从cond结构的某个成员里取出一个线程进行唤醒）</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s, signal to thread1 done....\n"</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    pthread_t t1<span class="token punctuation">,</span>t2<span class="token punctuation">;</span>    <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thread_run1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"thread 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thread_run2<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"thread 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h6 id="基于阻塞队列的生产消费模型"><a href="#基于阻塞队列的生产消费模型" class="headerlink" title="基于阻塞队列的生产消费模型"></a>基于阻塞队列的生产消费模型</h6><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">ifndef</span> __BLOCK_QUEUE_H__</span><span class="token macro property">#<span class="token directive keyword">define</span> __BLOCK_QUEUE_H__</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span>template<span class="token operator">&lt;</span>class T<span class="token operator">></span>class BlockQueue<span class="token punctuation">{</span>public<span class="token punctuation">:</span>    <span class="token function">BlockQueue</span><span class="token punctuation">(</span>size_t cap <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token function">_cap</span><span class="token punctuation">(</span>cap<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">,</span> nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c_cond<span class="token punctuation">,</span> nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p_cond<span class="token punctuation">,</span> nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">BlockQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c_cond<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p_cond<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">Put</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>data<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">LockQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">Full</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">WakeUpCon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">ProWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">unLockQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">Get</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>data<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">LockQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">WakeUpPro</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 先唤醒生产者</span>            <span class="token function">ConWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 再休眠消费者</span>        <span class="token punctuation">}</span>        data <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">unLockQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>private<span class="token punctuation">:</span>    <span class="token keyword">void</span> <span class="token function">ProWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p_cond<span class="token punctuation">,</span> <span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*         * 1、为什么要等？条件不满足         * 2、怎么知道条件是否满足？要判断是否满足条件就必须进入临界区，需要持有锁进入         * 3、如果条件不满足就需要阻塞等待，但是不能持有锁去等待！！！(锁被你拿着，其它线程无法获取锁就无法进入临界区，条件就无法发生改变，因此进入死锁状态)，因此wait时必须释放锁。         * 4、因此这个函数需要传入一个lock         *         * 1、在调用该函数时会自动释放锁。         * 2、当该函数返回时，返回到了临界区内，所以该函数会让该线程重新持有该锁。         */</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">ConWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c_cond<span class="token punctuation">,</span> <span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">WakeUpPro</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p_cond<span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"signal productor"</span> <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">WakeUpCon</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c_cond<span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"signal consumer"</span> <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    bool <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    bool <span class="token function">Full</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> _cap<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">LockQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">unLockQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>private<span class="token punctuation">:</span>    pthread_mutex_t lock<span class="token punctuation">;</span>    pthread_cond_t c_cond<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 消费者在该条件下等</span>    pthread_cond_t p_cond<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 生产者在该条件下等</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>queue<span class="token operator">&lt;</span>T<span class="token operator">></span> q<span class="token punctuation">;</span>    size_t _cap<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span></code></pre><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"BlockQueue.hpp"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">Pro_run</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">{</span>    BlockQueue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token punctuation">(</span>BlockQueue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> data <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">110</span><span class="token punctuation">;</span>        q<span class="token operator">-></span><span class="token function">Put</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Pro put: "</span> <span class="token operator">&lt;&lt;</span> data <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">Con_run</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">{</span>    BlockQueue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token punctuation">(</span>BlockQueue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        q<span class="token operator">-></span><span class="token function">Get</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Con get: "</span> <span class="token operator">&lt;&lt;</span> data <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    pthread_t con<span class="token punctuation">,</span>pro<span class="token punctuation">;</span>    BlockQueue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">*</span>bq <span class="token operator">=</span> new BlockQueue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pro<span class="token punctuation">,</span> nullptr<span class="token punctuation">,</span> Pro_run<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>bq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>con<span class="token punctuation">,</span> nullptr<span class="token punctuation">,</span> Con_run<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>bq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>con<span class="token punctuation">,</span> nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>pro<span class="token punctuation">,</span> nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    delete bq<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><h6 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h6><p>信号量本质是一个计数器，描述临界资源有效个数的计数器。（保证每次访问的临界资源不是同一个）</p><p>允许多个线程操作临界区内的多个资源。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>count<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// p() 原子性</span>count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// v() 原子性</span><span class="token comment" spellcheck="true">// 临界资源可以看成是多份的，不冲突的，提高效率</span></code></pre><h6 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h6><p>临界资源可以看成多份且不冲突的，信号量本质就是多份资源的计数器。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> sem<span class="token punctuation">{</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span>    mutex lock<span class="token punctuation">;</span>    wait_queue <span class="token operator">*</span>head<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h6 id="相关函数-1"><a href="#相关函数-1" class="headerlink" title="相关函数"></a>相关函数</h6><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h></span></span><span class="token comment" spellcheck="true">// 初始化信号量</span><span class="token keyword">int</span> <span class="token function">sem_init</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> pshared<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pshared：0表示线程间共享，1表示进程间共享。value：信号量初始值</span><span class="token comment" spellcheck="true">// 销毁信号量</span><span class="token keyword">int</span> <span class="token function">sem_destroy</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 等待信号量，会将信号量的值减1，P()</span><span class="token keyword">int</span> <span class="token function">sem_wait</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 发布信号量，表示资源使用完毕，可以归还了。将信号量值加1，V()</span><span class="token keyword">int</span> <span class="token function">sem_post</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span></code></pre><h6 id="基于环形队列的生产消费者模型"><a href="#基于环形队列的生产消费者模型" class="headerlink" title="基于环形队列的生产消费者模型"></a>基于环形队列的生产消费者模型</h6><p><img src="https://img.3amupupup.online/circle_queue_by_semaphore.png" alt="环形队列"></p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h></span></span>template<span class="token operator">&lt;</span>class T<span class="token operator">></span>class RingQueue<span class="token punctuation">{</span>public<span class="token punctuation">:</span>    <span class="token function">RingQueue</span><span class="token punctuation">(</span>size_t cap <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token function">_v</span><span class="token punctuation">(</span>cap<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        p_index <span class="token operator">=</span> c_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        _max_cap <span class="token operator">=</span> cap<span class="token punctuation">;</span>        <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem_data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem_blank<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> _max_cap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">RingQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">sem_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem_data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem_blank<span class="token punctuation">)</span><span class="token punctuation">;</span>        p_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        c_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">Get</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>out<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">P</span><span class="token punctuation">(</span>sem_data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 取数据时，要将数据对应的信号量减1</span>        out <span class="token operator">=</span> _v<span class="token punctuation">[</span>c_index<span class="token punctuation">]</span><span class="token punctuation">;</span>        c_index<span class="token operator">++</span><span class="token punctuation">;</span>        c_index <span class="token operator">%</span><span class="token operator">=</span> _max_cap<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 数据减1时对应的装数据的格子增1</span>        <span class="token function">V</span><span class="token punctuation">(</span>sem_blank<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">Put</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>in<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">P</span><span class="token punctuation">(</span>sem_blank<span class="token punctuation">)</span><span class="token punctuation">;</span>        _v<span class="token punctuation">[</span>p_index<span class="token punctuation">]</span> <span class="token operator">=</span> in<span class="token punctuation">;</span>        p_index<span class="token operator">++</span><span class="token punctuation">;</span>        p_index <span class="token operator">%</span><span class="token operator">=</span> _max_cap<span class="token punctuation">;</span>        <span class="token function">V</span><span class="token punctuation">(</span>sem_data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>private<span class="token punctuation">:</span>    <span class="token keyword">void</span> <span class="token function">P</span><span class="token punctuation">(</span>sem_t <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">V</span><span class="token punctuation">(</span>sem_t <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>private<span class="token punctuation">:</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>T<span class="token operator">></span> _v<span class="token punctuation">;</span>    size_t _max_cap<span class="token punctuation">;</span>    sem_t sem_data<span class="token punctuation">;</span>    sem_t sem_blank<span class="token punctuation">;</span>    size_t p_index<span class="token punctuation">;</span>    size_t c_index<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"RingQueue.hpp"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">Productor</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">{</span>    RingQueue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token punctuation">(</span>RingQueue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> data <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">100</span><span class="token punctuation">;</span>        q<span class="token operator">-></span><span class="token function">Put</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Productor Put data: "</span> <span class="token operator">&lt;&lt;</span> data <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">Consumer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">{</span>    RingQueue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token punctuation">(</span>RingQueue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> data<span class="token punctuation">;</span>        q<span class="token operator">-></span><span class="token function">Get</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Consumer Get data: "</span> <span class="token operator">&lt;&lt;</span> data <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    RingQueue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">*</span>rq <span class="token operator">=</span> new RingQueue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">;</span>    pthread_t pro<span class="token punctuation">,</span> con<span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pro<span class="token punctuation">,</span> nullptr<span class="token punctuation">,</span> Productor<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>con<span class="token punctuation">,</span> nullptr<span class="token punctuation">,</span> Consumer<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>pro<span class="token punctuation">,</span> nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>con<span class="token punctuation">,</span> nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <queue>#include <pthread.h>#include <cmath>#include <unistd.h>class Task{public:    int base;public:    Task() = default;    Task(int num): base(num){}    void Run()    {        std::cout << "thread id[" << pthread_self() <<"]" << "thread run done...... : base# " << base << " pow is # " << pow(base, 2)  << std::endl;        usleep(100);    }};class ThreadPool{private:    pthread_mutex_t lock;    pthread_cond_t cond; // 只能让消费者等，如果作为服务器时，生产者等待那么就无法接收外部请求了    std::queue<Task> q;    size_t max_num;public:    void LockQueue()    {        pthread_mutex_lock(&lock);    }    void UnLockQueue()    {        pthread_mutex_unlock(&lock);    }    void ThreadWait()    {        pthread_cond_wait(&cond, &lock);    }    void WakeUpThread()    {        pthread_cond_signal(&cond);    }    bool IsEmpty()    {        return q.size() == 0;    }    // threadpool    void Get(Task &out)    {        out = q.front();        q.pop();    }    // server    void Put(Task &in)    {        LockQueue();        q.push(in);        UnLockQueue();        WakeUpThread(); // 生产者塞任务进入队列之后，需要通知消费者。    }public:    ThreadPool(int num = 5): max_num(num)    {}    static void* Routine(void *arg)    {        ThreadPool *this_p = (ThreadPool*)arg;        while(true) // 这里是死循环，保证线程不会退出，一直从队列中取任务，队列空时又进入cond的休眠队列，等待被唤醒        {            this_p->LockQueue();            while(this_p->IsEmpty())            {                this_p->ThreadWait();            }            Task t;            this_p->Get(t);            this_p->UnLockQueue();            t.Run();        }    }    void ThreadPoolInit()    {        pthread_cond_init(&cond, nullptr);        pthread_mutex_init(&lock, nullptr);        pthread_t t;        for(size_t i = 0; i < max_num; i++)        {            pthread_create(&t, nullptr, Routine, this);      /*          在初始化阶段，初始化线程，线程开始运行之后发现task队列为空，则会在cond条件变量下进行休眠。          关于条件变量cond：这个结构中可能维护着一个队列，一旦线程调用pthread_cond_wait，那么这个线程就会          加入cond结构下的休眠队列，当生产者执行pthread_cond_signal时，休眠线程从休眠队列中取出重新加入cpu的运行队列。      */        }    }    ~ThreadPool()    {        pthread_cond_destroy(&cond);        pthread_mutex_destroy(&lock);    }};</code></pre><p>线程池存在的价值：</p><ul><li>有任务，立马有线程进行服务，省掉了线程创建的时间。</li><li>有效防止，server中线程过多，导致系统过载问题。</li></ul><p>线程池 VS 进程池：</p><ul><li>线程池占用资源更少，但是健壮性不强。</li><li>进程池占用资源更多，但是健壮性强。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CppPrimer</title>
      <link href="2021/04/13/CppPrimer/"/>
      <url>2021/04/13/CppPrimer/</url>
      
        <content type="html"><![CDATA[<h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><h4 id="1-5-类简介"><a href="#1-5-类简介" class="headerlink" title="1.5 类简介"></a>1.5 类简介</h4><h5 id="1-5-1-Sales-item类"><a href="#1-5-1-Sales-item类" class="headerlink" title="1.5.1 Sales_item类"></a>1.5.1 Sales_item类</h5><p>c++中通过定义类来定义数据结构。一个类定义了一个类型，以及与其相关联的操作。</p><h5 id="1-5-2-成员函数"><a href="#1-5-2-成员函数" class="headerlink" title="1.5.2 成员函数"></a>1.5.2 成员函数</h5><p>成员函数时定义为类一部分的函数，有时也被称为方法。</p><h3 id="第三章-字符串、向量和数组"><a href="#第三章-字符串、向量和数组" class="headerlink" title="第三章 字符串、向量和数组"></a>第三章 字符串、向量和数组</h3><h4 id="3-2-标准库类型-string"><a href="#3-2-标准库类型-string" class="headerlink" title="3.2 标准库类型 string"></a>3.2 标准库类型 string</h4><h5 id="3-2-1-定义和初始化-string-对象"><a href="#3-2-1-定义和初始化-string-对象" class="headerlink" title="3.2.1 定义和初始化 string 对象"></a>3.2.1 定义和初始化 string 对象</h5><pre class=" language-c"><code class="language-c">string s1<span class="token punctuation">;</span>string s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>string s3 <span class="token operator">=</span> <span class="token string">"heya"</span><span class="token punctuation">;</span>string <span class="token function">s4</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h6><p>如果使用等号初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。</p><p>与之相反，如果不使用等号，则执行的是直接初始化。</p><h3 id="第四章-表达式"><a href="#第四章-表达式" class="headerlink" title="第四章 表达式"></a>第四章 表达式</h3><h4 id="4-11-类型转换"><a href="#4-11-类型转换" class="headerlink" title="4.11 类型转换"></a>4.11 类型转换</h4><h6 id="何时发生类型转换"><a href="#何时发生类型转换" class="headerlink" title="何时发生类型转换"></a>何时发生类型转换</h6><ol><li>在大多表达式中，比int类型小的整形值会提升为较大的整数类型。</li><li>在条件中，非布尔值转换成布尔类型。</li><li>初始化过程中，初始值转换成变量类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。</li><li>如果算数运算或关系运算的运算对象有多种类型，需要转换成同一种类型。</li><li>函数调用时会发生类型转换。</li></ol><h5 id="4-11-1-算术转换"><a href="#4-11-1-算术转换" class="headerlink" title="4.11.1 算术转换"></a>4.11.1 算术转换</h5><h6 id="算术转换"><a href="#算术转换" class="headerlink" title="算术转换"></a>算术转换</h6><p>算术转换的含义是把一种算术类型转换成另一种算术类型。</p><p>算术转换的规则定义了一套类型转换的层次，其中运算符的运算对象将转换成最宽的类型。例如：</p><p>如果一个运算对象是long double，那么不论另外一个运算对象的类型是什么都会转换成long double</p><h6 id="整形提升"><a href="#整形提升" class="headerlink" title="整形提升"></a>整形提升</h6><p>负责把小整数类型转换成较大的整数类型。(前提是转换后的类型要能容纳原类型所有可能的值)</p><h5 id="4-11-3-显示类型转换"><a href="#4-11-3-显示类型转换" class="headerlink" title="4.11.3 显示类型转换"></a>4.11.3 显示类型转换</h5><h6 id="命名的强制类型转换"><a href="#命名的强制类型转换" class="headerlink" title="命名的强制类型转换"></a>命名的强制类型转换</h6><p>cast-name&lt;type&gt; (expression)，type是转换的目标类型，expression是要转换的值。如果type是引用类型，则结果是左值。cast-name是static_cast、</p><p>dynamic_cast、const_cast和reinterpret_cast中的一种。dynamic_cast支持运行时类型识别。</p><h6 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h6><p>任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> ret <span class="token operator">=</span> static_cast<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">/</span> b<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> ret <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// output: 3.33333</span></code></pre><p>当需要把一个较大的算数类型赋值给较小的类型时，static_cast非常有用。此时强制类型转换的意思是告诉编译器和读者：我们知道且不在乎潜在的精度损失。</p><p>static_cast对于编译器无法自动执行的类型转换也非常有用。例如，可以使用static_cast找回存在于void*指针中的值。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 任何非常量对象的地址都能存入void*</span>    <span class="token keyword">double</span> <span class="token operator">*</span>dp <span class="token operator">=</span> static_cast<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将void*转换回初始的指针类型</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h6 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h6><blockquote><p>顶层const表示指针本身是个常量，底层const表示指针指向的对象是一个常量。</p></blockquote><p>const_cast 只能改变运算对象的底层const：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>cp  <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> const_cast<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果不使用const_cast去掉const性质，那么*cp是无法修改的。</span>    <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"*cp = "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>cp <span class="token operator">&lt;&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"*p = "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pc<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> const_cast<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>将常量对象转换成非常量对象的行为一般称为–去掉const性质。一旦抹去对象的const性质，编译器不再阻止对该对象进行写操作。如果一个对象本身不是一个常量，使用强制类型转换获得写权限是合法行为。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cp<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> const_cast<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不能转换掉const性质，const_cast只能改变运算对象的底层const</span>static_cast<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span>const_cast<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 错误，const_cast只能改变常量属性</span></code></pre><h6 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h6><p>reinterpret_cast 通常为运算对象的位模式提供较低层次上的重新解释。</p><h3 id="第六章-函数"><a href="#第六章-函数" class="headerlink" title="第六章 函数"></a>第六章 函数</h3><h4 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h4><p>实参是形参的初始值。实参的类型必须与对应的形参存在对应关系。</p><h5 id="6-1-1-局部对象"><a href="#6-1-1-局部对象" class="headerlink" title="6.1.1 局部对象"></a>6.1.1 局部对象</h5><p>名字有作用域，对象有生命周期。</p><ul><li>名字的作用域是程序文本的一部分，名字在其中可见。</li><li>对象的声明周期是程序执行过程中该对象存在的一段时间。</li></ul><p>函数体是一个语句块。块构成一个新的作用域，可以在其中定义变量。形参和函数体内部定义的变量统称为局部变量。它们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量会隐藏在外层作用域中同名的其它所有声明。</p><h6 id="自动对象"><a href="#自动对象" class="headerlink" title="自动对象"></a>自动对象</h6><p>只存在于块执行期间的对象称为自动对象。(函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它)。形参是自动对象。</p><h6 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h6><p>在程序执行路径第一次经过对象定义语句时初始化，直到程序终止才被销毁。</p><h4 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h4><h5 id="6-2-6-含有可变形参的函数"><a href="#6-2-6-含有可变形参的函数" class="headerlink" title="6.2.6 含有可变形参的函数"></a>6.2.6 含有可变形参的函数</h5><p>为了编写能处理不同数量实参的函数，c++11新标准提供了两种主要方法：</p><ol><li><p>如果所有实参类型相同，可以传递一个名为initializer_list的标准库类型。initializer_list对象中的元素永远是常量值，无法改变其中的元素的值。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;initializer_list></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> il<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>iterator it <span class="token operator">=</span> il<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> il<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> il <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">test</span><span class="token punctuation">(</span>il<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><ol start="2"><li>如果实参的类型不同，可以编写一种特殊的函数，也就是可变参数模板。</li></ol><h6 id=""><a href="#" class="headerlink" title=""></a></h6><h4 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h4><h6 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h6><p>如果同一作用域内的几个函数名字相同但形参列表不同，称之为函数重载。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>beg<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>对于重载函数来说，它们应该在形参数量或形参类型上有所不同。</p><p>不允许两个函数除了返回类型外其它所有的要素都相同，也就是说返回值类型不能作为函数重载的要素。</p><h6 id="重载和const形参"><a href="#重载和const形参" class="headerlink" title="重载和const形参"></a>重载和const形参</h6><p>一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;initializer_list></span></span>using namespace std<span class="token punctuation">;</span>class C1<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*// 重复定义,顶层const无法区分void Print(C1* c1){    cout &lt;&lt; "c1" &lt;&lt; endl;}void Print(C1* const c2) // 表示形参指针变量c2是个常量，顶层const{    cout &lt;&lt; "c2" &lt;&lt; endl;}*/</span><span class="token keyword">void</span> <span class="token function">echo</span><span class="token punctuation">(</span>C1<span class="token operator">&amp;</span> c1<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ref c1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">echo</span><span class="token punctuation">(</span><span class="token keyword">const</span> C1<span class="token operator">&amp;</span> c2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// const修饰c2这个引用指向的对象是个常量，因此是底层const</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"c2"</span> <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">echo</span><span class="token punctuation">(</span>C1<span class="token operator">*</span> c3<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"c3"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">echo</span><span class="token punctuation">(</span><span class="token keyword">const</span> C1<span class="token operator">*</span> c4<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// const修饰的是C1对象</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"c4"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*void echo(C1* const c5) // 此时const修饰的是c5这个指针变量本身而非其指向的对象，是顶层const{    ;}*/</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h6 id="const-cast和重载"><a href="#const-cast和重载" class="headerlink" title="const_cast和重载"></a>const_cast和重载</h6><pre class=" language-c"><code class="language-c"><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token function">shorterString</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1 <span class="token punctuation">:</span> s2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 这种情况下，返回值也必须是const 引用类型</span><span class="token comment" spellcheck="true">/*     当需要得到一个普通的引用时，借助const_cast。(这里的两个shorterString函数是有发生重载的)    先将它的实参强制类型转换成对应的const的引用，然后调用shorterString函数的const版本。    const版本返回对const string的引用，再将这个引用转换成一个普通的string&amp;，然后返回。*/</span>string <span class="token operator">&amp;</span><span class="token function">shorterString</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> string <span class="token operator">&amp;</span>r <span class="token operator">=</span> <span class="token function">shorterString</span><span class="token punctuation">(</span>const_cast<span class="token operator">&lt;</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">,</span> const_cast<span class="token operator">&lt;</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span>  const_cast<span class="token operator">&lt;</span>string<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5 特殊用途语言特性"></a>6.5 特殊用途语言特性</h4><h5 id="6-5-1-默认实参"><a href="#6-5-1-默认实参" class="headerlink" title="6.5.1 默认实参"></a>6.5.1 默认实参</h5><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="6-5-2-内联函数和constexpr函数"><a href="#6-5-2-内联函数和constexpr函数" class="headerlink" title="6.5.2 内联函数和constexpr函数"></a>6.5.2 内联函数和constexpr函数</h5><p>把一些规模较小的操作定义成函数有很多好处，包括：</p><ul><li>容易阅读和理解</li><li>函数可以确保行为的统一</li><li>容易修改</li><li>复用</li></ul><p>但是也存在一个潜在的缺点，一次函数调用包含这一系列工作：</p><ol><li>调用前要先保存寄存器，并在返回时恢复；</li><li>可能需要拷贝实参；</li><li>程序转向一个新的位置继续执行。</li></ol><h6 id="内联函数可避免函数调用的开销"><a href="#内联函数可避免函数调用的开销" class="headerlink" title="内联函数可避免函数调用的开销"></a>内联函数可避免函数调用的开销</h6><p>将函数指定为内联函数，通常就是将它在每个调用点上“内联地”展开。例如 6.4 中的shorterString函数：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 调用</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">shorterString</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 将在编译过程中展开成类似于下面的形式</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1 <span class="token punctuation">:</span> s2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 在函数前加上inline关键字将其声明成内联函数，实际上不一定需要加inline，编译器会帮我们去优化的。</span></code></pre><h6 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h6><p>constexpr函数(constexpr function)是指 能用于常量表达式的函数。定义constexpr函数的方法与其它函数类似，需要遵循以下约定：</p><ol><li><p>函数的返回类型及所有形参的类型都得是字面值类型</p></li><li><p>函数体中必须有且只有一条return语句</p><pre class=" language-c"><code class="language-c">constexpr <span class="token keyword">int</span> <span class="token function">new_sz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>constexpr <span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token function">new_sz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*    执行该初始化任务时，编译器把对constexpr函数的调用替换成其结果值。    为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。*/</span><span class="token comment" spellcheck="true">/*    constexpr函数体内也可以包含其它语句，只要这些语句不执行任何操作就行。例如，constexpr函数中可以有空语句、    类型别名以及using声明。*/</span>constexpr size_t <span class="token function">scale</span><span class="token punctuation">(</span>size_t cnt<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">new_sz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> cnt<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确，scale的实参是常量表达式，所以它的返回值也是常量表达式。</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span>；<span class="token keyword">int</span> a2<span class="token punctuation">[</span><span class="token function">scale</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 错误，数组的大小不能是变量，必须是常量。因为scale的实参是变量，所以它的返回值也是一个变量</span></code></pre></li></ol><h4 id="6-6-函数匹配"><a href="#6-6-函数匹配" class="headerlink" title="6.6 函数匹配"></a>6.6 函数匹配</h4><h6 id="确定候选函数和可行函数"><a href="#确定候选函数和可行函数" class="headerlink" title="确定候选函数和可行函数"></a>确定候选函数和可行函数</h6><p>第一步是确定本次调用对应的重载函数集，集合中的函数称为候选函数。候选函数具备两个特征：① 与被调用的函数同名，② 其生命在调用点可见</p><p>第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为可行函数。可行函数具备两个特征：① 其形参数量与本次调用提供的实参数量相等，② 每个实参的类型与对应的形参类型相同或者能转换成形参的类型。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">5.6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*     调用 void f(double, double);     可行函数：        f(int) // double能转换成int        f(double, double) // 第二个形参提供了默认值    如果没有找到可行函数，编译器将报告无匹配函数的错误。*/</span></code></pre><h6 id="寻找最佳匹配-如果有的话"><a href="#寻找最佳匹配-如果有的话" class="headerlink" title="寻找最佳匹配(如果有的话)"></a>寻找最佳匹配(如果有的话)</h6><p>第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。实参类型与形参类型越接近，匹配的越好。精确匹配比需要类型转换的匹配更好。所以最终调用的是 f(double, double = 3.14)。</p><h6 id="含有多个形参的函数匹配"><a href="#含有多个形参的函数匹配" class="headerlink" title="含有多个形参的函数匹配"></a>含有多个形参的函数匹配</h6><p>例如调用：f(42, 2.56);</p><p>先确定可行函数：f(int, int)，f(double, double)。</p><p>接下来一次检查每个实参以确定哪个函数是最佳匹配。如果有且只有一个函数满足下列条件，则匹配成功：</p><ul><li>该函数每个实参的匹配都不劣于其它可行函数需要的匹配。</li><li>至少有一个实参的匹配优于其它可行函数提供的匹配。</li></ul><p>在上面的调用中，如果只考虑第一个实参，那么f(int, int) 能精确匹配；要想匹配第二个函数，int类型的实参必须转换成double类型，但是需要内置类型转换的匹配劣于精确匹配，因此就第一个实参来说，f(int, int) 比 f(double, double)更好。</p><p>接着考虑第二个实参2.56，同理，f(double, double)更好。</p><p>编译器最终会因为这个调用具有二义性而拒绝其请求：因为每一个可行函数各自在一个实参上实现了更好的匹配，从整体上无法判断孰优孰劣。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(int)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(int, int)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(double, double = 3.14)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(int, int, int)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(double, double, double)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">5.6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 报错</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">4.4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 报错</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="6-6-1"><a href="#6-6-1" class="headerlink" title="6.6.1"></a>6.6.1</h5><p>为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级：</p><ol><li>精确匹配<ul><li>实参类型和形参类型相同</li><li>实参从数组类型或函数类型转换成对应的指针类型</li><li>向实参添加顶层const或者从实参中删除顶层const</li></ul></li><li>通过const转换实现的函数匹配</li><li>通过类型提升实现的匹配</li><li>通过算术类型转换或指针转换实现的匹配</li><li>通过类类型转换实现的匹配</li></ol><h6 id="需要类型提升和算术类型转换的匹配"><a href="#需要类型提升和算术类型转换的匹配" class="headerlink" title="需要类型提升和算术类型转换的匹配"></a>需要类型提升和算术类型转换的匹配</h6><p>小整形一般都会提升到int类型或者更大的整形类型。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ff</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">ff</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ff</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// char提升成int，调用f(int)</span></code></pre><p>所有算术类型转换的级别都一样。例如，从int想unsigned int的转换并不比int向double的转换级别高。例如：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">manip</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">manip</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">manip</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 错误：二义性调用</span></code></pre><h6 id="函数匹配和const实参"><a href="#函数匹配和const实参" class="headerlink" title="函数匹配和const实参"></a>函数匹配和const实参</h6><h4 id="6-7-函数指针"><a href="#6-7-函数指针" class="headerlink" title="6.7 函数指针"></a>6.7 函数指针</h4><p>函数指针指向的是函数而非对象。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。</p><pre class=" language-c"><code class="language-c">bool <span class="token function">lengthCompare</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">bool</span> <span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="第七章-类"><a href="#第七章-类" class="headerlink" title="第七章 类"></a>第七章 类</h3><p>类的基本思想是数据抽象和封装(实现了类的接口和实现的分离，隐藏实现细节)。数据抽象是一种依赖于接口和实现的分离编程技术。</p><h4 id="7-1-定义抽象数据类型"><a href="#7-1-定义抽象数据类型" class="headerlink" title="7.1 定义抽象数据类型"></a>7.1 定义抽象数据类型</h4><h5 id="7-1-4-构造函数"><a href="#7-1-4-构造函数" class="headerlink" title="7.1.4 构造函数"></a>7.1.4 构造函数</h5><p>每个类都定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数控制其对象的初始化过程，这些函数叫构造函数。构造函数的任务是初始化类对象的数据成员，无论何时只要类被初始化，就会调用构造函数。</p><p>构造函数的名字与类名相同，无返回值。</p><p>构造函数不能声明成const，当创建一个类的const对象时，直到构造函数完成初始化完成，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。</p><p>如果类没有显示的定义构造函数，那么编译器就会为我们隐式的定义一个默认构造函数。</p><h6 id="某些类不能依赖于合成的默认构造函数"><a href="#某些类不能依赖于合成的默认构造函数" class="headerlink" title="某些类不能依赖于合成的默认构造函数"></a>某些类不能依赖于合成的默认构造函数</h6><ol><li><p>只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。</p><p>编译器只有在发现类不包含任何构造函数的情况下才会自动生成一个构造函数。一旦我们自己定义了其它的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认的构造函数。（依据：如果一个类在某种情况下需要控制对象初始化，那么该类很可能在所有情况下都需要控制。）</p></li><li><p>含有内置内省或者复合类型成员的类应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数。否则，在用户创建类的对象时就可能得到未定义的值。</p></li><li><p>有些时候编译器不能为类合成默认的构造函数。</p><p>例如，如果一个类中包含一个其它类类型成员且这个成员没有默认的构造函数，那么编译器将无法初始化该成员。对于这样的类必须自定义默认构造函数，否则该类将没有默认的构造函数。</p></li></ol><h6 id="default"><a href="#default" class="headerlink" title="=default"></a>=default</h6><p>当定义其它形式的构造函数时，也需要默认的构造函数，c++11中可以使用=default来要求编译器生成默认构造函数</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span>class Person<span class="token punctuation">{</span>public<span class="token punctuation">:</span>    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        _age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>private<span class="token punctuation">:</span>    <span class="token keyword">int</span> _age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Person p<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="7-2-访问控制与封装"><a href="#7-2-访问控制与封装" class="headerlink" title="7.2 访问控制与封装"></a>7.2 访问控制与封装</h4><p>定义在public说明符之后的成员在整个程序内可以被访问，public成员定义类的接口。</p><p>定义在private说明符之后的成员可以被类的成员函数访问。</p><h6 id="使用struct-或-class关键字"><a href="#使用struct-或-class关键字" class="headerlink" title="使用struct 或 class关键字"></a>使用struct 或 class关键字</h6><p>class中，默认的权限是私有的。struct中，默认的权限是public。</p><h5 id="7-2-1-友元"><a href="#7-2-1-友元" class="headerlink" title="7.2.1 友元"></a>7.2.1 友元</h5><p>类可以允许其它类或者函数访问它的非公有成员，方法是令其它类或者函数成为它的友元。</p><h3 id="第十章-泛型算法"><a href="#第十章-泛型算法" class="headerlink" title="第十章 泛型算法"></a>第十章 泛型算法</h3>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号</title>
      <link href="2021/04/12/signal/"/>
      <url>2021/04/12/signal/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img.3amupupup.online/pending-block-handler.png" alt="signal"></p><blockquote><ul><li>每个信号都有两个标志位表示阻塞(block)和未决(pending)，还有一个函数指针表示处理动作。信号产生时，内核在该进程控制块中设置该信号的未决标志，在上图例子中SIGHUP信号未阻塞也未产生过，当它递达时执行默认处理动作。</li><li>SIGINT信号产生过，但正在被阻塞，所以暂时不能递达。虽然它的处理动作是忽略，但在没有解除阻塞之前不能忽略这个信号，因为进程有机会改变处理动作之后在接触阻塞。</li><li>SIGQUIT信号未产生过，一旦产生SIGQUIT信号将被阻塞，它的处理动作是用户自定义函数 sighandler。如果在进程接触某信号的阻塞之前这种信号产生过多次，将如何处理？linux处理方式：常规信号在递达之前多次只计一次。而实时信号在递达之前产生多次可以依次放在一个队列里。</li></ul></blockquote><h5 id="信号保存：pending位图"><a href="#信号保存：pending位图" class="headerlink" title="信号保存：pending位图"></a>信号保存：pending位图</h5><p>01000000 00000000 00000000 00000000：信号2</p><p>比特位的位置：代表是哪个信号</p><p>比特为的内容：代表是否收到这个信号。(0无，1有)</p><h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> task_struct<span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> sigbitmap <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>操作系统如何发送信号？ 找到进程的pcb，将sigbitmap第八个位置的比特位修改为1。(操作系统给进程“发送”信号，操作系统给进程写信号)</p><h6 id="信号相关概念"><a href="#信号相关概念" class="headerlink" title="信号相关概念"></a>信号相关概念</h6><ol><li>实际执行信号的处理动作称为信号递达(Delivery)。</li><li>信号从产生到递达之间的状态，称为信号未决(Pending)。</li><li>进程可以选择阻塞(Block)某个信号。</li><li>被阻塞的信号将保持在未决状态，直到进程解除对此信号的阻塞，才执行递达动作。</li><li>忽略和阻塞是不同的，只要信号被阻塞就不会递达，而忽略是在递达之后可选的一种处理动作。</li></ol><h5 id="block位图"><a href="#block位图" class="headerlink" title="block位图"></a>block位图</h5><p>记录信号被屏蔽/阻塞信息：</p><p>01000000 00000000 00000000 00000000</p><p>比特位的位置，代表是哪个信号？(是谁)</p><p>比特为的内容，代表是否被屏蔽。</p><h5 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h5><p>是一个函数指针数组，信号编号是数组的下标。</p><pre class=" language-c"><code class="language-c">sighandler_t <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> sighandler_t handler<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>因此可以得知signal函数的作用：修改收到一个信号时的处理动作。(修改递达行为)</p><h5 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h5><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sigemptyset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化set所指向的信号集，使信号对应的所有比特位为0。</span><span class="token keyword">int</span> <span class="token function">sigfillset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化set所指向的信号集，使信号对应的所有比特位都为1。</span><span class="token keyword">int</span> <span class="token function">sigaddset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设置set对应的信号集，将signum信号对应比特位置为1。</span><span class="token keyword">int</span> <span class="token function">sigdelset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设置set对应的信号集，将signum信号对应的比特位置为0。</span><span class="token keyword">int</span> <span class="token function">sigismember</span><span class="token punctuation">(</span><span class="token keyword">const</span> sigset_t <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 判断信号signum是否存在于信号集set中，也就是判断对应的比特位是否为1。</span><span class="token keyword">int</span> <span class="token function">sigprocmask</span><span class="token punctuation">(</span><span class="token keyword">int</span> how<span class="token punctuation">,</span> <span class="token keyword">const</span> sigset_t <span class="token operator">*</span>restrict set<span class="token punctuation">,</span> igset_t <span class="token operator">*</span>restrict oset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*    读取或修改进程的信号屏蔽字(阻塞信号集)，成功返回0，出错返回-1。    如果oset时非空指针，则读取进程的当前信号屏蔽字通过oset参数传出。    如果set时非空指针，则根据how参数修改进程的信号屏蔽字。    如果set和oset都不为空，则先将未修改前的信号屏蔽字保存到oset中，再根据how参数修改信号屏蔽字。    how:         ① SIG_BLOCK，set包含了希望添加到当前信号屏蔽字的信号。mask|set        ② SIG_UNBLOCK，set包含了希望从当前信号屏蔽字中解除阻塞的信号。mask&amp;~set，例：set: 10001 => ~set: 01110 => mask&amp;~set: 比特位同时为1才会保存下来        ③ SIG_SETMASK，设置当前信号屏蔽字为set指向的的值。mast=set*/</span></code></pre><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">void</span> <span class="token function">show_pending</span><span class="token punctuation">(</span>sigset_t pending<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">31</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sigismember</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pending<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1~31信号，挨个判断是否在pending信号集中并打印显示</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"get a signal: %d\n"</span><span class="token punctuation">,</span>signum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    sigset_t pending<span class="token punctuation">;</span>    sigset_t block<span class="token punctuation">,</span> oblock<span class="token punctuation">;</span>    <span class="token function">sigisemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>block<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 先对block进行初始化，设置全0，这里修改的只是参数block，而不是修改的当前进程的信号屏蔽字</span>    <span class="token function">sigisemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pending<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 同上，初始化pending，设置全0</span>    <span class="token function">sigaddset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>block<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将2号信号添加进block</span>    <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>block<span class="token punctuation">,</span> <span class="token operator">&amp;</span>oblock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 修改当前进程的信号屏蔽字，等于block。也就是使当前进程屏蔽2号信号</span>      <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pending<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sigpending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pending<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取当前进程的pending信号集</span>        <span class="token function">show_pending</span><span class="token punctuation">(</span>pending<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">++</span> <span class="token operator">==</span> <span class="token number">10</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"recover sig mask.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>oblock<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// output</span><span class="token comment" spellcheck="true">/*  0000000000000000000000000000000  0000000000000000000000000000000  ^C0100000000000000000000000000000 // 键盘键入 ctrl+c，收到2号信号指挥pending上的第二个比特位被设置为1，代表收到了2号信号，但是由于我们屏蔽了2号信号，所以进程不会结束而是继续打印  0100000000000000000000000000000  0100000000000000000000000000000  0100000000000000000000000000000  0100000000000000000000000000000  0100000000000000000000000000000  0100000000000000000000000000000  0100000000000000000000000000000  0100000000000000000000000000000  recover sig mask.  get a signal: 2  0000000000000000000000000000000  0000000000000000000000000000000  0000000000000000000000000000000  0000000000000000000000000000000  0000000000000000000000000000000  0000000000000000000000000000000  ^Cget a signal: 2  0000000000000000000000000000000  ^\[1]    8302 quit       ./test // 键盘键入 ctrl + \ 退出*/</span></code></pre><h5 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h5><p>信号检测、处理、递达发生在进程从内核态切换到用户态的时候。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">void</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"get a signal: %d\n"</span><span class="token punctuation">,</span>signum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> sigaction act<span class="token punctuation">,</span> oact<span class="token punctuation">;</span>    act<span class="token punctuation">.</span>sa_hander <span class="token operator">=</span> handler<span class="token punctuation">;</span>    act<span class="token punctuation">.</span>sa_flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>act<span class="token punctuation">.</span>sa_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sigaction</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>act<span class="token punctuation">,</span> <span class="token operator">&amp;</span>oact<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><p>volatile作用：保持内存的可见性，告知编译器，被该关键字修饰的变量，不允许被优化，对该变量的任何操作，都必须在真实的内存中操作。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token comment" spellcheck="true">// int quit = 0;</span><span class="token keyword">volatile</span> <span class="token keyword">int</span> quit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 被volatile修饰的变量是不可被覆盖的，在任何执行流中读取该数据必须从该数据的真实存储位置读取，不能从任何缓存中读取。</span><span class="token keyword">void</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">{</span>    quit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">signal</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>quit<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果声明为int类型，quit会被优化为寄存器变量，while循环一直检测的是寄存器中的值，所以进程收到2号信号之后，修改的是内存上的值，寄存器上的值未被修改，所以进程没有退出</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"process exit\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="SIGCHILD"><a href="#SIGCHILD" class="headerlink" title="SIGCHILD"></a>SIGCHILD</h5><p>wait、waitpid函数清理僵尸进程，父进程可以阻塞或者非阻塞地等待子进程结束。阻塞方式会导致父进程不能处理其它任务。非阻塞方式：父进程在处理其它任务时还得时不时轮询一下，程序实现复杂。</p><p>子进程在结束时会给父进程发送SIGCHILD信号，该信号的默认处理动作是忽略，父进程可以自定义SIGCHILD信号的处理函数，这样父进程只需要关注自己的工作，不必关心子进程，子进程终止时会通知父进程，父进程在处理函数中调用wait回收即可。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token keyword">void</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"parent recived signal: %d\n"</span><span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">signal</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i am child process\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child process exit\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i am parent process\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*output:      ☁  signal [master] ⚡  ./run      i am parent process      i am child process      i am parent process      i am child process      i am parent process      i am child process      i am parent process      i am child process      i am parent process      i am child process      i am parent process      child process exit      parent recived signal: 17      i am parent process      i am parent process      i am parent process      i am parent process      ^C */</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx散列表</title>
      <link href="2021/03/23/ngx_hash/"/>
      <url>2021/03/23/ngx_hash/</url>
      
        <content type="html"><![CDATA[<h4 id="nginx数据类型：散列表"><a href="#nginx数据类型：散列表" class="headerlink" title="nginx数据类型：散列表"></a>nginx数据类型：散列表</h4><p><img src="https://img.3amupupup.online/ngx_hash_2.png" alt="散列表"></p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 存储key和value的元素</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span>             <span class="token operator">*</span>value<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 指向value的指针</span>    u_short           len<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// key的长度</span>    u_char            name<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// key长度是可变的，这里使用了c语言的柔性数组</span><span class="token punctuation">}</span> ngx_hash_elt_t<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// hash表结构</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    ngx_hash_elt_t  <span class="token operator">*</span><span class="token operator">*</span>buckets<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// hash表的桶指针地址值</span>    ngx_uint_t        size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// hash表的t桶个数</span><span class="token punctuation">}</span> ngx_hash_t<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// hash表初始化时所需的key的结构</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    ngx_str_t         key<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// key</span>    ngx_uint_t        key_hash<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// key经过hash函数计算得到的值</span>    <span class="token keyword">void</span>             <span class="token operator">*</span>value<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// value</span><span class="token punctuation">}</span> ngx_hash_key_t<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化结构，通过这个结构里的参数进行初始化</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    ngx_hash_t       <span class="token operator">*</span>hash<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指向hash表的指针</span>    ngx_hash_key_pt   key<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// hash函数</span>    ngx_uint_t        max_size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 最多能有多少个桶</span>    ngx_uint_t        bucket_size<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 桶的大小(桶的内存空间size，单位是字节)</span>    <span class="token keyword">char</span>             <span class="token operator">*</span>name<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// hash表名称</span>    ngx_pool_t       <span class="token operator">*</span>pool<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 内存池</span>    ngx_pool_t       <span class="token operator">*</span>temp_pool<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 临时内存池</span><span class="token punctuation">}</span> ngx_hash_init_t<span class="token punctuation">;</span></code></pre><h5 id="散列表提供的接口"><a href="#散列表提供的接口" class="headerlink" title="散列表提供的接口"></a>散列表提供的接口</h5><pre class=" language-c"><code class="language-c">ngx_int_t <span class="token function">ngx_hash_init</span><span class="token punctuation">(</span>ngx_hash_init_t <span class="token operator">*</span>hinit<span class="token punctuation">,</span> ngx_hash_key_t <span class="token operator">*</span>names<span class="token punctuation">,</span> ngx_uint_t nelts<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 构建散列表</span><span class="token keyword">void</span> <span class="token operator">*</span> <span class="token function">ngx_hash_find</span><span class="token punctuation">(</span>ngx_hash_t <span class="token operator">*</span>hash<span class="token punctuation">,</span> ngx_uint_t key<span class="token punctuation">,</span> u_char <span class="token operator">*</span>name<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 查找key</span>ngx_int_t <span class="token function">ngx_hash_wildcard_init</span><span class="token punctuation">(</span>ngx_hash_init_t <span class="token operator">*</span>hinit<span class="token punctuation">,</span> ngx_hash_key_t <span class="token operator">*</span>names<span class="token punctuation">,</span> ngx_uint_t nelts<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构建通配符散列表</span></code></pre><h5 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h5><ol><li><p>ngx_int_t ngx_hash_init(ngx_hash_init_t *hinit, ngx_hash_key_t *names, ngx_uint_t nelts): 构建散列表</p><p><img src="https://img.3amupupup.online/ngx_hash_test_1.png" alt="test"></p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/*typedef struct {    ngx_str_t         key;  // ngx_string类型的key    ngx_uint_t        key_hash; //  key经过hash函数处理之后的值    void             *value;    // value} ngx_hash_key_t;*/</span><span class="token comment" spellcheck="true">/*    第一个参数：hash表初始化结构：通过这个结构提供的参数进行初始化    第二个参数：ngx_hash_key_t组成的数组(先将key的hash值算好存储在结构里，    用的时候直接取就行了，而不是边用边计算hash值)    第三个元素：数组的元素个数*/</span><span class="token comment" spellcheck="true">/*    出现的参数说明：                        max_size: 桶的最大数量(这个hash表桶的最大个数)                        bucket_size: 桶的内存空间大小(不能超过65535)                        elt: ngx_hash_elt_t类型，桶中存储的元素    */</span>ngx_int_t<span class="token function">ngx_hash_init</span><span class="token punctuation">(</span>ngx_hash_init_t <span class="token operator">*</span>hinit<span class="token punctuation">,</span> ngx_hash_key_t <span class="token operator">*</span>names<span class="token punctuation">,</span> ngx_uint_t nelts<span class="token punctuation">)</span><span class="token punctuation">{</span>    u_char          <span class="token operator">*</span>elts<span class="token punctuation">;</span>    size_t           len<span class="token punctuation">;</span>    u_short         <span class="token operator">*</span>test<span class="token punctuation">;</span>    ngx_uint_t       i<span class="token punctuation">,</span> n<span class="token punctuation">,</span> key<span class="token punctuation">,</span> size<span class="token punctuation">,</span> start<span class="token punctuation">,</span> bucket_size<span class="token punctuation">;</span>    ngx_hash_elt_t  <span class="token operator">*</span>elt<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span>buckets<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hinit<span class="token operator">-></span>max_size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*            如果max_size为0，那么这个hash表毫无意义         */</span>        <span class="token function">ngx_log_error</span><span class="token punctuation">(</span>NGX_LOG_EMERG<span class="token punctuation">,</span> hinit<span class="token operator">-></span>pool<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                      <span class="token string">"could not build %s, you should "</span>u                      <span class="token string">"increase %s_max_size: %i"</span><span class="token punctuation">,</span>                      hinit<span class="token operator">-></span>name<span class="token punctuation">,</span> hinit<span class="token operator">-></span>name<span class="token punctuation">,</span> hinit<span class="token operator">-></span>max_size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hinit<span class="token operator">-></span>bucket_size <span class="token operator">></span> <span class="token number">65536</span> <span class="token operator">-</span> ngx_cacheline_size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*                从这里可以看出：bucket_size的长度不会超过65535字节，                elt的len成员的类型是u_short(无符号短整型，范围0~65535)，                也就是说一个桶在最坏情况下只能存储一个elt(如果elt足够长)。        */</span>        <span class="token function">ngx_log_error</span><span class="token punctuation">(</span>NGX_LOG_EMERG<span class="token punctuation">,</span> hinit<span class="token operator">-></span>pool<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                      <span class="token string">"could not build %s, too large "</span>                      <span class="token string">"%s_bucket_size: %i"</span><span class="token punctuation">,</span>                      hinit<span class="token operator">-></span>name<span class="token punctuation">,</span> hinit<span class="token operator">-></span>name<span class="token punctuation">,</span> hinit<span class="token operator">-></span>bucket_size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> nelts<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>hinit<span class="token operator">-></span>bucket_size <span class="token operator">&lt;</span> <span class="token function">NGX_HASH_ELT_SIZE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>names<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">/*              这里直接说结论：所有的bucket都是存储在一块连续的内存上的，所有的bucket通过              自己末尾上的NULL指针进行间隔(看上面的图)，由于names数组中每个元素对应的key              的长度可能都是不一样的，在用names中的元素生成对应的elt(elt包含一个柔性数组)时，              names中元素的key的长度不同，生成的elt的大小也就不同，为了提高对内存的访问效率，              ngx对每个elt进行了内存对齐，所以在连续内存上给elt分配内存时，并不是elt多大就分配              多少内存，而是分配对齐后的内存(类似结构体的内存对齐)。              这里遍历names中的每个元素，计算对应elt的内存大小进行计算，如果发现出现了              bucket_size小于其中任何一个元素的对应的elt的内存的大小(必须保证bucket_size              能存储至少一个elt)，就会返回失败提醒调用者增加bucket_size。          */</span>        <span class="token punctuation">{</span>            <span class="token function">ngx_log_error</span><span class="token punctuation">(</span>NGX_LOG_EMERG<span class="token punctuation">,</span> hinit<span class="token operator">-></span>pool<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                          <span class="token string">"could not build %s, you should "</span>                          <span class="token string">"increase %s_bucket_size: %i"</span><span class="token punctuation">,</span>                          hinit<span class="token operator">-></span>name<span class="token punctuation">,</span> hinit<span class="token operator">-></span>name<span class="token punctuation">,</span> hinit<span class="token operator">-></span>bucket_size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    test <span class="token operator">=</span> <span class="token function">ngx_alloc</span><span class="token punctuation">(</span>hinit<span class="token operator">-></span>max_size <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>u_short<span class="token punctuation">)</span><span class="token punctuation">,</span> hinit<span class="token operator">-></span>pool<span class="token operator">-></span>log<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          申请一个数组test，max_size个元素，元素类型u_short，稍后会进行模拟hash表的生成过程，          test数组是用来存储每一个bucket在生成hash表的过程中存储的元素所占用的内存大小，检测桶          中所有元素的内存大小是否超过了bucket_size。      */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>test <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    bucket_size <span class="token operator">=</span> hinit<span class="token operator">-></span>bucket_size <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          上面说过一个结论：每个bucket的末尾都存在一个NULL指针。所以一个桶能真正被用来          存储elt的空间应该减去一个空指针的大小。      */</span>    start <span class="token operator">=</span> nelts <span class="token operator">/</span> <span class="token punctuation">(</span>bucket_size <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*        一个ngx_hash_elt_t结构实例化之后的对象在内存上最少需要占用(2 * sizeof(void *))        字节内存，在此记为elt_min_size。        bucket_size / elt_min_size 的含义即：桶中能存储的最大元素个数，在此记为max_num。        start = nelts / max_num 的含义即为：桶的个数(至少)。      */</span>    start <span class="token operator">=</span> start <span class="token operator">?</span> start <span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 最起码要给一个桶</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hinit<span class="token operator">-></span>max_size <span class="token operator">></span> <span class="token number">10000</span> <span class="token operator">&amp;&amp;</span> nelts <span class="token operator">&amp;&amp;</span> hinit<span class="token operator">-></span>max_size <span class="token operator">/</span> nelts <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*             这一段暂时说不出原因，应该是对桶个数上的优化        */</span>        start <span class="token operator">=</span> hinit<span class="token operator">-></span>max_size <span class="token operator">-</span> <span class="token number">1000</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>size <span class="token operator">=</span> start<span class="token punctuation">;</span> size <span class="token operator">&lt;=</span> hinit<span class="token operator">-></span>max_size<span class="token punctuation">;</span> size<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*            这里开始进行探测的逻辑，内存循环根据桶子的个数去探测是否能装下所有elt，            外层循环不断增加桶子个数。        */</span>        <span class="token function">ngx_memzero</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span> size <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>u_short<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*            初始化为0，按需初始化，有多少个桶就初始化多少个test的元素(置0)        */</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> nelts<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>names<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">.</span>data <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">/*                  key是ngx_string类型，ngx_string的成员data指向字符的地址                这里是排除空串的情况              */</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            key <span class="token operator">=</span> names<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span>key_hash <span class="token operator">%</span> size<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/*                key的hash值 模 上size(桶个数)就能得出位于哪个bucket            */</span>            len <span class="token operator">=</span> test<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">NGX_HASH_ELT_SIZE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>names<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">/*                  test[key]上存储的是对应的桶buckets[key]已经使用了的空间，                  len是当前桶再次存储一个elt之后的内存空间大小的值              */</span><span class="token macro property">#<span class="token directive keyword">if</span> 0</span>            <span class="token function">ngx_log_error</span><span class="token punctuation">(</span>NGX_LOG_ALERT<span class="token punctuation">,</span> hinit<span class="token operator">-></span>pool<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                          <span class="token string">"%ui: %ui %uz \"%V\""</span><span class="token punctuation">,</span>                          size<span class="token punctuation">,</span> key<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>names<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">></span> bucket_size<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">/*                  如果有发现len大于桶子的存储空间，说明发生了hash碰撞次数较多                  (碰撞多存储的元素就多)，导致桶子里的空间溢出了，因此跳出当前                  循环进入外层的循环去增加桶子的葛素。              */</span>                 <span class="token keyword">goto</span> next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            test<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>u_short<span class="token punctuation">)</span> len<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">/*                  如果没发生桶空间溢出，则将len更新至test              */</span>        <span class="token punctuation">}</span>        <span class="token keyword">goto</span> found<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/*              走完一圈都没发生桶子空间溢出，则说明此时的size比较合适，能够存储所有元素          */</span>    next<span class="token punctuation">:</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    size <span class="token operator">=</span> hinit<span class="token operator">-></span>max_size<span class="token punctuation">;</span>    <span class="token function">ngx_log_error</span><span class="token punctuation">(</span>NGX_LOG_WARN<span class="token punctuation">,</span> hinit<span class="token operator">-></span>pool<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                  <span class="token string">"could not build optimal %s, you should increase "</span>                  <span class="token string">"either %s_max_size: %i or %s_bucket_size: %i; "</span>                  <span class="token string">"ignoring %s_bucket_size"</span><span class="token punctuation">,</span>                  hinit<span class="token operator">-></span>name<span class="token punctuation">,</span> hinit<span class="token operator">-></span>name<span class="token punctuation">,</span> hinit<span class="token operator">-></span>max_size<span class="token punctuation">,</span>                  hinit<span class="token operator">-></span>name<span class="token punctuation">,</span> hinit<span class="token operator">-></span>bucket_size<span class="token punctuation">,</span> hinit<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>found<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">/*         此时已经找到了最合适的桶子数：size。(决定桶子个数的原则：不浪费内存)    */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        test<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/*              上一步计算除去了bucket中NULL指针的空间,但是在实际中，              NULL指针也要算进去，这样才能给bucket分配最准确的内存大小，          */</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> nelts<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>names<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">.</span>data <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 忽略空key</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        key <span class="token operator">=</span> names<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span>key_hash <span class="token operator">%</span> size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 得到当前key应该位于哪个桶</span>        len <span class="token operator">=</span> test<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">NGX_HASH_ELT_SIZE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>names<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前桶子已经使用了的内存空间</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">></span> <span class="token number">65536</span> <span class="token operator">-</span> ngx_cacheline_size<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">/*                  如果有桶的长度大于bucket_size，说明桶溢出了              */</span>            <span class="token function">ngx_log_error</span><span class="token punctuation">(</span>NGX_LOG_EMERG<span class="token punctuation">,</span> hinit<span class="token operator">-></span>pool<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                          <span class="token string">"could not build %s, you should "</span>                          <span class="token string">"increase %s_max_size: %i"</span><span class="token punctuation">,</span>                          hinit<span class="token operator">-></span>name<span class="token punctuation">,</span> hinit<span class="token operator">-></span>name<span class="token punctuation">,</span> hinit<span class="token operator">-></span>max_size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">ngx_free</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里下一步是直接返回错误了，test必须free掉，否则会发生内存泄露</span>            <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        test<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>u_short<span class="token punctuation">)</span> len<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/*              test对应的元素保存了对应桶子的所需空间大小(桶里进一个elt，len累加)，              test[i] == bucket[i]的size          */</span>    <span class="token punctuation">}</span>    len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>test<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        test<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>u_short<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">ngx_align</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ngx_cacheline_size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        len <span class="token operator">+</span><span class="token operator">=</span> test<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*            计算出所有bucket总共需要多少内存        */</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hinit<span class="token operator">-></span>hash <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        hinit<span class="token operator">-></span>hash <span class="token operator">=</span> <span class="token function">ngx_pcalloc</span><span class="token punctuation">(</span>hinit<span class="token operator">-></span>pool<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ngx_hash_wildcard_t<span class="token punctuation">)</span>                                             <span class="token operator">+</span> size <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ngx_hash_elt_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*            sizeof(ngx_hash_wildcard_t)应该是有其它作用，暂时不理会。这里            分配了一个指针数组(ngx_hash_elt_t *)，每个指针指向对应的bucket的头部。            (看文章开始的图)        */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>hinit<span class="token operator">-></span>hash <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ngx_free</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        buckets <span class="token operator">=</span> <span class="token punctuation">(</span>ngx_hash_elt_t <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>                      <span class="token punctuation">(</span><span class="token punctuation">(</span>u_char <span class="token operator">*</span><span class="token punctuation">)</span> hinit<span class="token operator">-></span>hash <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ngx_hash_wildcard_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        buckets <span class="token operator">=</span> <span class="token function">ngx_pcalloc</span><span class="token punctuation">(</span>hinit<span class="token operator">-></span>pool<span class="token punctuation">,</span> size <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ngx_hash_elt_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>buckets <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ngx_free</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    elts <span class="token operator">=</span> <span class="token function">ngx_palloc</span><span class="token punctuation">(</span>hinit<span class="token operator">-></span>pool<span class="token punctuation">,</span> len <span class="token operator">+</span> ngx_cacheline_size<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          根据之前计算得到的len给所有elts分配一大块连续的内存(从内存池上申请的)      */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>elts <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_free</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    elts <span class="token operator">=</span> <span class="token function">ngx_align_ptr</span><span class="token punctuation">(</span>elts<span class="token punctuation">,</span> ngx_cacheline_size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 内存对齐，暂时不理解</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>test<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 说明在构建hash表时没有elt落进这个桶</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ngx_hash_elt_t <span class="token operator">*</span><span class="token punctuation">)</span> elts<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/*              类型转换          */</span>        elts <span class="token operator">+</span><span class="token operator">=</span> test<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/*              test[i]中存储的是模拟hash表构建过程中，每个桶中元素大小的总和。              现在按照这个值给桶子按需分配内存，最大程度的节省内存          */</span>     <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// test数组置0</span>        test<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> nelts<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>names<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">.</span>data <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 跳过空key</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 这里开始真正的遍历names数组，构建hash表</span>        key <span class="token operator">=</span> names<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span>key_hash <span class="token operator">%</span> size<span class="token punctuation">;</span>        elt <span class="token operator">=</span> <span class="token punctuation">(</span>ngx_hash_elt_t <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>u_char <span class="token operator">*</span><span class="token punctuation">)</span> buckets<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">+</span> test<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 拿到elt的首地址</span>        elt<span class="token operator">-></span>value <span class="token operator">=</span> names<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 写入value</span>        elt<span class="token operator">-></span>len <span class="token operator">=</span> <span class="token punctuation">(</span>u_short<span class="token punctuation">)</span> names<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">.</span>len<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 写入len字段</span>        <span class="token function">ngx_strlow</span><span class="token punctuation">(</span>elt<span class="token operator">-></span>name<span class="token punctuation">,</span> names<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">.</span>data<span class="token punctuation">,</span> names<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">.</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 修改key为小写</span>        test<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>u_short<span class="token punctuation">)</span> <span class="token punctuation">(</span>test<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">NGX_HASH_ELT_SIZE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>names<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 记录每个bucket的大小</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 遍历buckets</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        elt <span class="token operator">=</span> <span class="token punctuation">(</span>ngx_hash_elt_t <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>u_char <span class="token operator">*</span><span class="token punctuation">)</span> buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> test<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/*              buckets[i]是每个bucket的首地址，加上起存储空间就是末尾的位置，              将次位置当做elt处理，其value置空，当做间隔标志。          */</span>        elt<span class="token operator">-></span>value <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 置为NULL</span>    <span class="token punctuation">}</span>    <span class="token function">ngx_free</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>    hinit<span class="token operator">-></span>hash<span class="token operator">-></span>buckets <span class="token operator">=</span> buckets<span class="token punctuation">;</span>    hinit<span class="token operator">-></span>hash<span class="token operator">-></span>size <span class="token operator">=</span> size<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> 0</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ngx_str_t   val<span class="token punctuation">;</span>        ngx_uint_t  key<span class="token punctuation">;</span>        elt <span class="token operator">=</span> buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>elt <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ngx_log_error</span><span class="token punctuation">(</span>NGX_LOG_ALERT<span class="token punctuation">,</span> hinit<span class="token operator">-></span>pool<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                          <span class="token string">"%ui: NULL"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>elt<span class="token operator">-></span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            val<span class="token punctuation">.</span>len <span class="token operator">=</span> elt<span class="token operator">-></span>len<span class="token punctuation">;</span>            val<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token operator">&amp;</span>elt<span class="token operator">-></span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            key <span class="token operator">=</span> hinit<span class="token operator">-></span><span class="token function">key</span><span class="token punctuation">(</span>val<span class="token punctuation">.</span>data<span class="token punctuation">,</span> val<span class="token punctuation">.</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">ngx_log_error</span><span class="token punctuation">(</span>NGX_LOG_ALERT<span class="token punctuation">,</span> hinit<span class="token operator">-></span>pool<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                          <span class="token string">"%ui: %p \"%V\" %ui"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> elt<span class="token punctuation">,</span> <span class="token operator">&amp;</span>val<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            elt <span class="token operator">=</span> <span class="token punctuation">(</span>ngx_hash_elt_t <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">ngx_align_ptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>elt<span class="token operator">-></span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> elt<span class="token operator">-></span>len<span class="token punctuation">,</span>                                                   <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token keyword">return</span> NGX_OK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>void * ngx_hash_find(ngx_hash_t *hash, ngx_uint_t key, u_char *name, size_t len): 查找key</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* * 第一个参数：hash表 * 第二个参数：key经过hash函数计算出的值 * 第三个参数：key * 第四个长度：key的长度 */</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">ngx_hash_find</span><span class="token punctuation">(</span>ngx_hash_t <span class="token operator">*</span>hash<span class="token punctuation">,</span> ngx_uint_t key<span class="token punctuation">,</span> u_char <span class="token operator">*</span>name<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_uint_t       i<span class="token punctuation">;</span>    ngx_hash_elt_t  <span class="token operator">*</span>elt<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> 0</span>    <span class="token function">ngx_log_error</span><span class="token punctuation">(</span>NGX_LOG_ALERT<span class="token punctuation">,</span> ngx_cycle<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"hf:\"%*s\""</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    elt <span class="token operator">=</span> hash<span class="token operator">-></span>buckets<span class="token punctuation">[</span>key <span class="token operator">%</span> hash<span class="token operator">-></span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*        key进行取模得到它是位于哪个桶里，得到的是bucket的首地址    */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>elt <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*            说明桶里没有元素        */</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>elt<span class="token operator">-></span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*            桶的结尾元素：elt->value==NULL，间隔标志，            走到NULL说明key不存在        */</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">!=</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span> elt<span class="token operator">-></span>len<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">/*              如果传入的key的长度不等于桶中elt的长度(elt->len是指key的长度)              那么必不是这个key，就不用检查key了。先判断长度，在判断key，长              度不同key就不用比较了          */</span>            <span class="token keyword">goto</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">/*                  比较key              */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> elt<span class="token operator">-></span>name<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">goto</span> next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> elt<span class="token operator">-></span>value<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/*              走到这里说明找到了          */</span>    next<span class="token punctuation">:</span>        elt <span class="token operator">=</span> <span class="token punctuation">(</span>ngx_hash_elt_t <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">ngx_align_ptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>elt<span class="token operator">-></span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> elt<span class="token operator">-></span>len<span class="token punctuation">,</span>                                               <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*            计算下一个元素的起始地址并进行类型转换        */</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 否则返回空</span><span class="token punctuation">}</span></code></pre></li><li><p>ngx_int_t ngx_hash_wildcard_init<strong>(</strong>ngx_hash_init_t <strong>***hinit</strong>,** ngx_hash_key_t <strong>***names</strong>,**    ngx_uint_t nelts**);</p></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>ngx_hash_init初始化的hash表是静态的，根据给定的一组key结构和key的个数进行初始化，生成的hash表仅仅是为了查找，不能动态添加元素。初始化过程中会模拟hash表的构建，但又不是真正意义上的构建，仅仅是在模拟构建时计算每个桶需要的空间，然后在真正构建hash表时按需给桶分配内存，最大程度的节省内存。</p><p>所有bucket下的所有elt位于一块连续的内存上，通过elt-&gt;value == NULL作为bucket之间的间隔。</p><p>最重要的一点：</p><p>buckets是一块连续的内存，由多个bucket组成，每个bucket的末尾存在一个NULL指针作为标志位。</p><p>bucket由多个elt组成，因为key的长度不一样，最终生成的elt长度也不一样(key是保存在elt的柔性数组上)，也就是说不能像操作数组一样去操作buckets(数组的每个元素大小相同，可以通过步长去访问，但是这里的bucket中的每个elt长度不一致)。</p><p>解决办法：</p><p><img src="https://img.3amupupup.online/ngx_align_1.png" alt="ngx_align"></p><p>这两个宏函数的作用： 在b的基础上对a求最小的倍数。 ngx_hash_elt_t的前两个结构体成员自动对齐了，不对齐的是后面的这个柔性数组，经过这两个宏函数处理后，在柔性数组后面补了一块内存(红色部分)，这就对齐了。这是连续的内存但是因为elt这个结构的内存大小和key有关系，key越大name越大越大elt越大，key是不定长的，因此每个elt的大小都不一样，那就不能像数组那样操作bucket。在计算模拟hash构建阶段，会计算elt对齐后的内存空间大小，因此elt的末尾地址必然是4或8的倍数，访问第二个元素时，通过拿到第一个elt的(&amp;elt-&gt;name[0] + elt-&gt;len)再使用ngx_align_ptr对其进行取整，拿到的就是下一个elt的首地址。(要拿到第二个元素就必须知道第一个元素的name数组后的第一个内存地址，拿第三个就需要知道第二个的，有链表那味儿，但是无伤大雅，因为在构建hash时多个元素可能会落进同一个桶里，查找时如果得到的桶里恰好有多个元素，也是需要去遍历对比name的)。</p><h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h5><ol><li><p>内存对齐</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> ngx_align(d, a)     (((d) + (a - 1)) &amp; ~(a - 1))</span><span class="token macro property">#<span class="token directive keyword">define</span> ngx_align_ptr(p, a)                                                   \    (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) &amp; ~((uintptr_t) a - 1))</span><span class="token macro property">#<span class="token directive keyword">define</span> NGX_HASH_ELT_SIZE(name)                                               \    (sizeof(void *) + ngx_align((name)->key.len + 2, sizeof(void *)))</span><span class="token comment" spellcheck="true">/*    a = 4:  二进制： 0000 0100       从右往左，第三位为1，剩下全为0;    a = 8:  二进制： 0000 1000       从右往左，第四位为1, 剩下全为0；    a = 16: 二进制:  0001 0000       从右往左，第五位为1，剩下全为0；    a - 1 = 3:  二进制： 0000 0011   从右往左，第三位之前，全是1；    a - 1 = 7:  二进制： 0000 0111   从右往左，第四位之前，全是1；    a - 1 = 15: 二进制： 0000 1111   从右往左，第五位之前，全是1；    ~(a - 1) = ~3:  二进制： 1111 1100   从右往左，第二位之后，全是1；    ~(a - 1) = ~7:  二进制： 1111 1000   从右往左，第三位之后，全是1；    ~(a - 1) = ~15: 二进制： 1111 0000   从右往左，第四位之后，全是1；    一个数，一定是这个数的二进制从右起第一个不为零的位所表示的数的整数倍    a = 12:  二进制： 0000 1100     从右起，第一个不为零的位所表示的整数为 0000 0100 即 4    那么，a = 12 一定是 4 的整数倍    如果，我们需要任意的一个数a对4取整怎么办呢？很简单，只需要把a从右起的若干位置0就可以了。    比如：            a = 13: 二进制：0000 1101            向0000 0100 即 4 取整，只需要将 0000 1101从右起，前两位置0，即可得到，0000 1100 即12            这个置0的过程可以表达为0000 1101 &amp;  1111 1100            而 1111 1100 = ~(4 - 1)，因此，13 对 4 取整的二进制运算即为：13 &amp; ~(4 - 1)    对于一个任意的数d和一个2的任意次幂a：    d对a向下取整的二进制运算为：d &amp; ~(a -1)    d对a向上取整的二进制运算为：(d + (a - 1)) &amp; ~(a - 1)*/</span><span class="token comment" spellcheck="true">/*    ngx_align(9,4) = 12    ngx_align(17,4) = 20    ngx_align_ptr(p, a)和ngx_align一样，只是会先将内存地址转成数字再计算*/</span></code></pre></li><li><p>柔性数组</p><p><img src="https://img.3amupupup.online/soft_array.png" alt="柔性数组"></p><p>结论：柔性数组与结构体在内存上是连续的</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hashtable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ngx_align</title>
      <link href="2021/03/22/ngx_align/"/>
      <url>2021/03/22/ngx_align/</url>
      
        <content type="html"><![CDATA[<p>1、cache line</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/130770773" target="_blank" rel="noopener">CPU Cache</a></p><p>CPU 每次访问数据时先在缓存中查找一次，找不到则去主存找，访问完数据后会将数据存入缓存，以备后用。这就产生了一个问题，CPU 在访问某个地址的时候如何知道目标数据是在缓存中存在？如何知道缓存的数据是否还有效没被修改？不能为每个存入缓存的字节都打标记，所以 CPU 缓存会划分为固定大小的 Block 称为 Cache Line，作为存取数据的最小单位。大小都为 2 的整数幂，比如 16 字节，256 字节等。这样一个 cache line 这一整块内存能通过一个标记来记录是否在内存中，是否还有效，是否被修改等。一次存取一块数据也能充分利用总线带宽以及 CPU 访问的空间局部性。</p></blockquote><pre class=" language-c"><code class="language-c"></code></pre><hr><p>实际上，对齐参数(MALLOC_ALIGNMENT)大小的设定需要满足以下两点：</p><ol><li><p>必须是2的幂</p></li><li><p>必须是void *的整数倍</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nginx单向链表</title>
      <link href="2021/03/22/ngx_list/"/>
      <url>2021/03/22/ngx_list/</url>
      
        <content type="html"><![CDATA[<h4 id="nginx数据类型：单向链表"><a href="#nginx数据类型：单向链表" class="headerlink" title="nginx数据类型：单向链表"></a>nginx数据类型：单向链表</h4><p><img src="https://img.3amupupup.online/ngx_list_1.png" alt="单向链表"></p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 单向链表的子结点</span><span class="token keyword">struct</span> ngx_list_part_s <span class="token punctuation">{</span>    <span class="token keyword">void</span>             <span class="token operator">*</span>elts<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 数据区的首地址</span>    ngx_uint_t        nelts<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  指向第一个未使用过的元素</span>    ngx_list_part_t  <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//  指向下一个结点的指针</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 单向链表的父结点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    ngx_list_part_t  <span class="token operator">*</span>last<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指向链表中的最后一个结点</span>    ngx_list_part_t   part<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//</span>    size_t            size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 元素大小</span>    ngx_uint_t        nalloc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//  指向最后一个使用过的元素</span>    ngx_pool_t       <span class="token operator">*</span>pool<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//  指向内存池的指针，因为都是从内存池上分配的，所以需要保存指向内存池的指针</span><span class="token punctuation">}</span> ngx_list_t<span class="token punctuation">;</span></code></pre><h5 id="单向链表提供的接口"><a href="#单向链表提供的接口" class="headerlink" title="单向链表提供的接口"></a>单向链表提供的接口</h5><pre class=" language-c"><code class="language-c">ngx_list_t <span class="token operator">*</span><span class="token function">ngx_list_create</span><span class="token punctuation">(</span>ngx_pool_t <span class="token operator">*</span>pool<span class="token punctuation">,</span> ngx_uint_t n<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建链表结构(父结点)</span><span class="token keyword">static</span> ngx_inline ngx_int_t <span class="token function">ngx_list_init</span><span class="token punctuation">(</span>ngx_list_t <span class="token operator">*</span>list<span class="token punctuation">,</span> ngx_pool_t <span class="token operator">*</span>pool<span class="token punctuation">,</span> ngx_uint_t n<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化操作</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">ngx_list_push</span><span class="token punctuation">(</span>ngx_list_t <span class="token operator">*</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 添加元素</span></code></pre><h5 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h5><ol><li><p>ngx_list_t *ngx_list_create(ngx_pool_t *pool, ngx_uint_t n, size_t size): 创建链表结构</p><pre class=" language-c"><code class="language-c">ngx_list_t <span class="token operator">*</span><span class="token function">ngx_list_create</span><span class="token punctuation">(</span>ngx_pool_t <span class="token operator">*</span>pool<span class="token punctuation">,</span> ngx_uint_t n<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_list_t  <span class="token operator">*</span>list<span class="token punctuation">;</span>    list <span class="token operator">=</span> <span class="token function">ngx_palloc</span><span class="token punctuation">(</span>pool<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ngx_list_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          在small链表上给链表的管理结构(父结点: ngx_list_t)分配内存      */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_list_init</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> pool<span class="token punctuation">,</span> n<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token operator">!=</span> NGX_OK<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 初始化数据区域</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> list<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>static ngx_inline ngx_int_t ngx_list_init(ngx_list_t *list, ngx_pool_t *pool, ngx_uint_t n, size_t size): 初始化链表</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> ngx_inline ngx_int_t<span class="token function">ngx_list_init</span><span class="token punctuation">(</span>ngx_list_t <span class="token operator">*</span>list<span class="token punctuation">,</span> ngx_pool_t <span class="token operator">*</span>pool<span class="token punctuation">,</span> ngx_uint_t n<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    list<span class="token operator">-></span>part<span class="token punctuation">.</span>elts <span class="token operator">=</span> <span class="token function">ngx_palloc</span><span class="token punctuation">(</span>pool<span class="token punctuation">,</span> n <span class="token operator">*</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          分配在small还是large链表上取决于n*size      */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token operator">-></span>part<span class="token punctuation">.</span>elts <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    list<span class="token operator">-></span>part<span class="token punctuation">.</span>nelts <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          指向最后一个使用过的元素      */</span>    list<span class="token operator">-></span>part<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          指向链表的下一个结点      */</span>    list<span class="token operator">-></span>last <span class="token operator">=</span> <span class="token operator">&amp;</span>list<span class="token operator">-></span>part<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          指向当前链表的最后一个结点(初始化时指向自己)，便于尾插      */</span>    list<span class="token operator">-></span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          元素的大小(占用内存的字节)      */</span>    list<span class="token operator">-></span>nalloc <span class="token operator">=</span> n<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          元素个数      */</span>    list<span class="token operator">-></span>pool <span class="token operator">=</span> pool<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          指向内存池      */</span>    <span class="token keyword">return</span> NGX_OK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>void *ngx_list_push(ngx_list_t *list): 添加元素</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">ngx_list_push</span><span class="token punctuation">(</span>ngx_list_t <span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">void</span>             <span class="token operator">*</span>elt<span class="token punctuation">;</span>    ngx_list_part_t  <span class="token operator">*</span>last<span class="token punctuation">;</span>    last <span class="token operator">=</span> l<span class="token operator">-></span>last<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          拿到最后一个元素的指针，尾插时避免遍历链表从而导致效率低下      */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>last<span class="token operator">-></span>nelts <span class="token operator">==</span> l<span class="token operator">-></span>nalloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/*                    说明空间用完了，需要扩容                */</span>        <span class="token comment" spellcheck="true">/* the last part is full, allocate a new list part */</span>        last <span class="token operator">=</span> <span class="token function">ngx_palloc</span><span class="token punctuation">(</span>l<span class="token operator">-></span>pool<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ngx_list_part_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/*              从内存池上给子结点结构分配内存          */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">/*                  分配失败              */</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        last<span class="token operator">-></span>elts <span class="token operator">=</span> <span class="token function">ngx_palloc</span><span class="token punctuation">(</span>l<span class="token operator">-></span>pool<span class="token punctuation">,</span> l<span class="token operator">-></span>nalloc <span class="token operator">*</span> l<span class="token operator">-></span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/*              从内存池上给新结点分配数据区的内存，每个结点的数据区域都是一样大          */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>last<span class="token operator">-></span>elts <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">/*                  分配失败              */</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        last<span class="token operator">-></span>nelts <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/*              新扩容的链表没有使用过，nelts指向第一个元素          */</span>        last<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        l<span class="token operator">-></span>last<span class="token operator">-></span>next <span class="token operator">=</span> last<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/*              将新添加的结点添加到链表末尾          */</span>        l<span class="token operator">-></span>last <span class="token operator">=</span> last<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/*              链表的last指向也要修改          */</span>    <span class="token punctuation">}</span>    elt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> last<span class="token operator">-></span>elts <span class="token operator">+</span> l<span class="token operator">-></span>size <span class="token operator">*</span> last<span class="token operator">-></span>nelts<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          首地址加上已经使用的内存等于未使用内存的起始位置      */</span>    last<span class="token operator">-></span>nelts<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> elt<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx双向链表</title>
      <link href="2021/03/21/ngx_queue/"/>
      <url>2021/03/21/ngx_queue/</url>
      
        <content type="html"><![CDATA[<h4 id="nginx数据类型：双向链表"><a href="#nginx数据类型：双向链表" class="headerlink" title="nginx数据类型：双向链表"></a>nginx数据类型：双向链表</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> ngx_queue_s <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/*          链表这个结构本身不带有任何数据，而是把这个链表结构挂载到业务数据结构上，实现了业务数据结构与链表结构的解耦      */</span>    ngx_queue_t  <span class="token operator">*</span>prev<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 前驱指针</span>    ngx_queue_t  <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 后驱指针</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><img src="https://img.3amupupup.online/ngx_queue_2.png" alt="链表示例"></p><h5 id="双向链表提供的接口"><a href="#双向链表提供的接口" class="headerlink" title="双向链表提供的接口"></a>双向链表提供的接口</h5><pre class=" language-c"><code class="language-c"><span class="token function">ngx_queue_init</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化链表指向</span><span class="token function">ngx_queue_empty</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 判断链表是否为空</span><span class="token function">ngx_queue_insert_head</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 链表头插</span><span class="token function">ngx_queue_insert_tail</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 链表尾插</span><span class="token function">ngx_queue_head</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取链表第一个元素，h是哨兵位</span><span class="token function">ngx_queue_last</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取链表最后一个元素</span><span class="token function">ngx_queue_sentinel</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取哨兵结点</span><span class="token function">ngx_queue_next</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取结点q的下一个结q</span><span class="token function">ngx_queue_prev</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取结点q的前一个结点</span><span class="token function">ngx_queue_remove</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从链表中移除x结点</span><span class="token function">ngx_queue_split</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> q<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 切割链表</span><span class="token function">ngx_queue_add</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ngx_queue_data</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> type<span class="token punctuation">,</span> link<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 以上都是宏函数</span>ngx_queue_t <span class="token operator">*</span><span class="token function">ngx_queue_middle</span><span class="token punctuation">(</span>ngx_queue_t <span class="token operator">*</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h5><ol><li><p>ngx_queue_init(q): 初始化链表</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> ngx_queue_init(q)                                                     \    (q)->prev = q;                                                            \    (q)->next = q</span><span class="token comment" spellcheck="true">/*    前驱、后驱指针都指向自己，当前结点是哨兵位*/</span></code></pre></li><li><p>ngx_queue_empty(h): 判断链表是否为空</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> ngx_queue_empty(h)                                                    \    (h == (h)->prev)</span><span class="token comment" spellcheck="true">/*    双向链表的前驱或者后驱指向的是自己时则为空(仅存在哨兵结点)*/</span></code></pre></li><li><p>ngx_queue_insert_head(h, x): 在头结点之后插入x结点(头插)</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> ngx_queue_insert_head(h, x)                                           \    (x)->next = (h)->next;                                                    \    (x)->next->prev = x;                                                      \    (x)->prev = h;                                                            \    (h)->next = x</span></code></pre></li><li><p>ngx_queue_insert_tail(h, x): 在链表的末尾添加新结点x(尾插)</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> ngx_queue_insert_tail(h, x)                                           \    (x)->prev = (h)->prev;                                                    \    (x)->prev->next = x;                                                      \    (x)->next = h;                                                            \    (h)->prev = x</span></code></pre></li><li><p>ngx_queue_head(h): 获取链表的第一个有效结点(除去哨兵位)</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> ngx_queue_head(h)                                                     \    (h)->next</span></code></pre></li><li><p>ngx_queue_last(h): 获取链表最后一个结点</p><pre><code>#define ngx_queue_last(h)                                                     \    (h)-&gt;prev</code></pre></li><li><p>ngx_queue_sentinel(h): 获取哨兵位</p><pre><code>#define ngx_queue_sentinel(h)                                                 \    (h)</code></pre></li><li><p>ngx_queue_next(q): 获取q的下一个结点</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> ngx_queue_next(q)                                                     \    (q)->next</span></code></pre></li><li><p>ngx_queue_prev(q): 获取q的前一个结点</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> ngx_queue_prev(q)                                                     \    (q)->prev</span></code></pre></li><li><p>ngx_queue_remove(x): 从链表中移除结点x</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> ngx_queue_remove(x)                                                   \    (x)->next->prev = (x)->prev;                                              \    (x)->prev->next = (x)->next;                                              \    (x)->prev = NULL;                                                         \    (x)->next = NULL</span></code></pre></li><li><p>ngx_queue_add</p><pre><code>#define ngx_queue_add(h, n)                                                   \    (h)-&gt;prev-&gt;next = (n)-&gt;next;                                              \    (n)-&gt;next-&gt;prev = (h)-&gt;prev;                                              \    (h)-&gt;prev = (n)-&gt;prev;                                                    \    (h)-&gt;prev-&gt;next = h;</code></pre></li><li><p>ngx_queue_data(q, type, link)</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> ngx_queue_data(q, type, link)                                         \    (type *) ((u_char *) q - offsetof(type, link))</span><span class="token comment" spellcheck="true">/*    可以通过业务结构体中ngx_queue_t数据结构的偏移量来得到业务主体的数据结构的指针地址，    实现了业务数据结构和链表结构的解耦*/</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stddef.h></span></span><span class="token comment" spellcheck="true">/* #define ngx_queue_data(q, type, link)                                         \    (type *) ((u_char *) q - offsetof(type, link))*/</span><span class="token keyword">struct</span> data<span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token operator">*</span> _a<span class="token punctuation">;</span>    <span class="token keyword">long</span> _b<span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token operator">*</span> _c<span class="token punctuation">;</span>    <span class="token keyword">float</span> _d<span class="token punctuation">;</span>    <span class="token keyword">struct</span> data<span class="token operator">*</span> _e<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"data结构中_a 偏移量 = %ld字节\n"</span><span class="token punctuation">,</span><span class="token function">offsetof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> data<span class="token punctuation">,</span> _a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"data结构中_d 偏移量 = %ld字节\n"</span><span class="token punctuation">,</span><span class="token function">offsetof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> data<span class="token punctuation">,</span> _d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> data d<span class="token punctuation">;</span>    <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    d<span class="token punctuation">.</span>_a <span class="token operator">=</span> array<span class="token punctuation">;</span>    d<span class="token punctuation">.</span>_b <span class="token operator">=</span> <span class="token number">333</span><span class="token punctuation">;</span>    d<span class="token punctuation">.</span>_c <span class="token operator">=</span> <span class="token string">"duwei"</span><span class="token punctuation">;</span>    d<span class="token punctuation">.</span>_d <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"d._c = %s\n"</span><span class="token punctuation">,</span>d<span class="token punctuation">.</span>_c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"d._d = %f\n"</span><span class="token punctuation">,</span>d<span class="token punctuation">.</span>_d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> data <span class="token operator">*</span>newP <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> data<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>_d<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">offsetof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> data<span class="token punctuation">,</span> _d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*        将_d成员的地址转换成char*, 再减去_d相对data的偏移量(字节)，        再将得到的结果转换成struct data*就是d的首地址。    */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"newP->_c = %s\n"</span><span class="token punctuation">,</span>newP<span class="token operator">-></span>_c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"newP->_d = %f\n"</span><span class="token punctuation">,</span>newP<span class="token operator">-></span>_d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"d = %p, newP = %p\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>d<span class="token punctuation">,</span>newP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>ngx_queue_t *ngx_queue_middle(ngx_queue_t *queue): 获取链表的中间结点</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/*    快慢指针获取中间结点*/</span>ngx_queue_t <span class="token operator">*</span><span class="token function">ngx_queue_middle</span><span class="token punctuation">(</span>ngx_queue_t <span class="token operator">*</span>queue<span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_queue_t  <span class="token operator">*</span>middle<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    middle <span class="token operator">=</span> <span class="token function">ngx_queue_head</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          头结点的下一个结点      */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>middle <span class="token operator">==</span> <span class="token function">ngx_queue_last</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">/*              如果middle等于头结点的上一个结点，则链表只有两个元素 head 和 mid          */</span>        <span class="token keyword">return</span> middle<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    next <span class="token operator">=</span> <span class="token function">ngx_queue_head</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          next保存链表的头结点之后的结点      */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        middle <span class="token operator">=</span> <span class="token function">ngx_queue_next</span><span class="token punctuation">(</span>middle<span class="token punctuation">)</span><span class="token punctuation">;</span>        next <span class="token operator">=</span> <span class="token function">ngx_queue_next</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/*              走到这里 middle、next都指向第二个有效结点          */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token function">ngx_queue_last</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">/*                  当next走到末尾元素时，mid才走一半，所以mid是中间元素              */</span>            <span class="token keyword">return</span> middle<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        next <span class="token operator">=</span> <span class="token function">ngx_queue_next</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/*              next走的速度是middle的两倍          */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token function">ngx_queue_last</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">/*                  走到末尾时，middle才走一半路程，此时指向中间位置              */</span>            <span class="token keyword">return</span> middle<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>void ngx_queue_sort(ngx_queue_t <em>queue, ngx_int_t (</em>cmp)(const ngx_queue_t *, const ngx_queue_t *)): 链表排序</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span><span class="token function">ngx_queue_sort</span><span class="token punctuation">(</span>ngx_queue_t <span class="token operator">*</span>queue<span class="token punctuation">,</span>    <span class="token function">ngx_int_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>cmp<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> ngx_queue_t <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> ngx_queue_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_queue_t  <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    q <span class="token operator">=</span> <span class="token function">ngx_queue_head</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">==</span> <span class="token function">ngx_queue_last</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>q <span class="token operator">=</span> <span class="token function">ngx_queue_next</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span> q <span class="token operator">!=</span> <span class="token function">ngx_queue_sentinel</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span> q <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        prev <span class="token operator">=</span> <span class="token function">ngx_queue_prev</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        next <span class="token operator">=</span> <span class="token function">ngx_queue_next</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ngx_queue_remove</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cmp</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> q<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            prev <span class="token operator">=</span> <span class="token function">ngx_queue_prev</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>prev <span class="token operator">!=</span> <span class="token function">ngx_queue_sentinel</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ngx_queue_insert_after</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>ngx_queue_split(h, q, n): </p><p><img src="https://img.3amupupup.online/ngx_queue_2.png" alt="链表示例"></p><p><img src="https://img.3amupupup.online/ngx_queue_split_1.png" alt="切割链表"></p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> ngx_queue_split(h, q, n)                                              \    (n)->prev = (h)->prev;                                                    \    (n)->prev->next = n;                                                      \    (n)->next = q;                                                            \    (h)->prev = (q)->prev;                                                    \    (h)->prev->next = h;                                                      \    (q)->prev = n;</span></code></pre><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>双向链表的数据结构中并未定义数据，而是通过将链表结构挂载到业务结构中通过offsetof计算出链表结构在业务结构中的偏移量，再减去偏移量就得到了业务结构的指针地址。实现了链表与数据的解耦。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息的表示和处理</title>
      <link href="2021/03/20/information_representation_and_processing/"/>
      <url>2021/03/20/information_representation_and_processing/</url>
      
        <content type="html"><![CDATA[<h4 id="2-1-信息存储"><a href="#2-1-信息存储" class="headerlink" title="2.1 信息存储"></a>2.1 信息存储</h4><ul><li>大多数计算机使用8位的块，或者字节(byte)，作为最小的可寻址的内存单位，而不是访问内存中单独的位。</li><li>C编译器把指针和类型联系起来，这样就可以根据指针值的类型，生成不同的机器级别代码来访问存储在指针所指向位置处的值。尽管C编译器维护着这个类型的信息，但是它生成的实际机器级程序不包含关于数据类型的信息。</li><li>机器级程序将内存视为一个非常大的字节数组，称为虚拟内存(virtual memory)。内存的每一个字节都是由唯一的数字标识的，称为地址(address)。所有地址的集合就称为虚拟地址空间(virtual address space)。</li></ul><h5 id="2-1-1-十六进制表示法"><a href="#2-1-1-十六进制表示法" class="headerlink" title="2.1.1 十六进制表示法"></a>2.1.1 十六进制表示法</h5><table><thead><tr><th align="center"></th><th align="left"></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td align="center">十六进制</td><td align="left">1</td><td>7</td><td>3</td><td>A</td><td>4</td></tr><tr><td align="center">二 进 制</td><td align="left">0001</td><td>0111</td><td>0011</td><td>1010</td><td>0100</td></tr></tbody></table><h5 id="2-1-2-字数据大小"><a href="#2-1-2-字数据大小" class="headerlink" title="2.1.2 字数据大小"></a>2.1.2 字数据大小</h5><ul><li><p>对于一个字长为w位的机器而言，虚拟地址的范围是0 ~ 2^w-1，程序最多访问2^w个字节。</p><p><img src="/image/image-20201023114928097.png" alt="image-20201023114928097"></p><p>举个例子：</p><p>32位操作系统，传输总线是32位，8bit为一个字节，那么在读或者写数据时一次就能传输32/8=4个字节。一个字长就是4字节。</p></li></ul><h5 id="2-1-3-寻址和字节顺序"><a href="#2-1-3-寻址和字节顺序" class="headerlink" title="2.1.3 寻址和字节顺序"></a>2.1.3 寻址和字节顺序</h5><ul><li>对于跨越多字节的程序对象，必须建立两个规则：① 这个对象的地址是什么，② 在内存上如何排列</li><li>多字节对象会被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。 </li></ul><p>排列表示一个对象的字节有两个通用规则：小端法 &amp; 大端法</p><p>低有效字节存储在低地址上，称为小端存储，反之则为大端存储。</p><p><img src="/image/image-20201023131136500.png" alt="image-20201023131136500"></p><p>C语言中字符串被编码为一个以null(其值为0)字符结尾的字符数组。</p><h5 id="2-1-6-布尔"><a href="#2-1-6-布尔" class="headerlink" title="2.1.6  布尔"></a>2.1.6  布尔</h5><ul><li><p>NOT: ~</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0000 0000 0000 0000 0000 0000 0000 1010</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token operator">~</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 1111 1111 1111 1111 1111 1111 1111 0101 补</span>                        <span class="token comment" spellcheck="true">// 1111 1111 1111 1111 1111 1111 1111 0100 反</span>                        <span class="token comment" spellcheck="true">// 1000 0000 0000 0000 0000 0000 0000 1011 原</span><span class="token punctuation">}</span></code></pre></li><li><p>AND: &amp;</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 0000 0000 0000 0000 0000 0000 0000 1010</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 0000 0000 0000 0000 0000 0000 0000 1111</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>a<span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0000 0000 0000 0000 0000 0000 0000 1010</span><span class="token punctuation">}</span></code></pre></li><li><p>OR: |</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 0000 0000 0000 0000 0000 0000 0000 0010</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 0000 0000 0000 0000 0000 0000 0000 1011</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>a<span class="token operator">|</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0000 0000 0000 0000 0000 0000 0000 1011</span><span class="token punctuation">}</span></code></pre></li><li><p>EXCLUSIVE-OR: ^</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 0000 0000 0000 0000 0000 0000 0000 1010</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 0000 0000 0000 0000 0000 0000 0000 0010</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>a<span class="token operator">^</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0000 0000 0000 0000 0000 0000 0000 1000</span><span class="token punctuation">}</span></code></pre></li></ul><h5 id="2-1-9-移位运算"><a href="#2-1-9-移位运算" class="headerlink" title="2.1.9 移位运算"></a>2.1.9 移位运算</h5><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 0000 0000 0000 0000 0000 0000 0000 1010</span>    a <span class="token operator">=</span>  a <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 0000 0000 0000 0000 0000 0000 0000 0001</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 1,无符号右移补0</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 原码: 1000 0000 0000 0000 0000 0000 0000 0101</span>    <span class="token comment" spellcheck="true">// 反码: 1111 1111 1111 1111 1111 1111 1111 1010</span>    <span class="token comment" spellcheck="true">// 补码: 1111 1111 1111 1111 1111 1111 1111 1011</span>    b <span class="token operator">=</span> b <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 补码: 1111 1111 1111 1111 1111 1111 1101 1000</span>    <span class="token comment" spellcheck="true">// 反码: 1111 1111 1111 1111 1111 1111 1101 0111</span>    <span class="token comment" spellcheck="true">// 原码: 1000 0000 0000 0000 0000 0000 0010 1000</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"b = %d\n"</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// -40</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 原码: 1000 0000 0000 0000 0000 0000 0000 0101</span>    <span class="token comment" spellcheck="true">// 反码: 1111 1111 1111 1111 1111 1111 1111 1010</span>    <span class="token comment" spellcheck="true">// 补码: 1111 1111 1111 1111 1111 1111 1111 1011</span>    c <span class="token operator">=</span> c <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 补码: 1111 1111 1111 1111 1111 1111 1111 1111</span>    <span class="token comment" spellcheck="true">// 反码: 1111 1111 1111 1111 1111 1111 1111 1110</span>    <span class="token comment" spellcheck="true">// 补码: 1000 0000 0000 0000 0000 0000 0000 0001</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"c = %d\n"</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// -1,有符号数右移时补符号位</span><span class="token punctuation">}</span></code></pre><h4 id="2-2-整数表示"><a href="#2-2-整数表示" class="headerlink" title="2.2 整数表示"></a>2.2 整数表示</h4>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟内存</title>
      <link href="2021/03/20/virtual_memory/"/>
      <url>2021/03/20/virtual_memory/</url>
      
        <content type="html"><![CDATA[<h3 id="第九章：虚拟内存"><a href="#第九章：虚拟内存" class="headerlink" title="第九章：虚拟内存"></a>第九章：虚拟内存</h3><h5 id="9-1-物理和虚拟寻址"><a href="#9-1-物理和虚拟寻址" class="headerlink" title="9.1 物理和虚拟寻址"></a>9.1 物理和虚拟寻址</h5><p>物理寻址：</p><p><img src="/Users/duwei/Desktop/source/image/image-20201023182237165.png" alt="image-20201023182237165"></p><p>该示例的上下文是一条加载指令。当cpu加载这条指令时，会生成一个有效物理地址，通过内存总线，把它传递给主存。主存取出从物理地址4开始的四个字节，并将它返回给cpu，cpu会将它存放在一个寄存器里。</p><p>虚拟寻址：</p><p><img src="/Users/duwei/Desktop/source/image/image-20201023182622615.png" alt="image-20201023182622615"></p><p>使用虚拟地址，cpu通过生成一个虚拟地址(Virtual Address,VA)来访问主存，这个虚拟地址在被送到主存之前先转换成适当的虚拟地址(Memory Manager Unit简称MMU：内存管理单元，利用存放在主存中的查询表来动态翻译虚拟地址)，主存收到翻译过的地址(物理地址)之后从物理内存上取出数据并返回给cpu。</p><h5 id="9-2-地址空间"><a href="#9-2-地址空间" class="headerlink" title="9.2 地址空间"></a>9.2 地址空间</h5><p>地址空间：一个非负整数地址的有序集合。为了简化讨论，总是假设使用的是线性地址空间。</p><p>在一个带虚拟内存的系统，CPU从一个有N=2^n个地址的空间中生成虚拟地址，称为虚拟地址空间。</p><p>{0, 1, 2, 3,…,N-1}</p><p>一个包含N=2^n个地址的虚拟地址空间叫做一个n位地址空间。例如32位操作系统(2^32)、64位操作系统(2^64)。</p><p>主存中的每个字节都有一个选自虚拟空间的地址和一个选自物理空间的地址。</p><table><thead><tr><th align="center">虚拟地址位数(n)</th><th align="center">虚拟地址数(N)</th><th align="center">最大的可能虚拟地址</th></tr></thead><tbody><tr><td align="center">8</td><td align="center">2^8=256 byte</td><td align="center">2^8-1=255</td></tr><tr><td align="center">16</td><td align="center">2^16=64 K</td><td align="center">2^16-1</td></tr><tr><td align="center">32</td><td align="center">2^32 = 4096M = 4G</td><td align="center">2^32-1</td></tr><tr><td align="center">48</td><td align="center">2^48 = 256T</td><td align="center">2^48-1</td></tr><tr><td align="center">64</td><td align="center">2^64 = 16E</td><td align="center">2^64-1</td></tr></tbody></table><h5 id="9-3-虚拟内存作为缓存工具"><a href="#9-3-虚拟内存作为缓存工具" class="headerlink" title="9.3 虚拟内存作为缓存工具"></a>9.3 虚拟内存作为缓存工具</h5><h6 id="1、什么是虚拟内存？"><a href="#1、什么是虚拟内存？" class="headerlink" title="1、什么是虚拟内存？"></a>1、什么是虚拟内存？</h6><p>虚拟内存是磁盘上(较低层)连续N个字节组成的数组，每个字节都有唯一的虚拟地址作为数组的索引，磁盘上数组的内容(指的是数据)被缓存在主存中。(虚拟页存在于磁盘上)</p><p>物理内存被分隔成物理页(Physical Page,PP)。</p><p>VM系统将虚拟内存分隔成虚拟页(Virtual Page,VP)。</p><p>虚拟页面的集合分为三个不相交的子集：</p><ol><li><p>未分配的(VM系统还未分配或者未创建的页，未分配的块没有任何数据和他们相关联，所以不占用任何磁盘空间，linux命令free在计算内存使用量时，未分配的 不会被记入)。</p></li><li><p>缓存的(已缓存在物理内存中的已分配页)。</p></li><li><p>未缓存的(未缓存在物理内存中的已分配页)。</p><p><img src="/image/image-20201026121811373.png" alt="image-20201026121811373"></p></li></ol><h6 id="2、DRAM缓存组织结构"><a href="#2、DRAM缓存组织结构" class="headerlink" title="2、DRAM缓存组织结构"></a>2、DRAM缓存组织结构</h6><ul><li>SRAM：表示位于cpu和主存之间的L1、L2、L3高速缓存。</li><li>DRAM：表示虚拟内存系统的缓存，它在主存中缓存虚拟页。</li><li>直   写：当 CPU 要将数据写入内存时 除了更新缓冲内存(高速缓存L1、L2、L3)上的数据外也将数据写在 DRAM 中 以维持主存与缓冲内存的一致性 当要写入内存的数据一多 速度自然就慢了下来 </li><li>回   写：每当 CPU 要将数据写入内存时 只会先更新缓冲内存(高速缓存L1、L2、L3)上的数据 随后再让缓冲内存在总线不塞车的时候 才把数据写回 DRAM 所以速度自然快得多</li></ul><h6 id="3、页表-将虚拟页映射到物理页"><a href="#3、页表-将虚拟页映射到物理页" class="headerlink" title="3、页表(将虚拟页映射到物理页)"></a>3、页表(将虚拟页映射到物理页)</h6><p>虚拟内存必须有某种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页(主存)。如果不命中还必须判断这个虚拟页存放在磁盘的哪个位置上，在物理页中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页。(操作系统为每个进程都维护一个独立的页表)</p><p>页表：将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表，操作系统负责维护页表的内容，以及在磁盘与DRAM之间来回传送页。</p><p><img src="/image/image-20201020134441586.png" alt="image-20201020134441586"></p><p>我们将假设每个PTE是由一个有效位(valid bit)和一个n位地址字段组成，有效位表明了该虚拟页当前是否被缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。 如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。否则，这个地址就指向该虚拟页在磁盘上的起始位置。</p><ul><li><p>确定虚拟地址大小(n)和页大小(P)的组合需要的PTE数量。</p><table><thead><tr><th align="center">n(位)</th><th align="center">P=2^p</th><th align="center">PTE数量</th></tr></thead><tbody><tr><td align="center">16</td><td align="center">4K</td><td align="center">2^16 / 2^12  = 16</td></tr><tr><td align="center">16</td><td align="center">8K</td><td align="center">2^16 / 2^13 = 8</td></tr><tr><td align="center">32</td><td align="center">4K</td><td align="center">2^32 / 2^12 = 2^20</td></tr><tr><td align="center">32</td><td align="center">8K</td><td align="center">2^32 / 2^13 = 2^19</td></tr></tbody></table></li></ul><h6 id="4、缺页"><a href="#4、缺页" class="headerlink" title="4、缺页"></a>4、缺页</h6><p>DRAM缓存不命中称为缺页。</p><p>自己的理解：在cpu获取虚拟页中的数据时，地址翻译硬件去读页表的页表记录的有效位，如果有效位为0则推断出该虚拟页未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会在主存的PP(物理页)中选择一个被缓存的VP作为牺牲页(如果牺牲页中的数据被修改过那么就会将数据写会磁盘)，接下来将要被缓存的vp从磁盘中加载出来缓存到主存上去(替换牺牲页)。</p><ul><li><p>CPU引用VP3中的一个字，地址翻译硬件将虚拟地址作为一个索引(虚拟地址分为两部分：虚拟页号[VPN:virtual page number]和虚拟页偏移量[VPO:virtual page offset]，使用虚拟页号作为索引)来定位PTE3，通过读取PTE3：有效为为0且地址不为null，所以得出VP3没有被缓存在物理内存中且得到了VP3的磁盘地址，此时触发缺页异常，缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页(PP3中的VP4，如果VP4的内容被修改了，那么内核就会将VP4的数据复制回磁盘)，无论哪种情况，内核都会修改VP4的页表条目，反映VP4不在缓存在主存中的事实。</p><p><img src="/image/image-20201020140133328.png" alt="image-20201020140133328"></p></li><li><p>随后，内核从磁盘复制VP3到内存PP3，并更新PTE3(将有效为设置为1，地址位设置为物理页号)，随后返回，当异常处理程序返回的时候，它会重启导致缺页的指令，该指令会把缺页的虚拟地址重新发送给地址翻译硬件，但是此时VP3已经缓存在物理内存中了，那么页命中就能由地址翻译硬件正常处理了。</p><p><img src="/image/image-20201026140413910.png" alt="image-20201026140413910"></p></li></ul><p>5、分配页面</p><ul><li><p>操作系统分配一个新的虚拟内存页时对页表的影响，例如：调用mallooc，在这个实例中，VP5的分配过程是在磁盘创建空间并更新PTE5，并使它指向磁盘上这个新创建的页面。此过程中并没有分配物理内存哦。</p><p><img src="/image/image-20201026141028175.png" alt="image-20201026141028175"></p></li></ul><hr><h5 id="9-6-地址翻译"><a href="#9-6-地址翻译" class="headerlink" title="9.6 地址翻译"></a>9.6 地址翻译</h5><ul><li><p>地址翻译符号</p><p><img src="/image/image-20201026153155106.png" alt="image-20201026153155106"></p></li><li><p>MMU利用虚拟地址包含的VPN寻找PTE，将页表条目中的PPN和VPO串联起来就得到响应的物理地址(因为vp和pp都是P字节，所以物理页和虚拟页的偏移量相同)</p><p><img src="/image/image-20201026153233283.png" alt="image-20201026153233283"></p></li></ul><p>当页面命中时，CPU硬件执行的步骤：</p><ol><li>处理器生成一个虚拟地址，并把它传送给MMU。</li><li>MMU生成PTE地址，并从高速缓存/主存请求得到它。</li><li>高速缓存/主存向MMU返回PTE。</li><li>MMU构造物理地址，并把它传给告诉缓存/主存。</li><li>高速缓存/主存返回所请求的数据字给处理器。</li></ol><p><img src="/image/image-20201020145055727.png" alt="image-20201020145055727"></p><p>缺页，CPU硬件执行步骤：</p><ol><li>处理器生成一个虚拟地址，并把它传送给MMU。</li><li>MMU生成PTE地址，并从高速缓存/主存请求得到它。</li><li>高速缓存/主存向MMU返回PTE。</li><li>PTE中的有效为是0，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。</li><li>缺页处理程序确定出物理内存中的牺牲页，如果这个页面修改了则把它换出到磁盘。</li><li>缺页处理程序页面调入新的页面，并更新内存中的PTE。</li><li>缺页处理程序返回到原来的进程，再次执行导致缺页的指令，CPU将引起缺页的虚拟地址重新发送给MMU。</li></ol><p><img src="/image/image-20201020145822292.png" alt="image-20201020145822292"></p><ul><li><p>给定一个32位的虚拟地址空间和一个24位的物理地址，对于下列页面大小P。</p><table><thead><tr><th align="center">P</th><th align="center">VPN位数</th><th align="center">VPO位数</th><th align="center">PPN位数</th><th align="center">PPO位数</th></tr></thead><tbody><tr><td align="center">1KB (2^p=1024,p=10)</td><td align="center">22</td><td align="center">10</td><td align="center">14</td><td align="center">10</td></tr><tr><td align="center">2KB(2^p=2048,p=11)</td><td align="center">21</td><td align="center">11</td><td align="center">13</td><td align="center">11</td></tr><tr><td align="center">4KB(2^p=4096,p=12)</td><td align="center">20</td><td align="center">12</td><td align="center">12</td><td align="center">12</td></tr><tr><td align="center">8KB(2^p=8192,p=13)</td><td align="center">19</td><td align="center">13</td><td align="center">11</td><td align="center">13</td></tr></tbody></table><p>(常说的32位和64位操作系统，指的就是页表条目PTE的长度。)</p></li></ul><h6 id="1、多级页表"><a href="#1、多级页表" class="headerlink" title="1、多级页表"></a>1、多级页表</h6><p>到目前为止，一直假设系统只用一个单独的页表进行地址翻译。但是如果我们有一个32位地址空间、4kb的页和一个4字节的PTE，那么即使应用所引用的只是虚拟空间中很小的一部分，也总是需要4MB的页表驻留内存。(32位地址空间，总共有2^32个内存地址，一个虚拟页的大小是4KB，那么总共有 2^32/2^12=2^20 个内存页，一个内存页需要一个PTE，一个PTE是4字节，那么页表总共大小是：2^20 * 2^12 = 2^32字节 = 2^32 / 2^10 KB = 2^12 / 2^10 MB = 4MB。在没有优化的情况下，一张独立页表在内存中要占用4M物理内存)</p><hr><h6 id="计算机中的字，双字以及存储"><a href="#计算机中的字，双字以及存储" class="headerlink" title="计算机中的字，双字以及存储"></a>计算机中的字，双字以及存储</h6><ul><li>字节(byte)：一个字节由8位二进制数组成</li><li>字(word)：</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx缓冲区</title>
      <link href="2021/03/18/ngx_buf/"/>
      <url>2021/03/18/ngx_buf/</url>
      
        <content type="html"><![CDATA[<h4 id="nginx缓冲区"><a href="#nginx缓冲区" class="headerlink" title="nginx缓冲区"></a>nginx缓冲区</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> ngx_buf_s <span class="token punctuation">{</span>    u_char          <span class="token operator">*</span>pos<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/* 待处理数据的开始标记  */</span>    u_char          <span class="token operator">*</span>last<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* 待处理数据的结尾标记 */</span>    off_t            file_pos<span class="token punctuation">;</span>    off_t            file_last<span class="token punctuation">;</span>    u_char          <span class="token operator">*</span>start<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* start of buffer */</span>    u_char          <span class="token operator">*</span>end<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/* end of buffer */</span>    ngx_buf_tag_t    tag<span class="token punctuation">;</span>    ngx_file_t      <span class="token operator">*</span>file<span class="token punctuation">;</span>    ngx_buf_t       <span class="token operator">*</span>shadow<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* the buf's content could be changed */</span>    <span class="token keyword">unsigned</span>         temporary<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 标志位，为1时，内存可修改 */</span>    <span class="token comment" spellcheck="true">/*     * the buf's content is in a memory cache or in a read only memory     * and must not be changed     */</span>    <span class="token keyword">unsigned</span>         memory<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* the buf's content is mmap()ed and must not be changed */</span>    <span class="token keyword">unsigned</span>         mmap<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span>         recycled<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span>         in_file<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span>         flush<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span>         sync<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span>         last_buf<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span>         last_in_chain<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span>         last_shadow<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span>         temp_file<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* STUB */</span> <span class="token keyword">int</span>   num<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓冲区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx内存池</title>
      <link href="2021/03/18/ngx_mem_pool/"/>
      <url>2021/03/18/ngx_mem_pool/</url>
      
        <content type="html"><![CDATA[<h4 id="nginx内存池"><a href="#nginx内存池" class="headerlink" title="nginx内存池"></a>nginx内存池</h4><h5 id=""><a href="#" class="headerlink" title=""></a><img src="http://img.3amupupup.online/ngx_mem_pool_struct_3.png" alt="内存池结构"></h5><p><img src="https://img.3amupupup.online/ngx_mem_pool_5.png" alt="内存池结构"></p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    u_char               <span class="token operator">*</span>last<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 内存池中未使用内存的开始节点地址 */</span>    u_char               <span class="token operator">*</span>end<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* 内存池的结束地址 */</span>    ngx_pool_t           <span class="token operator">*</span>next<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 指向下一个内存池,组成链表 */</span>    ngx_uint_t            failed<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 失败次数 */</span><span class="token punctuation">}</span> ngx_pool_data_t<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// typedef struct ngx_pool_s ngx_pool_t;</span><span class="token keyword">struct</span> ngx_pool_s <span class="token punctuation">{</span>    ngx_pool_data_t       d<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 内存池的数据区域(小块数据) */</span>    size_t                max<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* 最大每次可分配内存,大于这个值将被添加到大块数据链表上,小于这个值将被添加到小块数据链表上 */</span>    ngx_pool_t           <span class="token operator">*</span>current<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 指向当前的内存池指针地址。ngx_pool_t链表上最后一个缓存池结构 */</span>    ngx_chain_t          <span class="token operator">*</span>chain<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 缓冲区链表 */</span>    ngx_pool_large_t     <span class="token operator">*</span>large<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 存储大块数据的链表 */</span>    ngx_pool_cleanup_t   <span class="token operator">*</span>cleanup<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 可自定义回调函数，清除内存块分配的内存 */</span>    ngx_log_t            <span class="token operator">*</span>log<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* 日志 */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// typedef struct ngx_pool_cleanup_s  ngx_pool_cleanup_t;</span><span class="token keyword">struct</span> ngx_pool_cleanup_s <span class="token punctuation">{</span>    ngx_pool_cleanup_pt   handler<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 清理的回调函数 */</span>    <span class="token keyword">void</span>                 <span class="token operator">*</span>data<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 指向存储的数据地址 */</span>    ngx_pool_cleanup_t   <span class="token operator">*</span>next<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 下一个ngx_pool_cleanup_t */</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><ol><li><p>ngx_calloc: 分配内存并初始化，底层调用的是malloc和memset。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">ngx_calloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> ngx_log_t <span class="token operator">*</span>log<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">void</span>  <span class="token operator">*</span>p<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">ngx_alloc</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> log<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_memzero</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/*              ngx_memzero是个宏函数，底层实际调用memset，src/core/ngx_string.h              #define ngx_memzero(buf, n)       (void) memset(buf, 0, n)          */</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><ol start="2"><li><p>ngx_alloc: 分配内存，底层调用的是malloc。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span>   <span class="token function">ngx_alloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> ngx_log_t <span class="token operator">*</span>log<span class="token punctuation">)</span>   <span class="token punctuation">{</span>       <span class="token keyword">void</span>  <span class="token operator">*</span>p<span class="token punctuation">;</span>       p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/*              底层去调用malloc分配内存         */</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token function">ngx_log_error</span><span class="token punctuation">(</span>NGX_LOG_EMERG<span class="token punctuation">,</span> log<span class="token punctuation">,</span> ngx_errno<span class="token punctuation">,</span>                         <span class="token string">"malloc(%uz) failed"</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token function">ngx_log_debug2</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_ALLOC<span class="token punctuation">,</span> log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"malloc: %p:%uz"</span><span class="token punctuation">,</span> p<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> p<span class="token punctuation">;</span>   <span class="token punctuation">}</span></code></pre></li><li><p>ngx_create_pool: 创建内存池结点</p><pre class=" language-c"><code class="language-c">ngx_pool_t <span class="token operator">*</span><span class="token function">ngx_create_pool</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> ngx_log_t <span class="token operator">*</span>log<span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_pool_t  <span class="token operator">*</span>p<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">ngx_memalign</span><span class="token punctuation">(</span>NGX_POOL_ALIGNMENT<span class="token punctuation">,</span> size<span class="token punctuation">,</span> log<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          #define ngx_memalign(alignment, size, log)  ngx_alloc(size, log)，          而ngx_alloc实际上是去调用malloc      */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    p<span class="token operator">-></span>d<span class="token punctuation">.</span>last <span class="token operator">=</span> <span class="token punctuation">(</span>u_char <span class="token operator">*</span><span class="token punctuation">)</span> p <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ngx_pool_t<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          p是通过malloc申请得到的内存的首地址，前sizeof(ngx_pool_t)字节的内存要留给内存池的管理结构(我也叫他控制中心)，          控制中心之后的内存是给申请者使用的。last是申请者能够使用内存的起始位置，end是结束位置(由数据结构得知)      */</span>    p<span class="token operator">-></span>d<span class="token punctuation">.</span>end <span class="token operator">=</span> <span class="token punctuation">(</span>u_char <span class="token operator">*</span><span class="token punctuation">)</span> p <span class="token operator">+</span> size<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          end指向申请得到的内存的末尾位置，          p是首地址，加上size就是结束地址即end的指向位置，          内存的申请者总共申请了size个字节的内存，能够使用的内存为：size - sizeof(ngx_pool_t)      */</span>    p<span class="token operator">-></span>d<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          内存池通过指针相连，组成一个链表，下一个结点在创建时应当指向NULL      */</span>    p<span class="token operator">-></span>d<span class="token punctuation">.</span>failed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    size <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ngx_pool_t<span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token operator">-></span>max <span class="token operator">=</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> NGX_MAX_ALLOC_FROM_POOL<span class="token punctuation">)</span> <span class="token operator">?</span> size <span class="token punctuation">:</span> NGX_MAX_ALLOC_FROM_POOL<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*     NGX_MAX_ALLOC_FROM_POOL should be (ngx_pagesize - 1), i.e. 4095 on x86.     On Windows NT it decreases a number of locked pages in a kernel.     max取size和操作系统弄内存页二者中较小的值     */</span>    p<span class="token operator">-></span>current <span class="token operator">=</span> p<span class="token punctuation">;</span>    p<span class="token operator">-></span>chain <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    p<span class="token operator">-></span>large <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    p<span class="token operator">-></span>cleanup <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    p<span class="token operator">-></span>log <span class="token operator">=</span> log<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          只有缓存池的父节点，才会用到这几个成员  ，子节点只挂载在p->d.next,并且只负责p->d的数据内容      */</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>ngx_destroy_pool: 销毁内存池结点</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span><span class="token function">ngx_destroy_pool</span><span class="token punctuation">(</span>ngx_pool_t <span class="token operator">*</span>pool<span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_pool_t          <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token operator">*</span>n<span class="token punctuation">;</span>    ngx_pool_large_t    <span class="token operator">*</span>l<span class="token punctuation">;</span>    ngx_pool_cleanup_t  <span class="token operator">*</span>c<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>c <span class="token operator">=</span> pool<span class="token operator">-></span>cleanup<span class="token punctuation">;</span> c<span class="token punctuation">;</span> c <span class="token operator">=</span> c<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ngx_log_debug1</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_ALLOC<span class="token punctuation">,</span> pool<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                           <span class="token string">"run cleanup: %p"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>            c<span class="token operator">-></span><span class="token function">handler</span><span class="token punctuation">(</span>c<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">/*          只有父结点才有cleanup链表，          cleanup链表的结点结构有三个成员：清理函数handler、指向存储数据的data、指向下一个结点的next          这里遍历cleanup链表，调用handler清理data      */</span><span class="token macro property">#<span class="token directive keyword">if</span> (NGX_DEBUG)    </span><span class="token comment" spellcheck="true">// 编译debug级别，如果为true，会打印日志</span>    <span class="token comment" spellcheck="true">/*     * we could allocate the pool->log from this pool     * so we cannot use this log while free()ing the pool     */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>l <span class="token operator">=</span> pool<span class="token operator">-></span>large<span class="token punctuation">;</span> l<span class="token punctuation">;</span> l <span class="token operator">=</span> l<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_log_debug1</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_ALLOC<span class="token punctuation">,</span> pool<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"free: %p"</span><span class="token punctuation">,</span> l<span class="token operator">-></span>alloc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> pool<span class="token punctuation">,</span> n <span class="token operator">=</span> pool<span class="token operator">-></span>d<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* void */</span><span class="token punctuation">;</span> p <span class="token operator">=</span> n<span class="token punctuation">,</span> n <span class="token operator">=</span> n<span class="token operator">-></span>d<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_log_debug2</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_ALLOC<span class="token punctuation">,</span> pool<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                       <span class="token string">"free: %p, unused: %uz"</span><span class="token punctuation">,</span> p<span class="token punctuation">,</span> p<span class="token operator">-></span>d<span class="token punctuation">.</span>end <span class="token operator">-</span> p<span class="token operator">-></span>d<span class="token punctuation">.</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>l <span class="token operator">=</span> pool<span class="token operator">-></span>large<span class="token punctuation">;</span> l<span class="token punctuation">;</span> l <span class="token operator">=</span> l<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token operator">-></span>alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ngx_free</span><span class="token punctuation">(</span>l<span class="token operator">-></span>alloc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">/*          只有父结点才有large链表，          遍历large(大块数据链表)链表，释放alloc指针指向的存储数据的内存          #define ngx_free          free          由此可知ngx_free是个宏，底层调用的还是free，这里直接将大块数据内存还给了操作系统      */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> pool<span class="token punctuation">,</span> n <span class="token operator">=</span> pool<span class="token operator">-></span>d<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* void */</span><span class="token punctuation">;</span> p <span class="token operator">=</span> n<span class="token punctuation">,</span> n <span class="token operator">=</span> n<span class="token operator">-></span>d<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/*              至此，父结点上的large链表以及cleanup链表都被清理了，然后循环清理内存池结点，              小块数据内存是分配在内存池结点上的，和其控制中心(ngx_pool_t)是连续的，              释放时直接释放当前结点就行了          */</span>          <span class="token comment" spellcheck="true">/*              至此清理工作结束。              但是有个小疑问：chain(缓冲区)链表为啥没有被清理？          */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>ngx_reset_pool: 清理内存池结点</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span><span class="token function">ngx_reset_pool</span><span class="token punctuation">(</span>ngx_pool_t <span class="token operator">*</span>pool<span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_pool_t        <span class="token operator">*</span>p<span class="token punctuation">;</span>    ngx_pool_large_t  <span class="token operator">*</span>l<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>l <span class="token operator">=</span> pool<span class="token operator">-></span>large<span class="token punctuation">;</span> l<span class="token punctuation">;</span> l <span class="token operator">=</span> l<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token operator">-></span>alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ngx_free</span><span class="token punctuation">(</span>l<span class="token operator">-></span>alloc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">/*          清理large链表      */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> pool<span class="token punctuation">;</span> p<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token operator">-></span>d<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p<span class="token operator">-></span>d<span class="token punctuation">.</span>last <span class="token operator">=</span> <span class="token punctuation">(</span>u_char <span class="token operator">*</span><span class="token punctuation">)</span> p <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ngx_pool_t<span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token operator">-></span>d<span class="token punctuation">.</span>failed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">/*          重置小数据块区域的内存，注意这里是修改last的指向，将last重新指向起始位置，          内存并没有被擦除，因为是小数据块内存，这里没有将其归还给操作系统，          目的是避免频繁的malloc和free产生内存碎片问题，频繁调用这两个函数也会给          操作系统带来额外的消耗。      */</span>    pool<span class="token operator">-></span>current <span class="token operator">=</span> pool<span class="token punctuation">;</span>    pool<span class="token operator">-></span>chain <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    pool<span class="token operator">-></span>large <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>ngx_palloc: 向内存池申请内存的函数</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">ngx_palloc</span><span class="token punctuation">(</span>ngx_pool_t <span class="token operator">*</span>pool<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">if</span> !(NGX_DEBUG_PALLOC)</span>      <span class="token comment" spellcheck="true">/*          这里是个条件编译，如果没开启ngx palloc debug就会根据size决定调用ngx_palloc_small还是                              ngx_palloc_large，如果开启了debug则一律调用ngx_palloc_large      */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> pool<span class="token operator">-></span>max<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">ngx_palloc_small</span><span class="token punctuation">(</span>pool<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token keyword">return</span> <span class="token function">ngx_palloc_large</span><span class="token punctuation">(</span>pool<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>ngx_palloc_small: 分配小块数据内存的函数，调用这个函数所分配的内存都是在内存池结点上</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> ngx_inline <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">ngx_palloc_small</span><span class="token punctuation">(</span>ngx_pool_t <span class="token operator">*</span>pool<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> ngx_uint_t align<span class="token punctuation">)</span><span class="token punctuation">{</span>    u_char      <span class="token operator">*</span>m<span class="token punctuation">;</span>    ngx_pool_t  <span class="token operator">*</span>p<span class="token punctuation">;</span>    p <span class="token operator">=</span> pool<span class="token operator">-></span>current<span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        m <span class="token operator">=</span> p<span class="token operator">-></span>d<span class="token punctuation">.</span>last<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/*              m保存了last的指向，last &lt;-> end 之间是未被使用的内存          */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>align<span class="token punctuation">)</span> <span class="token punctuation">{</span>            m <span class="token operator">=</span> <span class="token function">ngx_align_ptr</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> NGX_ALIGNMENT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">/*              align，暂时不懂是啥意思          */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>d<span class="token punctuation">.</span>end <span class="token operator">-</span> m<span class="token punctuation">)</span> <span class="token operator">>=</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            p<span class="token operator">-></span>d<span class="token punctuation">.</span>last <span class="token operator">=</span> m <span class="token operator">+</span> size<span class="token punctuation">;</span>            <span class="token keyword">return</span> m<span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">/*              如果end到m(即last)之间的字节数大于size，那么这个内存池结点上的足够申请者使用，              则将last后移size个字节并返回之前last的指向的内存的地址供调用者使用          */</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>d<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">ngx_palloc_block</span><span class="token punctuation">(</span>pool<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          走到这里说明内存池的所有结点上都没有足够的空间分配出去，          此时则调用ngx_palloc_block新开一个内存池的节点(扩容)      */</span><span class="token punctuation">}</span></code></pre></li><li><p>ngx_palloc_large: 分配大块数据内存的函数，调用这个函数所分配的内存都是在large链表上</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">ngx_palloc_large</span><span class="token punctuation">(</span>ngx_pool_t <span class="token operator">*</span>pool<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">void</span>              <span class="token operator">*</span>p<span class="token punctuation">;</span>    ngx_uint_t         n<span class="token punctuation">;</span>    ngx_pool_large_t  <span class="token operator">*</span>large<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">ngx_alloc</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> pool<span class="token operator">-></span>log<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          底层调用malloc分配内存      */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>large <span class="token operator">=</span> pool<span class="token operator">-></span>large<span class="token punctuation">;</span> large<span class="token punctuation">;</span> large <span class="token operator">=</span> large<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>large<span class="token operator">-></span>alloc <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            large<span class="token operator">-></span>alloc <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token keyword">return</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">/*              遍历large链表，寻找空闲结点，找到了则将large链表上的空闲结点的alloc指向刚刚申请的内存p          */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">++</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">/*              如果找了三次还没找到那就不找了，避免链表过长时查找效率低          */</span>    <span class="token punctuation">}</span>    large <span class="token operator">=</span> <span class="token function">ngx_palloc_small</span><span class="token punctuation">(</span>pool<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ngx_pool_large_t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          在内存池结点的小块数据内存上给large的控制中心结构ngx_pool_large_t分配一块内存      */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>large <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/*              如果large分配失败p是要释放的，避免内存泄露          */</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    large<span class="token operator">-></span>alloc <span class="token operator">=</span> p<span class="token punctuation">;</span>    large<span class="token operator">-></span>next <span class="token operator">=</span> pool<span class="token operator">-></span>large<span class="token punctuation">;</span>    pool<span class="token operator">-></span>large <span class="token operator">=</span> large<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          新开的large结点变为large链表的头结点。      */</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>ngx_palloc_block: 添加新的内存池结点</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">ngx_palloc_block</span><span class="token punctuation">(</span>ngx_pool_t <span class="token operator">*</span>pool<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    u_char      <span class="token operator">*</span>m<span class="token punctuation">;</span>    size_t       psize<span class="token punctuation">;</span>    ngx_pool_t  <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token operator">*</span>new<span class="token punctuation">;</span>    psize <span class="token operator">=</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span> <span class="token punctuation">(</span>pool<span class="token operator">-></span>d<span class="token punctuation">.</span>end <span class="token operator">-</span> <span class="token punctuation">(</span>u_char <span class="token operator">*</span><span class="token punctuation">)</span> pool<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          要新创建的内存池的结点的size是根据头结点的size创建的      */</span>    m <span class="token operator">=</span> <span class="token function">ngx_memalign</span><span class="token punctuation">(</span>NGX_POOL_ALIGNMENT<span class="token punctuation">,</span> psize<span class="token punctuation">,</span> pool<span class="token operator">-></span>log<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          申请psize大小的内存块      */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    new <span class="token operator">=</span> <span class="token punctuation">(</span>ngx_pool_t <span class="token operator">*</span><span class="token punctuation">)</span> m<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          类型转换      */</span>    new<span class="token operator">-></span>d<span class="token punctuation">.</span>end <span class="token operator">=</span> m <span class="token operator">+</span> psize<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          end指向末尾      */</span>    new<span class="token operator">-></span>d<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          下一个结点指针 指向NULL避免野指针      */</span>    new<span class="token operator">-></span>d<span class="token punctuation">.</span>failed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    m <span class="token operator">+</span><span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ngx_pool_data_t<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          前sizeof(ngx_pool_data_t)个字节留给ngx_pool_data_t结构使用，          这里用的比较巧妙，细品细品，此时有点惊叹设计者的做法。          因为创建的是子节点，所以max、current指针、缓冲区链表指针、large链表指针、          cleanup链表指针，这几个成员所占的内存都可以分配出去给调用者使用(子结点用不到这几个成员)，          避免了空间浪费。      */</span>    m <span class="token operator">=</span> <span class="token function">ngx_align_ptr</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> NGX_ALIGNMENT<span class="token punctuation">)</span><span class="token punctuation">;</span>    new<span class="token operator">-></span>d<span class="token punctuation">.</span>last <span class="token operator">=</span> m <span class="token operator">+</span> size<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          移动last size个字节，标识这段内存已经被分配出去了      */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> pool<span class="token operator">-></span>current<span class="token punctuation">;</span> p<span class="token operator">-></span>d<span class="token punctuation">.</span>next<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token operator">-></span>d<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>d<span class="token punctuation">.</span>failed<span class="token operator">++</span> <span class="token operator">></span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pool<span class="token operator">-></span>current <span class="token operator">=</span> p<span class="token operator">-></span>d<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">/*          每遍历一个结点failed++，当failed超过了4时，current会指向新子结点，          这么做可以避免遍历整个链表(如果链表足够长，遍历一次效率比较低)      */</span>    p<span class="token operator">-></span>d<span class="token punctuation">.</span>next <span class="token operator">=</span> new<span class="token punctuation">;</span>    <span class="token keyword">return</span> m<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>ngx_pnalloc: 开辟内存的函数，根据size去调用不同的函数</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">ngx_pnalloc</span><span class="token punctuation">(</span>ngx_pool_t <span class="token operator">*</span>pool<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">if</span> !(NGX_DEBUG_PALLOC)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> pool<span class="token operator">-></span>max<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">ngx_palloc_small</span><span class="token punctuation">(</span>pool<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token keyword">return</span> <span class="token function">ngx_palloc_large</span><span class="token punctuation">(</span>pool<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>ngx_pcalloc: 申请一块内存并初始化为0值</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">ngx_pcalloc</span><span class="token punctuation">(</span>ngx_pool_t <span class="token operator">*</span>pool<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">ngx_palloc</span><span class="token punctuation">(</span>pool<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_memzero</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>ngx_pmemalign:</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">ngx_pmemalign</span><span class="token punctuation">(</span>ngx_pool_t <span class="token operator">*</span>pool<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> size_t alignment<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">void</span>              <span class="token operator">*</span>p<span class="token punctuation">;</span>    ngx_pool_large_t  <span class="token operator">*</span>large<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">ngx_memalign</span><span class="token punctuation">(</span>alignment<span class="token punctuation">,</span> size<span class="token punctuation">,</span> pool<span class="token operator">-></span>log<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    large <span class="token operator">=</span> <span class="token function">ngx_palloc_small</span><span class="token punctuation">(</span>pool<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ngx_pool_large_t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>large <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    large<span class="token operator">-></span>alloc <span class="token operator">=</span> p<span class="token punctuation">;</span>    large<span class="token operator">-></span>next <span class="token operator">=</span> pool<span class="token operator">-></span>large<span class="token punctuation">;</span>    pool<span class="token operator">-></span>large <span class="token operator">=</span> large<span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>ngx_pfree: 释放large链表上的内存p</p><pre class=" language-c"><code class="language-c">ngx_int_t<span class="token function">ngx_pfree</span><span class="token punctuation">(</span>ngx_pool_t <span class="token operator">*</span>pool<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_pool_large_t  <span class="token operator">*</span>l<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>l <span class="token operator">=</span> pool<span class="token operator">-></span>large<span class="token punctuation">;</span> l<span class="token punctuation">;</span> l <span class="token operator">=</span> l<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> l<span class="token operator">-></span>alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">/*                  遍历large链表，查找p所在的节点，如果large链表足够长时，这个函数的效率偏低              */</span>            <span class="token function">ngx_log_debug1</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_ALLOC<span class="token punctuation">,</span> pool<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                           <span class="token string">"free: %p"</span><span class="token punctuation">,</span> l<span class="token operator">-></span>alloc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">ngx_free</span><span class="token punctuation">(</span>l<span class="token operator">-></span>alloc<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">/*                  实际调用的还是free              */</span>            l<span class="token operator">-></span>alloc <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> NGX_OK<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> NGX_DECLINED<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>ngx_pool_cleanup_add: cleanup机制设计的比较灵活，pool-&gt;cleanup是一个链表，每个ngx_pool_cleanup_t的数据结构上保存这指向的内存地址和回调清理函数，通过这个机制可以很方便的管理一些特殊的内存类型，比如文件描述符、自定义类型。</p><pre class=" language-c"><code class="language-c">ngx_pool_cleanup_t <span class="token operator">*</span><span class="token function">ngx_pool_cleanup_add</span><span class="token punctuation">(</span>ngx_pool_t <span class="token operator">*</span>p<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_pool_cleanup_t  <span class="token operator">*</span>c<span class="token punctuation">;</span>    c <span class="token operator">=</span> <span class="token function">ngx_palloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ngx_pool_cleanup_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          给cleanup的控制中心结构分配内存，分配在内存池小块数据内存上的。      */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        c<span class="token operator">-></span>data <span class="token operator">=</span> <span class="token function">ngx_palloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>data <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        c<span class="token operator">-></span>data <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">/*          根据size决定是否分配数据区，数据区分配的内存在哪据size的大小而定，          可能在小数据块内存上也可能在large链表上      */</span>    c<span class="token operator">-></span>handler <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    c<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>cleanup<span class="token punctuation">;</span>    p<span class="token operator">-></span>cleanup <span class="token operator">=</span> c<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          头插进cleanup链表      */</span>    <span class="token function">ngx_log_debug1</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_ALLOC<span class="token punctuation">,</span> p<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"add cleanup: %p"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol><li>ngx_pool_run_cleanup_file: 清理cleanup链表上的文件描述符fd，时间复杂度O(n)，链表过长时效率偏低</li></ol><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span><span class="token function">ngx_pool_run_cleanup_file</span><span class="token punctuation">(</span>ngx_pool_t <span class="token operator">*</span>p<span class="token punctuation">,</span> ngx_fd_t fd<span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_pool_cleanup_t       <span class="token operator">*</span>c<span class="token punctuation">;</span>    ngx_pool_cleanup_file_t  <span class="token operator">*</span>cf<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>c <span class="token operator">=</span> p<span class="token operator">-></span>cleanup<span class="token punctuation">;</span> c<span class="token punctuation">;</span> c <span class="token operator">=</span> c<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>handler <span class="token operator">==</span> ngx_pool_cleanup_file<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cf <span class="token operator">=</span> c<span class="token operator">-></span>data<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cf<span class="token operator">-></span>fd <span class="token operator">==</span> fd<span class="token punctuation">)</span> <span class="token punctuation">{</span>                c<span class="token operator">-></span><span class="token function">handler</span><span class="token punctuation">(</span>cf<span class="token punctuation">)</span><span class="token punctuation">;</span>                c<span class="token operator">-></span>handler <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol><li>ngx_pool_cleanup_file: 关闭文件回调函数</li></ol><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span><span class="token function">ngx_pool_cleanup_file</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_pool_cleanup_file_t  <span class="token operator">*</span>c <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token function">ngx_log_debug1</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_ALLOC<span class="token punctuation">,</span> c<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"file cleanup: fd:%d"</span><span class="token punctuation">,</span>                   c<span class="token operator">-></span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_close_file</span><span class="token punctuation">(</span>c<span class="token operator">-></span>fd<span class="token punctuation">)</span> <span class="token operator">==</span> NGX_FILE_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_log_error</span><span class="token punctuation">(</span>NGX_LOG_ALERT<span class="token punctuation">,</span> c<span class="token operator">-></span>log<span class="token punctuation">,</span> ngx_errno<span class="token punctuation">,</span>                      ngx_close_file_n <span class="token string">" \"%s\" failed"</span><span class="token punctuation">,</span> c<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>ngx_pool_delete_file: 删除文件回调函数</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span><span class="token function">ngx_pool_delete_file</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_pool_cleanup_file_t  <span class="token operator">*</span>c <span class="token operator">=</span> data<span class="token punctuation">;</span>    ngx_err_t  err<span class="token punctuation">;</span>    <span class="token function">ngx_log_debug2</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_ALLOC<span class="token punctuation">,</span> c<span class="token operator">-></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"file cleanup: fd:%d %s"</span><span class="token punctuation">,</span>                   c<span class="token operator">-></span>fd<span class="token punctuation">,</span> c<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_delete_file</span><span class="token punctuation">(</span>c<span class="token operator">-></span>name<span class="token punctuation">)</span> <span class="token operator">==</span> NGX_FILE_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>        err <span class="token operator">=</span> ngx_errno<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">!=</span> NGX_ENOENT<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ngx_log_error</span><span class="token punctuation">(</span>NGX_LOG_CRIT<span class="token punctuation">,</span> c<span class="token operator">-></span>log<span class="token punctuation">,</span> err<span class="token punctuation">,</span>                          ngx_delete_file_n <span class="token string">" \"%s\" failed"</span><span class="token punctuation">,</span> c<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_close_file</span><span class="token punctuation">(</span>c<span class="token operator">-></span>fd<span class="token punctuation">)</span> <span class="token operator">==</span> NGX_FILE_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_log_error</span><span class="token punctuation">(</span>NGX_LOG_ALERT<span class="token punctuation">,</span> c<span class="token operator">-></span>log<span class="token punctuation">,</span> ngx_errno<span class="token punctuation">,</span>                      ngx_close_file_n <span class="token string">" \"%s\" failed"</span><span class="token punctuation">,</span> c<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>内存池的所有结点上，只有父结点才存在cleanup链表、large链表、buf链表，子节点上只有ngx_pool_data_t结构(pool-&gt;d)和用户内存区域。如果子节点上也能存在着三个链表，说实话结构会变得异常复杂。</li><li>申请小数据内存(size &lt; pool-&gt;max)时不一定是向操作系统申请内存，会先遍历内存池的结点，判断其data区是否能满足分配的需求，能满足则在其结点上分配(移动last的指向)。如果没有满足的结点，则新建一个结点并将其假如内存池链表。</li><li>申请大数据内存(size &gt;= poo-&gt;max)，large的控制中心结构ngx_pool_large_t所需要的内存是在ngx_pool_data_t管理的区域上分配的，size大小的内存是直接向操作系统申请的(malloc)，然后用alloc指针保存分配的内存的地址。</li><li>cleanup设计灵活，能自定义清理工作，便于我们在内存池申请自定义或者特殊类型的内存，申请的数据区域存在于large链表或内存池结点的小块数据区域。</li></ol><h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><ol><li><p>关于current指针</p><p>current在内存池初始化时时指向父节点本身的，但是随着内存的不断分配出去其指向会不断的从small链表的头结点向尾结点方向移动。在分配小块内存时，会遍历small链表的结点，然后判断结点上是否有足够的空间满足申请者的需求，如果有则在已存在的结点上分配内存，如果没有则添加新的结点并在新结点上分配内存。随着内存不断的分配，结点上的内存空间可能会被分配完或者接近分配完(只剩下小块的内存，无法满足申请者的需求，类似内存碎片)，因此就要去扩容了，随着结点个数不断增加链表越来越长，遍历结点的效率会越来越低，而且链表中很多结点上的空间可能已经被分配完了，重复的遍历时没有任何意义的。nginx巧妙的借助current指针来解决这个问题，</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">ngx_palloc_block</span><span class="token punctuation">(</span>ngx_pool_t <span class="token operator">*</span>pool<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    u_char      <span class="token operator">*</span>m<span class="token punctuation">;</span>    size_t       psize<span class="token punctuation">;</span>    ngx_pool_t  <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token operator">*</span>new<span class="token punctuation">;</span>    psize <span class="token operator">=</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span> <span class="token punctuation">(</span>pool<span class="token operator">-></span>d<span class="token punctuation">.</span>end <span class="token operator">-</span> <span class="token punctuation">(</span>u_char <span class="token operator">*</span><span class="token punctuation">)</span> pool<span class="token punctuation">)</span><span class="token punctuation">;</span>    m <span class="token operator">=</span> <span class="token function">ngx_memalign</span><span class="token punctuation">(</span>NGX_POOL_ALIGNMENT<span class="token punctuation">,</span> psize<span class="token punctuation">,</span> pool<span class="token operator">-></span>log<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    new <span class="token operator">=</span> <span class="token punctuation">(</span>ngx_pool_t <span class="token operator">*</span><span class="token punctuation">)</span> m<span class="token punctuation">;</span>    new<span class="token operator">-></span>d<span class="token punctuation">.</span>end <span class="token operator">=</span> m <span class="token operator">+</span> psize<span class="token punctuation">;</span>    new<span class="token operator">-></span>d<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    new<span class="token operator">-></span>d<span class="token punctuation">.</span>failed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    m <span class="token operator">+</span><span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ngx_pool_data_t<span class="token punctuation">)</span><span class="token punctuation">;</span>    m <span class="token operator">=</span> <span class="token function">ngx_align_ptr</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> NGX_ALIGNMENT<span class="token punctuation">)</span><span class="token punctuation">;</span>    new<span class="token operator">-></span>d<span class="token punctuation">.</span>last <span class="token operator">=</span> m <span class="token operator">+</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 重点部分</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> pool<span class="token operator">-></span>current<span class="token punctuation">;</span> p<span class="token operator">-></span>d<span class="token punctuation">.</span>next<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token operator">-></span>d<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>d<span class="token punctuation">.</span>failed<span class="token operator">++</span> <span class="token operator">></span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pool<span class="token operator">-></span>current <span class="token operator">=</span> p<span class="token operator">-></span>d<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    p<span class="token operator">-></span>d<span class="token punctuation">.</span>next <span class="token operator">=</span> new<span class="token punctuation">;</span>    <span class="token keyword">return</span> m<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这部分代码是nginx扩容small链表的逻辑，关于current指针的部分我已经标出。根据代码得知：在链表上已存在的结点上的空间都无法满足分配内存的需求时就会新建一个结点然后分配内存，新结点采用的是尾插，因此要遍历链表拿到尾结点，但是如果链表过长就会导致效率低下。因此每增加一个结点时，就会从current指向的结点开始遍历(最开始时指向父节点本身的)，对其结点的failed字段进行判断(还要增加1，因为扩容就意味着此前的所有结点不能满足分配需求)，如果某个结点四次以上不满足分配内存的需求，就将current指向这个结点的下一个结点(找你这个结点要了四次内存都要不到，我就认为你没有可分配的内存了，下次再找内存池要内存，直接跳过你，从你后面的结点开始要内存)。这样就可以避免每次都遍历整个链表以及其中空间已经分配完的结点。</p><p><img src="source/image/ngx_current_1-20210327225636357.png" alt="内存池结构"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mem_pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="2021/03/18/%E6%8E%92%E5%BA%8F/"/>
      <url>2021/03/18/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ol><li><p>排序思想</p><p>一个无序数列，从第一个数开始，循环比较相邻两个数的大小，如果前一个数大于后一个数则交换它们的位置(升序)。</p></li><li><p>示意图</p><p>一个数列：10 9 8 7 6 5 4 3 2 1</p><p><img src="http://img.3amupupup.online/BoubleSort.png" alt="冒泡排序"></p><p><img src="http://img.3amupupup.online/BubbleSort.gif" alt="冒泡排序"></p></li></ol><ol start="3"><li><p>实现</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> arrSize<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrSize<span class="token number">-1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arrSize<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 每循环一次意味着一个最大的数被移动到了数组末尾，在下一次循环时最后一个数没必要参与比较</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 判断循环时是否发生交换，没有发生交换则说明已经有序，直接退出。</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>理解</p><p>冒泡排序每迭代一次数组，最大数会被冒到最后，在下一次迭代时排除掉之前迭代冒的大数。</p><p>时间复杂度：N-1 + N-2 + …… + 1 即 O(N^2)。</p><p>空间复杂度：在排序过程中无需借助其它空间保存数据，即O(1)。</p></li></ol><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><ol><li><p>排序思想</p><p>一个无序数列，假设前n个数是有序的，依次取出n之后的数字与 n=&gt;0 进行比较，如果小于n则插入到n之前(升序)。</p></li><li><p>示意图</p><p><img src="http://img.3amupupup.online/InsertSort.png" alt="插入排序"></p><p><img src="http://img.3amupupup.online/InsertSort.gif" alt="插入排序"></p></li><li><p>实现</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> arrSize<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrSize<span class="token number">-1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 假设 0-end是有序数列，第一次end就是0,拿arr[1]和arr[0]比较</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 选出end之后的第一个数</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 升序</span>            <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果temp小于arr[end]，则说明要将end往后挪一次</span>                end<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 然后end继续往前走,继续判断temp是否小于arr[end]</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不小于arr[end]时直接跳出循环</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        arr<span class="token punctuation">[</span>end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><ol><li><p>排序思想</p><p>希尔排序是在插入排序的基础上做的优化。插入排序中，如果值大小分布越不均匀，在选择一个数与有序序列比较时需要移动end的次数会越多，序列越接近有序，需要移动end的次数就会越少。希尔排序在此基础上，将序列分成不连续多个组，然后进行插入排序，这会使得序列能更快的接近有序。直至间隔为1时就是插入排序，此时数组接近有序，效率会更高。</p></li><li><p>示意图</p><p><img src="http://img.3amupupup.online/ShellSort.png" alt="希尔排序"></p><p><img src="http://img.3amupupup.online/ShellSort.gif" alt="希尔排序"></p><p>图中，2、5、13为一组，5、3、3为一组，升序情况下：间隔越大，那么排在靠后位置的数就更加容易的被插入在数组靠前的位置，比如arr[1]=5、arr[5]=3、arr[9]=3，如果是插入排序，arr[9]=3 end需要移动6次才能使arr[9]到达靠前的位置，使用希尔排序，end移动两次就靠前了。会使数组更容易的接近有序。</p></li><li><p>实现</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> arrSize<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> gap <span class="token operator">=</span> arrSize<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>gap <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        gap <span class="token operator">=</span> gap<span class="token operator">/</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2/3=0,会导致排序提前结束(gap还没等于1就结束了),所以每次给gap加上个1。</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> arrSize<span class="token operator">-</span>gap<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// arrSize为什么要减去gap: 假如数组长度是10,gap第一次循环为4。</span>        <span class="token comment" spellcheck="true">// 循环开始之后，temp的下标(也就是end+gap)不能超出数组范围即:i+gap &lt; arrsize,也就是i&lt;arrSize-gap</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> end <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>end<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>end <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    arr<span class="token punctuation">[</span>end<span class="token operator">+</span>gap<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>                    end<span class="token operator">-</span><span class="token operator">=</span>gap<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span>                <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            arr<span class="token punctuation">[</span>end<span class="token operator">+</span>gap<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><ol><li><p>排序思想</p><p>有序数列(数组)的在内存上存储形式是线性的(一段连续的内存)，其逻辑结构是二叉树(完全二叉树)。利用这个特性可以将数组看成一个二叉树，然后进行建堆操作。（大堆的父结点大于左右孩子结点，小堆的父结点小于左右孩子结点），然后每次取出堆顶的数再重新建堆。(升序建大堆，降序建小堆)。leftChild = parent*2+1，rightChile = parent*2+2。</p></li><li><p>示意图</p><p><img src="http://img.3amupupup.online/BuildBigHeap.png" alt="建大堆"></p><p><img src="http://img.3amupupup.online/BuildArrayToHeap.png" alt="建堆完成后的效果"></p><p><img src="http://img.3amupupup.online/SortByHeap.png" alt="利用堆特性排序"></p><p><img src="http://img.3amupupup.online/HeapSort.gif" alt="堆排序"></p></li><li><p>实现</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>    <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token operator">*</span>b<span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">AdJustDown</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> arrSize<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 建堆</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> parent <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">int</span> child <span class="token operator">=</span> parent<span class="token operator">*</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>child <span class="token operator">&lt;</span> arrSize<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> arrSize <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>child<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            child<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>parent<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            parent <span class="token operator">=</span> child<span class="token punctuation">;</span>            child <span class="token operator">=</span> parent<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> arrSize<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>arrSize<span class="token number">-1</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span><span class="token number">0</span> <span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">AdJustDown</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>i<span class="token punctuation">,</span>arrSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> end <span class="token operator">=</span> arrSize<span class="token number">-1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">AdJustDown</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>        end<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ol><li><p>排序思想(升序)</p><p>左右两个指针left、right，取一个key值。左右开始向右向左遍历，左指针遇见比key大的数停止移动，右指针遇见比key小的数停止移动，此时交换左右指针对应的值，直到左右指针重合。此时key左边的值全比key小，右边的值全比key大。再通过分治思想对key左右两边的区间进行递归操作。</p></li><li><p>示意图</p><p><img src="http://img.3amupupup.online/QuickSortt.png" alt="快速排序"></p><p><img src="http://img.3amupupup.online/RecursionForQuickSort.png" alt="分治思想"></p><p><img src="http://img.3amupupup.online/QuickSortTime1.png" alt="时间复杂度"></p><p><img src="http://img.3amupupup.online/QuickSOrt.gif" alt="快速排序"></p></li><li><p>代码实现</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* * 三数取中 * 在数组有序时(假设是降序),keyIndex每次都是最小的数的下标 * 会导致快排变成一个N^2的算法,三数取中能有效避免这个缺陷。 */</span><span class="token keyword">int</span> <span class="token function">GetMidIdx</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr <span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> mid<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> left<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> mid<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> left<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> right<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">Part</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> midIndex <span class="token operator">=</span> <span class="token function">GetMidIdx</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 找出中位数</span>    <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>midIndex<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> keyIndex <span class="token operator">=</span> right<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>keyIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 因为是left先移动,所以left的最终停留位置的数一定比keyIndex大</span>            left<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">>=</span> arr<span class="token punctuation">[</span>keyIndex<span class="token punctuation">]</span><span class="token punctuation">)</span>            right<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 循环走到这里时,left位置的数比keyIndex大,right位置的数比keyIndex小,对它们进行交换</span>    <span class="token punctuation">}</span>    <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>keyIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// left最终停止的位置和keyIndex进行交换,此时left的左边全是比选出的keyIndex小的数,右边全是比keyIndex大的数。</span>    <span class="token keyword">return</span> left<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 必须返回left,下一次排序时就可以排除掉left，对left左右的两边的数进行排序</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> div <span class="token operator">=</span> <span class="token function">Part</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>div<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>div<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">QuickSortNoR</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>    Stack st<span class="token punctuation">;</span>    <span class="token function">StackInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意进栈顺序,先进的后被取出来</span>    <span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 栈不为空说明还存在没被排序的区间则要继续循环</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> _right <span class="token operator">=</span> <span class="token function">StackTop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">StackPop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> _left <span class="token operator">=</span> <span class="token function">StackTop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">StackPop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> div <span class="token operator">=</span> <span class="token function">Part</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>_left<span class="token punctuation">,</span>_right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>div<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> _right<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span>div<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保证入栈顺序和第一次一致</span>            <span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span>_right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>_left <span class="token operator">&lt;</span> div<span class="token number">-1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span>_left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span>div<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">StackDestory</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><ol><li><p>排序思想</p><p>合并有序数组</p></li><li><p>示意图</p><p><img src="http://img.3amupupup.online/MergeSort.png" alt="归并排序"></p><p><img src="http://img.3amupupup.online/MergeSortNoR.png" alt="非递归"></p><p><img src="http://img.3amupupup.online/MergeSort.gif" alt="归并排序"></p></li><li><p>实现</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 将数组分割成N个有序小区间(1个数的区间，一个数也算有序)，再合并有序的数组</span><span class="token keyword">void</span> <span class="token function">_MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> tmp<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">>=</span>right<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 分割退出的条件</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 拿到中间位置的索引，下一步递归分割，直到不可分为止(分割到只有一个数)</span>    <span class="token function">_MergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 递归分割左半边</span>    <span class="token function">_MergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">,</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 递归分割右半边</span>    <span class="token keyword">int</span> begin1 <span class="token operator">=</span> left<span class="token punctuation">,</span> end1 <span class="token operator">=</span> mid<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 走到这里说明已经分割完了，分成了right+1个一个元素的数组</span>    <span class="token keyword">int</span> begin2 <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end2 <span class="token operator">=</span> right<span class="token punctuation">;</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> begin1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// tmp区间起始位置</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>begin1 <span class="token operator">&lt;=</span> end1 <span class="token operator">&amp;&amp;</span> begin2 <span class="token operator">&lt;=</span> end2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 归并有序数组</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>begin1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>begin2<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>           tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>begin1<span class="token operator">&lt;=</span>end1<span class="token punctuation">)</span>        tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>begin2<span class="token operator">&lt;=</span>end2<span class="token punctuation">)</span>        tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 拷贝回原数组，拷贝一定是 &lt;= 闭区间，因为right传入的是闭区间</span>    <span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 归并，递归实现</span><span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> arrSize<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>arrSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_MergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arrSize<span class="token number">-1</span><span class="token punctuation">,</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 归并，非递归实现</span><span class="token keyword">void</span> <span class="token function">_MergeSortNoR</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> begin1<span class="token punctuation">,</span> <span class="token keyword">int</span> end1<span class="token punctuation">,</span> <span class="token keyword">int</span> begin2<span class="token punctuation">,</span> <span class="token keyword">int</span> end2<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> tmp<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">PrintArr</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> begin1<span class="token punctuation">,</span>right <span class="token operator">=</span> end2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里必须使用新变量记录数组的起始结束位置，因为经过迭代后begin1会自增</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> begin1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// tmp区间起始位置</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>begin1 <span class="token operator">&lt;=</span> end1 <span class="token operator">&amp;&amp;</span> begin2 <span class="token operator">&lt;=</span> end2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 归并有序数组</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>begin1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>begin2<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>begin1<span class="token operator">&lt;=</span>end1<span class="token punctuation">)</span>        tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>begin2<span class="token operator">&lt;=</span>end2<span class="token punctuation">)</span>        tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">MergeSortNoR</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> arrSize<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>arrSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> gap <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>gap<span class="token operator">&lt;</span>arrSize<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrSize<span class="token punctuation">;</span> i<span class="token operator">+</span><span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>gap<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// [i,i+gap-1] [i+gap, i+2*gap-1]</span>            <span class="token keyword">int</span> begin1 <span class="token operator">=</span> i<span class="token punctuation">,</span> end1 <span class="token operator">=</span> i<span class="token operator">+</span>gap<span class="token number">-1</span><span class="token punctuation">,</span> begin2 <span class="token operator">=</span> i<span class="token operator">+</span>gap<span class="token punctuation">,</span> end2 <span class="token operator">=</span>i<span class="token operator">+</span>gap<span class="token operator">*</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>begin2 <span class="token operator">>=</span> arrSize<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// begin2大于等于数组长度时说明只存在一组数据(无法分割成两组)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>end2<span class="token operator">>=</span>arrSize<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// end2大于等于数组长度则说明无法分割成均等的两组，end2超出了数组的范围</span>                end2 <span class="token operator">=</span> arrSize<span class="token number">-1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 所以需要调整end2的位置，使其不能超出数组范围</span>            <span class="token function">_MergeSortNoR</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>begin1<span class="token punctuation">,</span>end1<span class="token punctuation">,</span>begin2<span class="token punctuation">,</span>end2<span class="token punctuation">,</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        gap<span class="token operator">*</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><ol><li><p>思想</p><p>记录一个序列中数字出现的次数。</p><p>找出序列中的最大值 max 然后创建一个size为max+1的tmp数组，遍历数据序列，拿序列中的值做tmp数组的下标，tmp对应下标的值进行++ 计数。遍历结束后，依次从tmp中取值拷贝到原序列中，tmp的下标作为序列的值，tmp下标对应的值作为拷贝的次数。</p></li><li><p>示意图</p><p><img src="http://img.3amupupup.online/CountSort.png" alt="计数排序"></p><p><img src="http://img.3amupupup.online/849589-20171015231740840-6968181.gif" alt="计数排序"></p></li><li><p>实现</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">CountSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> arrSize<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> min <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> max <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 找出最大最小的值</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrSize<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            max <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            min <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> range <span class="token operator">=</span> max<span class="token operator">-</span>min<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建一个range+1大小的数组，利用相对位置存储计数，还原时tmp数组下标加上min就是原数组的值</span>    <span class="token keyword">int</span><span class="token operator">*</span> countArray <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>range<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>countArray<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"malloc failed.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">memset</span><span class="token punctuation">(</span>countArray<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>range<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrSize<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        countArray<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>min<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> range<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>countArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">+</span>min<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">free</span><span class="token punctuation">(</span>countArray<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins结合sonar代码检测流水线</title>
      <link href="2021/03/18/Jenkins%E7%BB%93%E5%90%88sonar%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
      <url>2021/03/18/Jenkins%E7%BB%93%E5%90%88sonar%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h5 id="1、jenkins所需插件"><a href="#1、jenkins所需插件" class="headerlink" title="1、jenkins所需插件"></a>1、jenkins所需插件</h5><p><a href="https://plugins.jenkins.io/workflow-aggregator" target="_blank" rel="noopener">Pipeline</a>、<a href="https://plugins.jenkins.io/sonar-quality-gates" target="_blank" rel="noopener">Sonar Quality Gates Plugin</a>、<a href="https://plugins.jenkins.io/sonar" target="_blank" rel="noopener">SonarQube Scanner</a>、<a href="https://plugins.jenkins.io/generic-webhook-trigger" target="_blank" rel="noopener">Generic Webhook Trigger Plugin</a></p><h5 id="2、jenkins配置"><a href="#2、jenkins配置" class="headerlink" title="2、jenkins配置"></a>2、jenkins配置</h5><ul><li><p>Dashboard =&gt; 系统管理 =&gt; 全局工具配置</p><p><img src="/image/image-20201227165338711.png" alt="sonar scanner安装"></p></li><li><p>Dashboard =&gt; 系统管理 =&gt; 系统配置</p><p><img src="/image/image-20201227165501679.png" alt="sonarqube servers配置"></p></li></ul><p>  <img src="/image/image-20201227165627390.png" alt="token配置"></p><p>  这个token是在sonar web上生成的，然后在jenkins上创建一个secret text类型凭据。</p><p>  <img src="/image/image-20201227165828644.png" alt="gitlab"></p><p>  配置连接gitlab，要生成gitlab api token</p><p>  <img src="/image/image-20201227165956042.png" alt="获取gitlab Private token"></p><p>  生成private token。在sonar检测代码所有条件都通过时，要通过这个private token去操作gitlab的api来自动接受合并请求。</p><p>  <img src="/image/image-20201227170513752.png" alt="private token 凭据"></p><p>  生成凭据，记住这里的id 为12，一会pipeline脚本要用</p><ul><li><p>在gitlab项目下配置触发器，只勾选Merge Request Events (这个token随机生成一个就好了)</p><p><img src="/image/image-20201227170841973.png" alt="gitlab webhook"></p></li></ul><h5 id="3、pipiline脚本"><a href="#3、pipiline脚本" class="headerlink" title="3、pipiline脚本"></a>3、pipiline脚本</h5><pre class=" language-pipeline"><code class="language-pipeline">pipeline {   agent any   environment {        PrivateToken= credentials('12') // 获取private token，之前在凭据里配置过，这样比较安全，不需要在脚本里明文使用token    }   options {      gitLabConnection('gitlab')    }       triggers {        GenericTrigger(            genericVariables: [            [key: 'source_branch', value: '$.object_attributes.source_branch'], // 获取merge的源分支,只检测源分支，源分支的代码检测成功才能合并到目标分支            [key: 'url', value: '$.object_attributes.url'], // 获取gitlab merge请求的url            [key: 'action', value: '$.object_attributes.action'], // 获取merge动作 [reopen,close,open],只在reopen和open时才出发流水线检测            [key: 'source_project_id', value: '$.object_attributes.source_project_id'],            [key: 'iid', value: '$.object_attributes.iid'],            [key: 'name', value: '$.user.name'], // 获取合并请求的发起人            [key: 'project_name', value: '$.project.name'], // 或者项目名            [key: 'target_branch', value: '$.object_attributes.target_branch'], // 获取目标分支，我这里的需求是：合并到release.test分支的请求才进行质检、自动合并，所以我需要拿到这个变量            [key: 'object_kind', value: '$.object_kind']            ],            token: 'fc161920aa6f1886e7417416edc85500' , // 这是webhook上填写的token            causeString: ' Triggered on $ref' ,            printContributedVariables: true,            printPostContent: true        )    }   stages {    stage("select branch"){        steps{                script{                    if((env.source_branch =~ 'release.*').matches() || (env.action!="open"  && env.action!="update") || env.target_branch != "release.test"){ // 触发流水线检测代码的条件                        stage("exit with 0"){                            ansiColor('gnome-terminal') {                                echo "\033[32m Jump Sonar\n user:$name\nproject_name:$project_name\nobject_kind:$object_kind\naction:$action\nsource_branch:$source_branch\n target_branch:$target_branch \033[0m"                            }                                   }                    }else{                        stage('pull branch') {                            checkout([$class: 'GitSCM', branches: [[name: "*/$source_branch"]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: '11', url: 'http://gitlab.xxxxxx.com:8888/xubin/xxxxxxxx.git']]])                        }                        stage('SonarQubeanalysis') {                                script {                                    scannerHome = tool 'sonar-scanner'                                }                            withSonarQubeEnv('sonar') {                            sh "echo ${scannerHome}"                            sh "${scannerHome}/bin/sonar-scanner -Dsonar.projectKey=$JOB_BASE_NAME -Dsonar.sources=./app"                            }                    }                       stage("SonarQube Quality Gate") {                                    timeout(time: 1, unit: 'HOURS') {                                    def qg = waitForQualityGate('sonar')                                    if (qg.status != 'OK') {                                    echo "Status: ${qg.status}"                                    error "Pipeline aborted due to quality gate failure: ${qg.status}" // 质检没通过直接让流水线失败退出                                    }                                }                                ansiColor('gnome-terminal') {                                echo "\033[32m Jump Sonar\n user:$name\nproject_name:$project_name\nobject_kind:$object_kind\naction:$action\nsource_branch:$source_branch\n target_branch:$target_branch \033[0m"                            }                    }                         stage("Merge"){ // 如果检测通过自动合并请求                                script{                                    httpRequest authentication: '11', customHeaders: [[maskValue: false, name: 'PRIVATE-TOKEN', value: "$PrivateToken"]], httpMode: 'PUT', responseHandle: 'NONE', url: "http://gitlab.xxxxxx.com:8888/api/v4/projects/$source_project_id/merge_requests/$iid/merge"                                }                        }                    }                }            }        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sonar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带环链表</title>
      <link href="2021/03/18/%E5%B8%A6%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
      <url>2021/03/18/%E5%B8%A6%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="1、判断链表是否带环"><a href="#1、判断链表是否带环" class="headerlink" title="1、判断链表是否带环"></a>1、<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">判断链表是否带环</a></h4><h5 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h5><ol><li><p>给链表设置两个指针，slow移动一步，fast移动两步。</p><p><img src="/image/image-20201227013251253.png" alt="初始状态"></p></li><li><p>fast和slow指针都进入环之后</p><p><img src="/image/image-20201227013617501.png" alt="fast、slow进环"></p></li><li><p>fast和slow指针重合</p><p>在slow和fast都进环之后，fast开始追slow。slow移动一步，fast移动两步。</p><p><img src="/image/image-20201227014743194.png" alt="指针追赶"></p><p>每一次移动fast和slow之间的距离缩短一步，最终重合，则证明有环。如果fast指针在经过若干次移动之后为NULL(循环结束)，则说明不带环。</p><p><img src="/image/image-20201227013919844.png" alt="指针重合"></p></li><li><p>代码：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     struct ListNode *next; * }; */</span>bool <span class="token function">hasCycle</span><span class="token punctuation">(</span><span class="token keyword">struct</span> ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> ListNode <span class="token operator">*</span>slow <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">struct</span> ListNode <span class="token operator">*</span>fast <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">&amp;&amp;</span> fast<span class="token operator">-></span>next<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        slow <span class="token operator">=</span> slow<span class="token operator">-></span>next<span class="token punctuation">;</span>        fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">==</span> fast<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> true<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="2、带环链表的入环结点"><a href="#2、带环链表的入环结点" class="headerlink" title="2、带环链表的入环结点"></a>2、<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">带环链表的入环结点</a></h4><h5 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h5><ol><li><p>给链表设置两个指针，slow移动一步，fast移动两步。</p><p><img src="/image/image-20201227132753055.png" alt="初始状态"></p></li><li><p>slow在进入环之后，在一个C之内就会被fast追上(fast的速度是slow的两倍)。</p><p>slow走的距离是：L+X</p><p>fast走的距离是 ：L+N*C+X (如果L足够长环足够小，fast进环且绕环N次之后slow才会进入)</p><p>2*(L+X) = L+N*C+X =&gt; L = N*C -X</p><p>然后同时从head和fast位置开始遍历，找到相同的节点。</p><p><img src="/image/image-20201227154937844.png" alt="slow、fast重合"></p></li><li><p>代码：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     struct ListNode *next; * }; */</span><span class="token keyword">struct</span> ListNode <span class="token operator">*</span><span class="token function">detectCycle</span><span class="token punctuation">(</span><span class="token keyword">struct</span> ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> ListNode <span class="token operator">*</span>slow <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">struct</span> ListNode <span class="token operator">*</span>fast <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">&amp;&amp;</span> fast<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 遍历链表，找到slow与fast重合的点</span>    <span class="token punctuation">{</span>        slow <span class="token operator">=</span> slow<span class="token operator">-></span>next<span class="token punctuation">;</span>        fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>fast <span class="token operator">==</span> slow<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>fast <span class="token operator">||</span> <span class="token operator">!</span>fast<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 判断上一步循环时因为遍历到NULL结束的还是因为 fast==slow 结束的</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果fast或者fast->next为NULL说明链表不带环，直接返回NULL</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">&amp;&amp;</span> head<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 遍历寻找相交结点</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>fast <span class="token operator">==</span> head<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> fast<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token punctuation">;</span>        head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux性能优化实战笔记</title>
      <link href="2021/03/18/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/18/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="01、平均负载"><a href="#01、平均负载" class="headerlink" title="01、平均负载"></a>01、平均负载</h4><p>平均负载：系统出于可运行状态<font size=2 color=red>（正在使用cpu或者正在等待cpu的进程，也就是ps命令看到的Running 或 Runnable状态的进程）</font>和不可中断状态<font size=2 color=red>（进程正在处于内核态关键流程中的进程，这些流程是不可打断的，例如等待硬件设备的I/O响应，也就是ps命令看到的D状态。比如，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程就处于不可中断状态。如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。所以，不可中断状态实际上是系统对进程和硬件设备的一种保护机制。）</font>的平均进程数，也就是平均活跃进程数。</p><pre class=" language-shell"><code class="language-shell">#观察进程的cpu使用情况，间隔一秒输出一次pidstat  -u 1#观察cpu使用情况，观察各状态占比mpstat -P ALL  1</code></pre><h4 id="02、CPU-上下文切换"><a href="#02、CPU-上下文切换" class="headerlink" title="02、CPU 上下文切换"></a>02、CPU 上下文切换</h4><p>CPU 寄存器：是 CPU 内置的容量小、但速度极快的内存。</p><p>程序计数器：则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。</p><p>它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做 CPU 上下文。</p><p>CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p><p>上下文切换情景：</p><p>① 系统调用，cpu寄存器里原来用户态的指令位置，需要先保存起来，接着为了执行内核态的代码，cpu寄存器需要更新为内核态指令的最新位置，最后才是跳转到内核态运行内核任务，系统调用结束后cpu需要恢复到原来保存的用户态，继续运行进程。so，一次系统调用发生了两次cpu上下文切换。（<font size=2 color=red>系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的</font>）</p><p>进程上下文切换，是指从一个进程切换到另一个进程运行。而系统调用过程中一直是同一个进程在运行。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux性能优化实战笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECS磁盘扩容</title>
      <link href="2021/03/18/ECS%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/"/>
      <url>2021/03/18/ECS%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h6 id="1、通过-df-h-知根分区大小为40G。"><a href="#1、通过-df-h-知根分区大小为40G。" class="headerlink" title="1、通过 df -h 知根分区大小为40G。"></a>1、通过 df -h 知根分区大小为40G。</h6><p><img src="/image/image-20200512133700547.png" alt="image-20200512133700547"></p><h6 id="2、在阿里云后台对当前ECS实例的磁盘进行在线扩容。"><a href="#2、在阿里云后台对当前ECS实例的磁盘进行在线扩容。" class="headerlink" title="2、在阿里云后台对当前ECS实例的磁盘进行在线扩容。"></a>2、在阿里云后台对当前ECS实例的磁盘进行在线扩容。</h6><p><img src="/image/image-20200512134218782.png" alt="image-20200512134218782"></p><h6 id="3、扩容后登陆ECS使用fdisk-l查看磁盘大小，磁盘已经扩容到100G。"><a href="#3、扩容后登陆ECS使用fdisk-l查看磁盘大小，磁盘已经扩容到100G。" class="headerlink" title="3、扩容后登陆ECS使用fdisk -l查看磁盘大小，磁盘已经扩容到100G。"></a>3、扩容后登陆ECS使用fdisk -l查看磁盘大小，磁盘已经扩容到100G。</h6><p><img src="/image/image-20200512134102595.png" alt="image-20200512134102595"></p><h6 id="4、安装growpart"><a href="#4、安装growpart" class="headerlink" title="4、安装growpart"></a>4、安装growpart</h6><pre class=" language-shell"><code class="language-shell">[root@iZbp1e8z3uz7pmqbsis8bkZ ~]# yum -y install cloud-utils-growpartLoaded plugins: fastestmirrorbase                                                     | 3.6 kB     00:00epel                                                     | 4.7 kB     00:00extras                                                   | 2.9 kB     00:00updates                                                  | 2.9 kB     00:00(1/7): base/7/x86_64/group_gz                              | 153 kB   00:00(2/7): extras/7/x86_64/primary_db                          | 190 kB   00:00(3/7): epel/x86_64/group_gz                                |  95 kB   00:00(4/7): updates/7/x86_64/primary_db                         | 176 kB   00:00(5/7): epel/x86_64/updateinfo                              | 1.0 MB   00:00(6/7): base/7/x86_64/primary_db                            | 6.1 MB   00:00(7/7): epel/x86_64/primary_db                              | 6.8 MB   00:00Determining fastest mirrors * base: mirrors.cloud.aliyuncs.com * epel: mirrors.cloud.aliyuncs.com * extras: mirrors.cloud.aliyuncs.com * updates: mirrors.cloud.aliyuncs.comResolving Dependencies--> Running transaction check---> Package cloud-utils-growpart.noarch 0:0.29-5.el7 will be installed--> Finished Dependency ResolutionDependencies Resolved================================================================================ Package                     Arch          Version            Repository   Size================================================================================Installing: cloud-utils-growpart        noarch        0.29-5.el7         base         27 kTransaction Summary================================================================================Install  1 PackageTotal download size: 27 kInstalled size: 61 kDownloading packages:cloud-utils-growpart-0.29-5.el7.noarch.rpm                 |  27 kB   00:00Running transaction checkRunning transaction testTransaction test succeededRunning transaction  Installing : cloud-utils-growpart-0.29-5.el7.noarch                       1/1  Verifying  : cloud-utils-growpart-0.29-5.el7.noarch                       1/1Installed:  cloud-utils-growpart.noarch 0:0.29-5.el7Complete!</code></pre><h6 id="5、扩展-dev-vda1分区（命名含义为扩展-dev-vda磁盘的第一个分区）。"><a href="#5、扩展-dev-vda1分区（命名含义为扩展-dev-vda磁盘的第一个分区）。" class="headerlink" title="5、扩展/dev/vda1分区（命名含义为扩展/dev/vda磁盘的第一个分区）。"></a>5、扩展/dev/vda1分区（命名含义为扩展/dev/vda磁盘的第一个分区）。</h6><pre class=" language-shell"><code class="language-shell">[root@iZbp1e8z3uz7pmqbsis8bkZ ~]# growpart /dev/vda 1CHANGED: partition=1 start=2048 old: size=83881984 end=83884032 new: size=209713119 end=209715167</code></pre><p>​     若报错unexpected output in sfdisk –version……..则运行LANG=en_US.UTF-8切换ECS实例的字符编码类型。</p><p>6、运行resize2fs <PartitionName> 命令调用resize2fs扩容文件系统。</p><pre class=" language-shell"><code class="language-shell">[root@iZbp1e8z3uz7pmqbsis8bkZ ~]# resize2fs /dev/vda1resize2fs 1.42.9 (28-Dec-2013)Filesystem at /dev/vda1 is mounted on /; on-line resizing requiredold_desc_blocks = 3, new_desc_blocks = 7The filesystem on /dev/vda1 is now 26214139 blocks long.[root@iZbp1e8z3uz7pmqbsis8bkZ ~]# df -hFilesystem      Size  Used Avail Use% Mounted on/dev/vda1        99G  1.5G   93G   2% /devtmpfs        487M     0  487M   0% /devtmpfs           497M     0  497M   0% /dev/shmtmpfs           497M  308K  496M   1% /runtmpfs           497M     0  497M   0% /sys/fs/cgrouptmpfs           100M     0  100M   0% /run/user/0</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ecs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次海外k8s集群代码发布实践</title>
      <link href="2021/03/18/%E4%B8%80%E6%AC%A1%E6%B5%B7%E5%A4%96k8s%E9%9B%86%E7%BE%A4%E4%BB%A3%E7%A0%81%E5%8F%91%E5%B8%83%E5%AE%9E%E8%B7%B5/"/>
      <url>2021/03/18/%E4%B8%80%E6%AC%A1%E6%B5%B7%E5%A4%96k8s%E9%9B%86%E7%BE%A4%E4%BB%A3%E7%A0%81%E5%8F%91%E5%B8%83%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>项目背景：要上一个海外版的小说平台，gitlab在国内，当前是要求在海外搭建一个测试环境(php代码)</p><h3 id="第一阶段："><a href="#第一阶段：" class="headerlink" title="第一阶段："></a>第一阶段：</h3><p>话不多说，在香港买了台机器，down了个oneinstack脚本装环境，环境具体为mysql+redis+php-fpm7.1.3+nginx。</p><p>jenkins+gitlab都是在国内，也没多想直接在jenkins创建了一个工程，使用ssh-server插件将构建好的代码push到香港机器。问题来了，因为机器是在香港，在jenkins push代码的时候巨慢无比，每一次发布起码花费十分钟以上的时间，严重影响开发效率。</p><h3 id="第二阶段："><a href="#第二阶段：" class="headerlink" title="第二阶段："></a>第二阶段：</h3><p>想到了用容器的方式发布，思路是这样：在杭州机器上将镜像构建好，然后push到香港仓库去，因为镜像push的时候会进行压缩，另外push到香港仓库之后那边机器拉取代码的速度会大大提升，缩短了发布时间（这是为以后生产发布做考虑，代码同步慢，有些文件更新有些文件没更新可能会造成线上报错的）。于是开始构建基础镜像，编写<a href="http://127.0.0.1:4000/2020/07/28/Dockerfile/" target="_blank" rel="noopener">Dockerfile</a>。</p><p>编写dockerfile：①保证镜像精简 ②尽量减少镜像的层数，将底层环境固定。</p><p>nginx和php-fpm基础镜像构建完成后使用jenkins进行打包代码到镜像里，使用的pipeline脚本。</p><p>第二阶段使用的是docker compose，因此每一次更新都需要登录香港机器手动拉取并更新镜像，比较麻烦，所以很快就放弃了这种方式</p><h3 id="第三阶段："><a href="#第三阶段：" class="headerlink" title="第三阶段："></a>第三阶段：</h3><p>考虑使用k8s，于是在香港买了个k8s集群，两个2c4g的节点，外加一台2c4g的机器作为数据库机器（redis+mysql），后续正式上线之后再考虑扩容。</p><p>问题：</p><p>​    1、nginx容器和php-fpm容器需要共享代码才能正常提供服务。</p><p>​    解决：首先想到的是每次发布构建两个镜像，即将代码分别拷贝进nginx和php容器，然后通过deployment去运行，但是这种方法太麻烦，因为没次都需要重新更新php和nginx容器，这两个镜像的体积加起来差不多有800M了，所以不考虑这种方式。</p><p>​                于是使用了deployment控制器中的volume —- emptydir共享卷，代码使用一个initcontainer拷贝进去。这样的话我每次只需要更新initcontainer(initcontainer不需要什么环境，使用的busybox，基础镜像才几M，加上代码也就30M左右，这样的话大大提高了镜像构建、推送、拉取的速度)。</p><p>使用pipeline构建代码容器：</p><pre class=" language-yaml"><code class="language-yaml">pipeline <span class="token punctuation">{</span>   agent any   stages <span class="token punctuation">{</span>      stage('pull code') <span class="token punctuation">{</span>         steps <span class="token punctuation">{</span>            checkout(<span class="token punctuation">[</span><span class="token key atrule">$class</span><span class="token punctuation">:</span> <span class="token string">'GitSCM'</span><span class="token punctuation">,</span> <span class="token key atrule">branches</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">'*/test'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token key atrule">doGenerateSubmoduleConfigurations</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token punctuation">,</span> <span class="token key atrule">extensions</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token key atrule">submoduleCfg</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token key atrule">userRemoteConfigs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token key atrule">credentialsId</span><span class="token punctuation">:</span> <span class="token string">'11'</span><span class="token punctuation">,</span> <span class="token key atrule">url</span><span class="token punctuation">:</span> <span class="token string">'http://xxxxx.xxxxxxx.com/xxxxx/xxxxxxx_api.git'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>)         <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      stage('build image')<span class="token punctuation">{</span>          steps <span class="token punctuation">{</span>              sh 'wget http<span class="token punctuation">:</span>//172.16.72.173/leshuapi/.dockerignore <span class="token punctuation">-</span>O .dockerignore'              sh 'wget http<span class="token punctuation">:</span>//172.16.72.173/leshuapi/Dockerfile <span class="token punctuation">-</span>O Dockerfile'              sh 'sudo docker build <span class="token punctuation">-</span>t registry.cn<span class="token punctuation">-</span>hongkong.aliyuncs.com/ysg_codebox/$JOB_BASE_NAME<span class="token punctuation">:</span>latest .'          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      stage('push image')<span class="token punctuation">{</span>          steps <span class="token punctuation">{</span>              <span class="token key atrule">timeout(time</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token key atrule">unit</span><span class="token punctuation">:</span> 'MINUTES')<span class="token punctuation">{</span>                  retry(5) <span class="token punctuation">{</span>                      sh 'docker push registry.cn<span class="token punctuation">-</span>hongkong.aliyuncs.com/ysg_codebox/$JOB_BASE_NAME<span class="token punctuation">:</span>latest'                  <span class="token punctuation">}</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>deployment.yaml内容如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> leshuapi<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> leshuapp    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">dnsPolicy</span><span class="token punctuation">:</span> Default      <span class="token key atrule">shareProcessNamespace</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>      <span class="token key atrule">imagePullSecrets</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> regsecret      <span class="token key atrule">initContainers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> copycode        <span class="token comment" spellcheck="true">#代码容器</span>        <span class="token key atrule">image</span><span class="token punctuation">:</span> registry.cn<span class="token punctuation">-</span>hongkong.aliyuncs.com/ysg_codebox/xxxxxxxxx<span class="token punctuation">:</span>latest        <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> Always        <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"mv"</span><span class="token punctuation">,</span><span class="token string">"/data/wwwroot/"</span><span class="token punctuation">,</span><span class="token string">"/data/www/"</span><span class="token punctuation">]</span>        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> www          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data/www      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> chown        <span class="token key atrule">image</span><span class="token punctuation">:</span> registry.cn<span class="token punctuation">-</span>hongkong.aliyuncs.com/ysg_baseimage/xxxxbox<span class="token punctuation">:</span>v2        <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent        <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"chown"</span><span class="token punctuation">,</span><span class="token string">"-R"</span><span class="token punctuation">,</span><span class="token string">"www.www"</span><span class="token punctuation">,</span><span class="token string">"/data/www/"</span><span class="token punctuation">]</span>        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> www          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data/www      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx          <span class="token key atrule">image</span><span class="token punctuation">:</span> registry.cn<span class="token punctuation">-</span>hongkong.aliyuncs.com/ysg_baseimage/nginx<span class="token punctuation">:</span>v3          <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent          <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>            <span class="token key atrule">capabilities</span><span class="token punctuation">:</span>              <span class="token key atrule">add</span><span class="token punctuation">:</span>              <span class="token punctuation">-</span> SYS_PTRACE          <span class="token key atrule">stdin</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>          <span class="token key atrule">tty</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>          <span class="token key atrule">resources</span><span class="token punctuation">:</span>            <span class="token key atrule">requests</span><span class="token punctuation">:</span>              <span class="token key atrule">memory</span><span class="token punctuation">:</span> 200Mi              <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 100m            <span class="token key atrule">limits</span><span class="token punctuation">:</span>              <span class="token key atrule">memory</span><span class="token punctuation">:</span> 300Mi              <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 200m          <span class="token key atrule">ports</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>          <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>            <span class="token key atrule">tcpSocket</span><span class="token punctuation">:</span>              <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>          <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"nginx"</span><span class="token punctuation">,</span> <span class="token string">"-g"</span><span class="token punctuation">,</span> <span class="token string">"daemon off;"</span><span class="token punctuation">]</span>          <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> www              <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data/www            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> logs              <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data/logs/            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>conf              <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /etc/nginx/conf.d/            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> env              <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data/www/wwwroot/env/        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> php<span class="token punctuation">-</span>fpm          <span class="token key atrule">image</span><span class="token punctuation">:</span> registry.cn<span class="token punctuation">-</span>hongkong.aliyuncs.com/ysg_baseimage/php<span class="token punctuation">-</span>fpm<span class="token punctuation">:</span>v2          <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent          <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>            <span class="token key atrule">capabilities</span><span class="token punctuation">:</span>              <span class="token key atrule">add</span><span class="token punctuation">:</span>              <span class="token punctuation">-</span> SYS_PTRACE          <span class="token key atrule">stdin</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>          <span class="token key atrule">tty</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>          <span class="token key atrule">resources</span><span class="token punctuation">:</span>            <span class="token key atrule">requests</span><span class="token punctuation">:</span>              <span class="token key atrule">memory</span><span class="token punctuation">:</span> 200Mi              <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 100m            <span class="token key atrule">limits</span><span class="token punctuation">:</span>            <span class="token key atrule">memory</span><span class="token punctuation">:</span> 300Mi              <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 200m          <span class="token key atrule">ports</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">9000</span>          <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>            <span class="token key atrule">tcpSocket</span><span class="token punctuation">:</span>              <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9000</span>          <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/usr/local/php/sbin/php-fpm"</span><span class="token punctuation">,</span><span class="token string">"-F"</span><span class="token punctuation">]</span>          <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> www              <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data/www            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> logs              <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data/logs/            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> phpfpm<span class="token punctuation">-</span>conf              <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/local/php/etc/php<span class="token punctuation">-</span>fpm.d/            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> env              <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data/www/wwwroot/env/      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> www        <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> logs        <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>conf        <span class="token key atrule">configMap</span><span class="token punctuation">:</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> leshuapi<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>conf          <span class="token key atrule">items</span><span class="token punctuation">:</span>           <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> server.conf             <span class="token key atrule">path</span><span class="token punctuation">:</span> server.conf      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> phpfpm<span class="token punctuation">-</span>conf        <span class="token key atrule">configMap</span><span class="token punctuation">:</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> leshuapi<span class="token punctuation">-</span>phpfpm<span class="token punctuation">-</span>conf          <span class="token key atrule">items</span><span class="token punctuation">:</span>           <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> www.conf             <span class="token key atrule">path</span><span class="token punctuation">:</span> www.conf      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> env        <span class="token key atrule">configMap</span><span class="token punctuation">:</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> leshuapi<span class="token punctuation">-</span>env          <span class="token key atrule">items</span><span class="token punctuation">:</span>           <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> .env             <span class="token key atrule">path</span><span class="token punctuation">:</span> .env<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> leshuapiservice<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> leshuapp</code></pre><p>镜像里的项目配置文件、nginx配置文件、php-fpm的配置文件全部通过configmap挂载出来方便修改，具体yaml省略。</p><p>配置文件结构：</p><p><img src="/image/image-20201016181209870.png" alt="image-20201016181209870"></p>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cicd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="2021/03/18/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2021/03/18/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h6 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h6><ol><li><p>示意图</p><p><img src="http://img.3amupupup.online/FullBinaryTree.png" alt="满二叉树"></p><p><img src="http://img.3amupupup.online/wanquanBinaryTree.png" alt="完全二叉树"></p></li><li><p>性质</p><ol><li>一个二叉树，如果每一层的结点个数都达到最大值则就是满二叉树。也就是说一个深度为k的二叉树，如果结点总数是(2^k)-1则是满二叉树。</li><li>前k-1层结点个数都是满的(达到最大个数)，最后一层可以不满，但是必须从左到右连续，称为完全二叉树。(满二叉树是特殊的完全二叉树)</li><li>若规定根结点的层数为1，则一棵非空二叉树的第i层至多有2^(i-1)个结点。</li><li>任何一颗二叉树，度为0的结点个数比度为2的结点个数多1。</li><li>对于有N个结点的满二叉树，二叉树的高度 h=log<sub>2</sub><sup>N+1</sup>。</li><li>对于有N个结点的完全二叉树，二叉树的高度 h=log<sub>2</sub><sup>N</sup>+1。</li></ol></li></ol><h6 id="二叉树的顺序存储。"><a href="#二叉树的顺序存储。" class="headerlink" title="二叉树的顺序存储。"></a>二叉树的顺序存储。</h6><ol><li><p>示意图</p><p><img src="http://img.3amupupup.online/BinaryTreeStorageInArray1.png" alt="image-20210125135822359"></p></li><li><p>父亲结点下标是i，则左孩子结点下标为2*i+1、右孩子结点下标</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="2021/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>2021/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>计算机网络</p><h5 id="三种交换方式："><a href="#三种交换方式：" class="headerlink" title="三种交换方式："></a>三种交换方式：</h5><table><thead><tr><th>交换方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>电路交换</td><td>通信时延小(比特流直达终点)<br />有序传输<br />没有冲突<br />使用范围广(模拟信号、数字信号)<br />实时性强<br />控制简单</td><td>建立连接时间长<br />线路独占，使用效率低<br />灵活性差<br />难以规格化</td></tr><tr><td>报文交换</td><td>无需建立连接(不需要为通信双方事先建立一条专用的通信线路，不存在建立连接的时延。)<br />动态分配线路<br />提高线路可靠性<br />提高线路利用率<br />提供多目标服务</td><td>引起了转发时延<br />需要较大的存储缓存空间<br />需要传输额外的信息量(报头要携带目标地址、源地址等信息)<br /></td></tr><tr><td>分组交换</td><td>无需建立连接<br />线路利用率高<br />简化了存储管理<br />加速传输<br />减少出错概率和重传数据量</td><td>引起了转发时延<br />需要传输额外的信息量<br />对于数据报服务，存在失序、丢失或重复分组的问题；对于虚电路服务，存在呼叫建立、数据传输和虚电路释放三个过程</td></tr></tbody></table><h5 id="计算机网络的定义和分类"><a href="#计算机网络的定义和分类" class="headerlink" title="计算机网络的定义和分类"></a>计算机网络的定义和分类</h5>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编笔记</title>
      <link href="2021/03/18/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/18/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>AX = AH + AL</p><p>BX = BH + BL</p><p>CX = CH + CL</p><p>DX = DH + DL</p><p>数据寄存器</p><p>段地址寄存器：偏移地址寄存器</p><p>DS    SP</p><p>ES    BP</p><p>SS    SI</p><p>CS    DI</p><p>​         IP(和指令有关)</p><p>​         BX</p><p>u指令：将内存某个地址开始的字节全部当做指令</p><p>d指令：将某个内存地址开始的字节全部当做数据</p><p>指令和数据在内存中是没有区别的</p><p>cpu中的cs段地址寄存器和ip这个偏移地址寄存器组合的时候，从中读取的内容当作指令来执行</p><p>指令是有长度的，一条指令可以由多个字节构成</p><p>执行过程：</p><p>1、cpu从cs:ip所指向的内存单元读取指令，存放到指令缓存器中</p><p>2、ip = ip+所读指令的长度，从而指向下一条指令</p><p>3、执行指令缓存器中的内容，毁到步骤1</p><p>汇编指令 jmp</p><p>转移指令，可以修改cs和ip这两个寄存器 决定了cpu从哪里读取指令</p><p>debug调试工具：</p><ul><li><p>r：可以查看和改变寄存器中的内容</p><p><img src="/Users/duwei/Desktop/source/image/image-20201102234009082.png" alt="image-20201102234009082"></p><p><img src="/Users/duwei/Desktop/source/image/image-20201102234134627.png" alt="image-20201102234134627"></p></li><li><p>d：可以查看内存中的内容</p><p><img src="/Users/duwei/Desktop/source/image/image-20201102234450730.png" alt="image-20201102234450730"></p></li></ul><ul><li><p>u：可以将内存中的机器指令翻译成汇编指令 u:地址</p><p><img src="/Users/duwei/Desktop/source/image/image-20201102234935752.png" alt="image-20201102234935752"></p></li><li><p>a：向内存写入一条汇编指令</p><p><img src="/Users/duwei/Desktop/source/image/image-20201102235151996.png" alt="image-20201102235151996"></p></li><li><p>t：执行当前cs:ip所指向的机器指令</p></li><li><p>e：可以改写内存中的内容</p><p><img src="/Users/duwei/Desktop/source/image/image-20201102235637216.png" alt="image-20201102235637216"></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C深入剖析</title>
      <link href="2021/03/18/C%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/"/>
      <url>2021/03/18/C%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<ul><li><p>定义和声明</p><ul><li><p>定义：编译器创建一个对象，为这个对象分配一块内存并给它取一个名字，名字就是我们常说的变量或对象名。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">;</span></code></pre></li><li><p>声明：告诉编译器，这个名字已经匹配到一块内存上了；告诉编译器，这个名字预定了，其它地方不能再使用，这种声明的最典型例子就是声明一个函数；声明不会分配内存。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">extern</span> inn a<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//声明一个函数</span></code></pre></li></ul></li><li><p>struct</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">struct</span> stu<span class="token punctuation">{</span><span class="token punctuation">}</span> s1<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lu\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 编译器gcc</span></code></pre></li><li><p>柔性数组</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> soft_arr<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lu\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>soft_arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 4</span>    soft_arr <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>soft_arr<span class="token punctuation">)</span><span class="token operator">+</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>结构中最后一个成员允许是一个未知大小的数组，这个成员叫做柔性数组。sizefo 返回这种类型的大小不包括柔性数组的内存。包含柔性数组成员的结构用malloc进行内存动态分配。(应用：比如网络通信，收发数据包)</p></li><li><p>union</p><pre class=" language-c"><code class="language-c"><span class="token keyword">union</span> Person<span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>addr<span class="token punctuation">;</span>    <span class="token keyword">double</span> balance<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lu\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">union</span> Person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>union维护足够的空间来置放多个成员的某一个成员，而不是为每个数据成员配置空间。在union中所有成员公用一个空间，同一时间只能存储其中一个数据成员，所有数据成员拥有相同的起始地址。</p><p>一个union需要配置足够的空间来容纳所有成员。上述例子中：double占用内存空间最大，所以Person的内存大小是8字节。</p><p>大小端对union的影响：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">union</span> T<span class="token punctuation">{</span>    <span class="token keyword">char</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">union</span> T t1<span class="token punctuation">;</span>    t1<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>t1<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><img src="https://upload-images.jianshu.io/upload_images/15150075-33c893aeed324c98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" style="zoom:67%;" /></li><li><p>enum</p><pre class=" language-c"><code class="language-c"><span class="token keyword">enum</span> Color<span class="token punctuation">{</span>    RED<span class="token punctuation">,</span>    BLACK<span class="token punctuation">,</span>    WHITE<span class="token punctuation">,</span>    YELLOW<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    RED <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// expression is not assignable</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>auto</p><p>编译器在默认缺省的情况下，所有变量都是auto。</p></li><li><p>register</p><p>请求编译器尽可能的将这个变量存在cpu内部的寄存器中而不是通过内存寻址访问。register变量可能不存放在内存中，所以不能用&amp;符取地址。</p></li><li><p>static</p><ul><li>修饰变量。<ul><li>变量分局部变量和全局变量，被static修饰它们都存在于内存的静态区。</li><li>静态全局变量：作用域仅限于变量被定义的文件中。</li><li>局部静态变量：只能在定义这个局部静态变量的函数使用，即使函数调用结束，这个变量也不会消失。</li></ul></li><li>修饰函数。<ul><li>函数前加static称为静态函数，静态不是指存储方式，而是此函数的作用域仅限于本文件内。</li></ul></li></ul></li><li><p>switch</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"default\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"2\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"3\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        case c:   // error</span><span class="token comment" spellcheck="true">//            printf("%d",c);</span><span class="token comment" spellcheck="true">//            break;</span><span class="token comment" spellcheck="true">//        case 3.14:    // error</span><span class="token comment" spellcheck="true">//            printf("3.14\n");</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// output:</span><span class="token comment" spellcheck="true">// default</span><span class="token comment" spellcheck="true">// 2</span><span class="token comment" spellcheck="true">// 3</span></code></pre><ul><li>case后只能是整形或字符型常量或常量表达式</li></ul></li><li><p>End0</p></li><li><p>0x01&lt;&lt;2+3</p><p>结果为32，+的优先级比&lt;&lt;高。</p><p>左移右移的位数不能大于数据的长度，不能小于0。</p></li><li><p>++i、i++</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">++</span>i<span class="token punctuation">,</span><span class="token operator">++</span>i<span class="token punctuation">,</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// ++i 先自增再进它其他运算。i在遇见逗号之后认为本计算单位已经结束，然后进行自增。</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"j = %d\n"</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 3</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token punctuation">(</span>k<span class="token operator">++</span><span class="token punctuation">,</span>k<span class="token operator">++</span><span class="token punctuation">,</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// i++ 先进行其它运算再自增</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"z = %d\n"</span><span class="token punctuation">,</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 2</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>x<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"y = %d\n"</span><span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 1+1+1=3 x遇到分号之后才认为本次计算单位已结束，x这时候才会进行自加</span><span class="token punctuation">}</span></code></pre></li><li><p>++i+++i+++i</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> a<span class="token operator">++</span><span class="token operator">+</span>b<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 贪心算法：a++ + b</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ret = %d\n"</span><span class="token punctuation">,</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// ret = 3</span><span class="token punctuation">}</span></code></pre></li><li><p>#define宏定义注释符号</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> BSC </span><span class="token comment" spellcheck="true">//</span><span class="token macro property">#<span class="token directive keyword">define</span> BMC </span><span class="token comment" spellcheck="true">/*#define EMC */</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>BSC a is <span class="token keyword">int</span>    DMC input a number<span class="token punctuation">:</span>EMC<span class="token punctuation">}</span></code></pre><p>注释先于预处理指令被处理。当发生宏替换时，注释已经处理完毕，再出现//、/*则会出现错误。</p></li><li><p>宏定义中的空格</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> SUM(x) (x)+(x)</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">SUM</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个空格仅在定义的时候有效，在使用这个宏函数的时候，空格会被忽略掉。因此：SUM(x) 和SUM (x)是一样的。</p><pre class=" language-shell"><code class="language-shell">duweideMacBook-Pro:test duwei$ cat test.c#define SUM(x) (x)+(x)int main(){    int ret = SUM (3);    return 0;}duweideMacBook-Pro:test duwei$ gcc -E test.c -o test.iduweideMacBook-Pro:test duwei$ cat test.i# 1 "test.c"# 1 "<built-in>" 1# 1 "<built-in>" 3# 361 "<built-in>" 3# 1 "<command line>" 1# 1 "<built-in>" 2# 1 "test.c" 2</code></pre></li></ul><p>  int main(){<br>   int ret = (3)+(3);<br>   return 0;<br>  }<br>  duweideMacBook-Pro:test duwei$</p><pre><code>- 预处理余下部分暂时省略，以后回来看- 略- 略- 略- int *p = NULL和 *p = NULL的区别  - ```c    int *p = NULL;    ```    定义一个指针变量p，其指向的内存里面保存的是int类型的数据，在定义变量p的同时把p的值设为0x00000000，这个过程叫初始化，是在编译的时候进行的。  - ```c    int *p;    *p = NULL;    ```    第一行代码，定义了一个指针变量p，其指向内存里保存的是int类型的数据，此时p变量本身是多少不可知，也就是说p变量此时指向的内存地址可能是个非法值。第二行代码给*p赋值为NULL，也就是给 *p指向的内存赋值NULL。由于p变量的内存地址可能是非法的，所以在调试时编译器可能会报错。- ```c  int main(){      char *p1 = &quot;abcdef&quot;;      printf(&quot;p1 = %p\n&quot;,p1);         // p1 = 0x109002f82      printf(&quot;p1 = %p\n&quot;,p1+1);       // p1 = 0x109002f82      printf(&quot;p1 = %p\n&quot;,p1+2);       // p1 = 0x109002f82      printf(&quot;&amp;p1 = %p\n&quot;,&amp;p1);       // &amp;p1 = 0x7ffee6bfda48      char p2[] = &quot;123456&quot;;      printf(&quot;p2 = %p\n&quot;,p2);         // p2 = 0x7ffee6bfda41      printf(&quot;&amp;p2 = %p\n&quot;,p2+1);      // &amp;p2 = 0x7ffee6bfda42      printf(&quot;&amp;p2 = %p\n&quot;,p2+2);      // &amp;p2 = 0x7ffee6bfda43  }</code></pre><p>  <img src="https://upload-images.jianshu.io/upload_images/15150075-95496cd76b42207b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="p1的访问方式"></p><p>  <img src="https://upload-images.jianshu.io/upload_images/15150075-586f59dc81a1ece9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="p2的访问方式"></p><p>  结论：</p><ul><li>数组名即为数据本身</li><li>数组作为参数传递给函数时，数组的地址赋值给形参，发生降维。</li></ul><ul><li><p>a和&amp;a的区别(数组名)</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*(a+1)=%d\n*(ptr-1))=%d\n"</span><span class="token punctuation">,</span><span class="token operator">*</span><span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// *(a+1)=2，*(ptr-1))=5</span><span class="token punctuation">}</span></code></pre><p>结论：</p><ul><li>&amp;a代表的是数组地址，&amp;a+1，加上的是sizeof(a)，指向a[4]的下一个元素。</li><li>a代表的是首元素地址。</li></ul></li><li><p>定义为数组，声明为指针</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>将arr声明为指针会造成访问方式的错误，得出意外的结果。本应该是直接读取到arr的内存地址然后进行偏移操作，但是这里声明为指针，导致了访问方式的改变，访问时会先读取arr所在内存空间存放的内存地址，然后再进行偏移操作。</p></li><li><p>定义为指针，声明为数组</p><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">extern</span> <span class="token keyword">char</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>也会因为定义和声明的方式不一样造成访问方式不一样从而得到意外的结果。</p></li><li><p>指针和数组对比</p><table><thead><tr><th>指针</th><th>数组</th></tr></thead><tbody><tr><td>保存数据的地址，任何被存入指针变量p的数据都会被当做地址处理。p本身的地址有编译器另外存储，存储在哪里我们并不知道。</td><td>保存数据，数组名a代表的是数组首元素的地址而不是数组的首地址，&amp;a才是整个数组的首地址。a本身的地址由编译器另外存储，存储在哪里，我们并不知道。</td></tr><tr><td>间接访问数据，首先取得指针变量p的内容，把它当做地址，然后从这个地址提取或者写入数据。指针可以以指针的形式访问*(p+i)；也可以以下标的方式访问p[i]。但是其本质都是先取p的内容然后加上 i * sizeof(类型)个byte作为数据的真正地址。</td><td>直接访问数据，数组名a是整个数组的名字，数组内每个元素并没有名字。只能通过”具名+匿名”的方式来访问其它某个元素，不能把数组当做一个整体来进行读写操作。数组可以以指针的形式访问*(pa+i)；也可以以下标的方式访问a[i]。但其本质都是a所代表的数组的首元素地址加上 i * sizeof(类型)个byte作为数据的真正地址。</td></tr><tr><td>通常用于动态数据结构</td><td>通常用于存储固定数目且数据类型相同的元素</td></tr><tr><td>相关函数malloc和free</td><td>隐式分配和删除</td></tr><tr><td>通常指向匿名数据（也可指向具名数据）</td><td>自身即为数组名</td></tr></tbody></table></li><li><p>地址强制转换</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>ptr1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>ptr2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ptr1[-1] = %x\n"</span><span class="token punctuation">,</span>ptr1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*ptr2 = %x\n"</span><span class="token punctuation">,</span><span class="token operator">*</span>ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>32位系统下：</p><p><img src="https://upload-images.jianshu.io/upload_images/15150075-c638b8896fc9d3be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>64位系统下会报错：Segmentation fault</p><p>个人看法：a代表的是首元素地址，将其强转成int然后+1再强转成int<em>，即将a地址进行+1操作然后赋值给ptr2。在32位下指针的长度和 int\</em> 类型的长度相同，所以不会发生提升。但是在64位下，将4位的int* 提升为8位的地址会发生提升，提升后的地址远远大于当前数组所有元素的地址，所以在进行printf访问打印时会报错：Segmentation fault。</p></li><li><p>&amp;p[4][2] - &amp;a[4][2] 等于多少？</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p,%d\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>p<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>p<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="https://upload-images.jianshu.io/upload_images/15150075-59a8fe82de0a6d11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" 是"></p></li><li><p>无法向一个函数传递数组</p><ul><li>C语言中，当一维数组作为函数参数时，编译器总把它解析成一个指向其首元素地址的指针。</li><li>函数本身没有类型，只有函数的返回值才有类型。</li></ul></li><li><p>能否把指针变量本身传递给一个函数</p><p>main函数中的变量不是全局变量，只不过是它的声明周期和全区变量一样长而已。全局变量定义在函数外部。</p></li><li><p>函数指针的定义</p><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>func1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> p1<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>func1是一个指针变量，指向一个有两个char*类型参数且返回值是char*类型的函数</p></li><li><p>*(int*)&amp;p</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 32位</span><span class="token keyword">void</span> <span class="token function">Function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Call Function.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Function<span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>p是一个指针变量，指向一个无参数无返回值的函数；</p><p>(int*)&amp;p将p的地址强转成int数据类型的指针；</p><p>*(int*)&amp;p 就是一个整型，要将函数Function的地址赋值给p得先将其转为整型。</p></li><li><p>(*(void(*)())0)();</p><p>void(*)()：表示一个指针，指向一个返回值时void且没有参数的函数。</p><p>(void(*)())0：表示将0强制转换成void(*)()这个函数指针类型。</p><p>(*(void(*)())0)：获取地址0开始的内存中的一段内容(解引用)。</p><p>(*(void(*)())0)()：函数调用。</p></li><li><p>函数指针数组</p><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// pf1是一个指向参数是char *类型，返回值时char*的函数的指针</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// pf2是函数指针数组</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">func3</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>func1<span class="token punctuation">;</span>    pf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>func2<span class="token punctuation">;</span>    pf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span>func3<span class="token punctuation">;</span>    pf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token string">"func1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token string">"func2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token string">"func3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>函数指针数组的指针</p><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// pf2是函数指针数组</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>pf2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// pf2是函数指针数组指针</span></code></pre></li><li><p>常见内存错误以及对策</p><ul><li><p>指针没有指向一块合法的内存</p><ul><li><p>结构体成员指针未初始化</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> student<span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>    <span class="token keyword">int</span> score<span class="token punctuation">;</span><span class="token punctuation">}</span>stu<span class="token punctuation">,</span><span class="token operator">*</span>pstu<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>stu<span class="token punctuation">.</span>name<span class="token punctuation">,</span><span class="token string">"jim"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stu<span class="token punctuation">.</span>score<span class="token operator">=</span><span class="token number">99</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在实例化stu时，给name分配了四字节的内存，但并没有指向合法的地址。调用strcpy往所指向的内存拷贝”jim”，这块内存name指针根本就无权访问，导致出错。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">struct</span> student<span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>    <span class="token keyword">int</span> score<span class="token punctuation">;</span><span class="token punctuation">}</span>stu<span class="token punctuation">,</span><span class="token operator">*</span>pstu<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    stu<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>stu<span class="token punctuation">.</span>name<span class="token punctuation">,</span><span class="token string">"jim"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stu<span class="token punctuation">.</span>score<span class="token operator">=</span><span class="token number">99</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>stu<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>pstu<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>没有为结构体指针分配足够的内存</p></li><li><p>函数入口校验</p><pre class=" language-c"><code class="language-c"><span class="token function">assert</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">!=</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 是一个宏而非函数</span></code></pre></li></ul></li><li><p>为指针分配的内存太小</p></li><li><p>内存分配成功，但未初始化</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//在不确定变量初始值的时候可以初始化为0或者NULL</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//或者使用memset(起始地址,要被设置的值,要被设置的内存大小);</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongo</title>
      <link href="2021/03/18/mongo/"/>
      <url>2021/03/18/mongo/</url>
      
        <content type="html"><![CDATA[<h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><h6 id="mongo备份-mongoexport导出json文件"><a href="#mongo备份-mongoexport导出json文件" class="headerlink" title="mongo备份: mongoexport导出json文件"></a>mongo备份: mongoexport导出json文件</h6><pre class=" language-shell"><code class="language-shell">./mongoexport --host 0.0.0.0:65535 -u username -p password --authenticationDatabase admin -d database -c collection -o file.json</code></pre><h6 id="mongo恢复-mongoimport导入json文件"><a href="#mongo恢复-mongoimport导入json文件" class="headerlink" title="mongo恢复: mongoimport导入json文件"></a>mongo恢复: mongoimport导入json文件</h6><pre class=" language-shell"><code class="language-shell">./mongoimport --host 0.0.0.0:65535 -u username -p password  --authenticationDatabase admin  -d database -c collection --file file.json</code></pre><h6 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合:"></a>创建集合:</h6><pre class=" language-sql"><code class="language-sql"><span class="token number">db</span><span class="token punctuation">.</span>createCollection<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h6 id="查看库信息"><a href="#查看库信息" class="headerlink" title="查看库信息:"></a>查看库信息:</h6><pre class=" language-sql"><code class="language-sql"><span class="token number">db</span><span class="token punctuation">.</span>stats<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="查看集合信息"><a href="#查看集合信息" class="headerlink" title="查看集合信息:"></a>查看集合信息:</h6><pre class=" language-sql"><code class="language-sql"><span class="token number">db</span><span class="token punctuation">.</span>collection<span class="token punctuation">.</span>stats<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><hr><h5 id="mongo遇见的一些问题"><a href="#mongo遇见的一些问题" class="headerlink" title="mongo遇见的一些问题"></a>mongo遇见的一些问题</h5><h6 id="删除数据，磁盘空间不释放"><a href="#删除数据，磁盘空间不释放" class="headerlink" title="删除数据，磁盘空间不释放:"></a>删除数据，磁盘空间不释放:</h6><p><code>db.collection.remove({}, {multi: true})</code>命令删除文档，删除之后不会将被删除数据的磁盘空间归还给操作系统，但是当有新数据插入时mongo能重新使用这块空间。(<a href="https://help.aliyun.com/document_detail/96530.html?spm=a2c4g.11186623.2.13.6cd05d5dLZVLZJ" target="_blank" rel="noopener">解决办法</a>)</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C和指针</title>
      <link href="2021/03/18/C%E5%92%8C%E6%8C%87%E9%92%88/"/>
      <url>2021/03/18/C%E5%92%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h4 id="第3章"><a href="#第3章" class="headerlink" title="第3章"></a>第3章</h4><h5 id="3-1-基本数据类型"><a href="#3-1-基本数据类型" class="headerlink" title="3.1 基本数据类型"></a>3.1 基本数据类型</h5><h6 id="3-1-1-整形家族"><a href="#3-1-1-整形家族" class="headerlink" title="3.1.1 整形家族"></a>3.1.1 整形家族</h6><p>长整型至少应该和整型一样，而整型至少应该和短整型一样长。</p><p>一、整型字面值</p><p>初始化之后不可以被修改。</p><p>在整数字面值后面添加L或l，可以使这个整数被解释为long类型值，字符U或u则用于把数值指定为unsigned整型值。如果添加lu则被解释为 unsigned long 整型值。字符常量的类型总是int。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token number">123L</span><span class="token punctuation">;</span>    <span class="token number">123u</span><span class="token punctuation">;</span>    <span class="token number">123LU</span><span class="token punctuation">;</span>    <span class="token number">0123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8进制</span>    <span class="token number">0x1561</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 16进制</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lu\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 4</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>二、枚举类型</p><p>以整型方式存储。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">enum</span> age<span class="token punctuation">{</span>    a<span class="token punctuation">,</span>    b<span class="token punctuation">,</span>    c<span class="token punctuation">,</span>    d<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h6 id="3-1-1-浮点类型"><a href="#3-1-1-浮点类型" class="headerlink" title="3.1.1 浮点类型"></a>3.1.1 浮点类型</h6><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lu\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8,缺省时默认为double类型</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lu\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token number">3.14l</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 16,long double</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lu\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token number">3.14f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 4</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lu\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lu\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 4</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h6 id="3-1-3-指针"><a href="#3-1-3-指针" class="headerlink" title="3.1.3 指针"></a>3.1.3 指针</h6><p>把内存想象成一条长街，每间房子都用一个唯一的号码进行标识。每一个位置包含一个值，这和它的地址式独立且显著不同的，即使他们都是数字。</p><p>一、指针常量</p><p>二、字符串常量</p><p>字符串：一串以NUL字节结尾的零个或多个字符。字符串通常存储在字符数组总，所以c语言中没有显示的字符串类型。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lu\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1，虽然字符串为空，但是还是会分配内存</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在程序中使用字符串常量时会生成一个“指向字符的常量指针”，当一个字符串常量出现于一个表达式中时，表达式所使用的值就是这些字符所存储的地址，而不是这些字符本身。因此，可以把字符串常量赋值给一个“指向字符的指针”。但是不能把字符串常量赋值给一个字符数组，因为字符串常量的直接值是一个指针，而不是这些字符本身。</p><h5 id="3-2-基本申明"><a href="#3-2-基本申明" class="headerlink" title="3.2 基本申明"></a>3.2 基本申明</h5><p>int a;</p><h6 id="3-2-1-初始化"><a href="#3-2-1-初始化" class="headerlink" title="3.2.1 初始化"></a>3.2.1 初始化</h6><h6 id="3-2-2-声明简单数组"><a href="#3-2-2-声明简单数组" class="headerlink" title="3.2.2 声明简单数组"></a>3.2.2 声明简单数组</h6><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><h6 id="3-2-3-声明指针"><a href="#3-2-3-声明指针" class="headerlink" title="3.2.3 声明指针"></a>3.2.3 声明指针</h6><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">,</span><span class="token operator">*</span>c<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>message <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*char *message;message = "hello world";*/</span></code></pre><h6 id="3-2-4-隐式声明"><a href="#3-2-4-隐式声明" class="headerlink" title="3.2.4 隐式声明"></a>3.2.4 隐式声明</h6><p>函数如果不显示的声明返回值的类型，就默认返回整型。</p><pre class=" language-c"><code class="language-c"><span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ret = %d\n"</span><span class="token punctuation">,</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="3-3-typedef"><a href="#3-3-typedef" class="headerlink" title="3.3 typedef"></a>3.3 typedef</h5><p>为数据类型定义新的名字，而不是产生新的类型。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token keyword">const</span> a<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 二者等价</span><span class="token keyword">int</span> <span class="token keyword">const</span> <span class="token operator">*</span>pi<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// const修饰 *pi ，可以修改pi的值但是不可以修改pi所指向的地址的值</span><span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> cpi<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 可以修改cpi所指向地址的值但是不可以修改cpi指向的地址。</span><span class="token keyword">int</span> <span class="token keyword">const</span> <span class="token operator">*</span> <span class="token keyword">const</span> cpci<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 无论是cpci指针本身还是它所指向的地址的值 都不可以修改</span></code></pre><h5 id="3-5-作用域"><a href="#3-5-作用域" class="headerlink" title="3.5 作用域"></a>3.5 作用域</h5><h6 id="3-5-1-代码块作用域"><a href="#3-5-1-代码块作用域" class="headerlink" title="3.5.1 代码块作用域"></a>3.5.1 代码块作用域</h6><p>任何在代码块的开始位置声明的标识符都具有代码块作用域。</p><h6 id="3-5-2-文件作用域"><a href="#3-5-2-文件作用域" class="headerlink" title="3.5.2 文件作用域"></a>3.5.2 文件作用域</h6><p>在代码块之外声明的标识符都具有文件作用域。</p><h6 id="3-5-3-原型作用域"><a href="#3-5-3-原型作用域" class="headerlink" title="3.5.3 原型作用域"></a>3.5.3 原型作用域</h6><p>只适用于在函数原型中声明的参数名。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><h5 id="3-6-链接属性"><a href="#3-6-链接属性" class="headerlink" title="3.6 链接属性"></a>3.6 链接属性</h5><p>标识符的链接属性决定如何处理在不同文件中出现的标识符。</p><p>链接属性</p><ul><li><p>external (extern)</p><p>属于external链接属性的表示符不论声明多少次、位于几个源文件都表示同一实体。</p></li><li><p>internal (static)</p><p>属于internal的连接属性的标识符在同一源文件内的所有声明中都指同一个实体。</p></li><li><p>none (auto)</p><p>没有链接属性的标识符总是被当做单独的个体。</p></li></ul><h5 id="3-7-存储类型"><a href="#3-7-存储类型" class="headerlink" title="3.7 存储类型"></a>3.7 存储类型</h5><p>变量的存储类型是指存储变量值的内存类型。变量的存储类型决定变量何时创建、何时销毁以及它的值将保持多久。</p><ul><li>普通内存</li><li>运行时堆栈</li><li>硬件寄存器</li></ul><p>变量的缺省存储类型取决于它的声明位置。在任何代码块之外声明的变量总是存储于静态内存中(不属于堆栈)，这类变量称为静态变量。静态变量在程序运行之前创建，在程序的整个执行期间始终存在。</p><p>在代码块内部声明的变量的缺省内存存储类型是自动的(automatic)，它存储于堆栈中，称为自动(auto)变量。在程序执行到声明自动变量的代码块时，自动变量才被创建，当程序离开该代码块时自行销毁。</p><p>对于在代码块内部声明的变量，加上static关键字，可以使它的存储类型从自动变为静态。具有静态存储类型的变量在整个程序执行过程中一直存在，而不仅仅在声明它的代码块的执行时存在。修改变量的存储类型并不表示修改该变量的作用域，它仍然只能在该代码块内部按变量名访问。函数形式参数不能声明为静态，因为实参总是在堆栈中传递给函数，用于支持递归。</p><p>register可以用于自动变量声明，提示他们应该存储于机器的硬件寄存器而不是内存中，这类变量称为寄存器变量(因为不在内存中，所以不能用&amp;取地址。)</p><p>初始化</p><ul><li><p>静态变量</p><p>静态变量的初始化中，可以把可执行程序文件想要初始化的值放在当程序执行时变量将会使用的位置。当可执行文件载入到内存时，这个已经保存了正确初始值的位置将赋值给那个变量。完成这个任务并不需要额外时间，也不需要额外指令，变量将会得到正确的值。如果不显式的指定其初始值，静态变量将初始化为0。</p></li><li><p>自动变量</p><p>自动变量初始化需要更多的开销，因为当程序链接时还无法判断自动变量的存储位置。</p></li></ul><h4 id="第六章-指针"><a href="#第六章-指针" class="headerlink" title="第六章 指针"></a>第六章 指针</h4><h5 id="6-14-总结"><a href="#6-14-总结" class="headerlink" title="6.14 总结"></a>6.14 总结</h5><p>声明一个指针变量并不会自动分配任何内存。</p><h5 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章 函数"></a>第七章 函数</h5><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span><span class="token operator">*</span><span class="token function">find_int</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这种声明方式，也就是用单独的一行给出参数的类型，那么编译器就只记住函数返回值的类型，不保存函数的参数数量和类型信息。</p><pre><code>int func();这种声明会被解释为旧式风格的声明，只保存了函数的返回值类型。int func(void);使用新风格原型时，得加上void提示没有任何参数</code></pre><h5 id="7-3-函数的参数"><a href="#7-3-函数的参数" class="headerlink" title="7.3 函数的参数"></a>7.3 函数的参数</h5><p>C函数的所有参数均以“值传递调用”方式进行传递。(参数为指针时也会发生值拷贝，拷贝地址)</p><h5 id="7-6-可变参数列表"><a href="#7-6-可变参数列表" class="headerlink" title="7.6 可变参数列表"></a>7.6 可变参数列表</h5><h6 id="7-6-1-stdarg宏"><a href="#7-6-1-stdarg宏" class="headerlink" title="7.6.1 stdarg宏"></a>7.6.1 stdarg宏</h6><h4 id="第八章-数组"><a href="#第八章-数组" class="headerlink" title="第八章 数组"></a>第八章 数组</h4><ul><li><p>下标：为了对下标表达式求值，编译器在程序中插入指令，取得a的值，并把它与整形的长度(也就是4)相乘，这个乘法需要花费一定的时间和空间。</p></li><li><p>指针：尽管不存在下标，但还是存在乘法运算，1这个值必须和整数的长度相乘，然后再与指针相加。但是这里存在一个重大区别：循环每次执行时，执行乘法的运算都是两个相同的数(1和4)。结果，这个乘法只在编译时执行一次—-程序现在包含了一条指令，把4与指针相加。程序在执行时并不执行乘法运算。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token operator">*</span>ap<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 下标</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>ap <span class="token operator">=</span> arr<span class="token punctuation">;</span> ap <span class="token operator">&lt;</span> arr<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>ap<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 指针</span>        <span class="token operator">*</span>ap <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><h5 id="8-1-一维数组"><a href="#8-1-一维数组" class="headerlink" title="8.1 一维数组"></a>8.1 一维数组</h5><h6 id="8-1-1-数组名"><a href="#8-1-1-数组名" class="headerlink" title="8.1.1 数组名"></a>8.1.1 数组名</h6><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 标量</span><span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 集合，称为数组</span></code></pre><p>数据名是常量指针。</p><p>数组名在两种情况下表示整个数组，其余一律表示首元素。</p><pre><code>int arr[10];sizeof(arr);&amp;arr;</code></pre><h6 id="8-1-2-下标引用"><a href="#8-1-2-下标引用" class="headerlink" title="8.1.2 下标引用"></a>8.1.2 下标引用</h6><p>数组下标引用和间接访问完全相同。</p><p>C检查下标所涉及的开销比你想象的大得多。编译器必须在程序中插入指令，证实下标表达式的结果所引用的元素和指针表达式所指向的元素属于同一数组。这个比较操作需要程序中所有数组的位置和长度方面的信息。这将占用一些空间。当程序运行时，这些信息必须进行更新，以反映自动和动态分配的数组，这又将占用一定的时间。</p><h6 id="8-1-3-指针与下标"><a href="#8-1-3-指针与下标" class="headerlink" title="8.1.3 指针与下标"></a>8.1.3 指针与下标</h6><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> arr1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span>a<span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> a <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        arr1<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>为了对下标表达式求值，编译器在程序中插入指令，取得a的值，并把它与整形的长度(4)相乘。这个乘法需要花费一定的空间和时间。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> arr2<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">*</span>ap<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>ap<span class="token operator">=</span>arr2<span class="token punctuation">;</span> ap <span class="token operator">&lt;</span> arr2<span class="token punctuation">;</span> <span class="token operator">++</span>ap<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>ap <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里的乘法运算出现在for语句的调整部分(++ap)，1这个值必须与整形的长度相乘，然后再与指针相加。但是这里存在很大的区别：循环每次执行时，执行乘法运算的都是两个相同的数(1和4)。结果这个乘法只会在编译时执行一次—-程序包含一条指令，把4与指针相加。程序在运行时并不执行乘法运算。</p><h6 id="8-1-4-指针的效率"><a href="#8-1-4-指针的效率" class="headerlink" title="8.1.4 指针的效率"></a>8.1.4 指针的效率</h6><h6 id="8-1-5-指针和数组"><a href="#8-1-5-指针和数组" class="headerlink" title="8.1.5 指针和数组"></a>8.1.5 指针和数组</h6><p>数组和指针不相等。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span></code></pre><p>声明一个数组时，编译器将根据声明所指定的元素数量为数组保存内存空间，然后创建数组名，它的值是一个常量，指向这段空间的起始位置。</p><p>声明一个指针变量时，编译器只为指针本身保留内存空间，它并不为任何整形值分配内存空间。而且指针变量并未被初始化为指向任何现有的内存空间，如果是一个自动变量，它甚至不会被初始化。</p><p>因此：*a是合法的。*b将访问内存中某个不确定的位置，或者导致程序终止。但是b++可以通过编译，a++缺不行，因为a是一个常量。</p><h6 id="8-1-6-作为函数参数的数组名"><a href="#8-1-6-作为函数参数的数组名" class="headerlink" title="8.1.6 作为函数参数的数组名"></a>8.1.6 作为函数参数的数组名</h6><p>一个数组名作为参数传递给函数：在函数传参时就会发生拷贝。可知数组是一个地址常量，在传参给函数时，发生地址拷贝，数组名(地址常量)传递给函数的形参，形参实例化成一个指针变量，指针变量存放数组的地址常量。因此数组地址传入函数之后，发生降维，降维成一个指针。函数如果执行了下标应用，实际山是对这个指针进行间接访问操作，并且通过这种间接访问，函数可以访问和修改调用程序的数组元素。</p><h6 id="8-1-7-声明数组参数"><a href="#8-1-7-声明数组参数" class="headerlink" title="8.1.7 声明数组参数"></a>8.1.7 声明数组参数</h6><pre><code>int strlen(char *string);int strlen(char string[]);</code></pre><h6 id="8-1-8-初始化"><a href="#8-1-8-初始化" class="headerlink" title="8.1.8 初始化"></a>8.1.8 初始化</h6><pre><code>char message1[] = &quot;Hello&quot;;char *message2 = &quot;Hello&quot;;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/15150075-912a16aa87956bdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h6 id="8-2-3-下标"><a href="#8-2-3-下标" class="headerlink" title="8.2.3 下标"></a>8.2.3 下标</h6><pre><code>int matrix[3][10];</code></pre><ul><li><p>matrix</p><p><img src="https://upload-images.jianshu.io/upload_images/15150075-4e7271031de98d6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>martrix此时指向第一个二维数组</p></li><li><p>matrix+1</p><p><img src="https://upload-images.jianshu.io/upload_images/15150075-cf614cf0e6dea534.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>*(matrix+1)</p><p><img src="https://upload-images.jianshu.io/upload_images/15150075-abe44a68c361cd8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>*(matrix+1)+5</p><p><img src="https://upload-images.jianshu.io/upload_images/15150075-921e9fc90ec740f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li></ul><h5 id="8-5-总结"><a href="#8-5-总结" class="headerlink" title="8.5 总结"></a>8.5 总结</h5><ul><li>在绝大多数表达式中，数组名是指向数组第一个元素的指针。只有两个规则例外：<ul><li>sizeof(arr)，返回整个数组占用的字节，而不是返回指针占用的字节。</li><li>&amp;arr，单目操作符&amp;返回一个指向整个数组的指针，而不是指向数组第一个元素的指针的指针。</li></ul></li><li>指针和数组不相等。<ul><li>声明一个数组，同时也分配了一些内存，用于容纳数组元素。</li><li>声明一个指针，只分配用于容纳指针本身的空间。</li></ul></li><li>当数组名作为函数参数传递。实际传递的是一个指向数组第一个元素的指针。函数所接收到的参数实际上是原参数的一份拷贝，所以函数可以对其进行操纵而不影响实际的参数。但是对指针执行间接访问操作允许函数修改原先数组的元素。</li><li>数组形参既可以声明成数组也可以声明成指针，这两种声明形式只有当他们作为函数形参时才相等。</li></ul><h4 id="第九章-字符串、字符和字节"><a href="#第九章-字符串、字符和字节" class="headerlink" title="第九章 字符串、字符和字节"></a>第九章 字符串、字符和字节</h4><h5 id="9-1-字符串基础"><a href="#9-1-字符串基础" class="headerlink" title="9.1 字符串基础"></a>9.1 字符串基础</h5><p>字符串是一串零个或多个字符，以NUL结尾。</p><h5 id="9-3-不受限制的字符串函数"><a href="#9-3-不受限制的字符串函数" class="headerlink" title="9.3 不受限制的字符串函数"></a>9.3 不受限制的字符串函数</h5><h6 id="9-3-1-复制字符串"><a href="#9-3-1-复制字符串" class="headerlink" title="9.3.1 复制字符串"></a>9.3.1 复制字符串</h6><p>char *strcpy(char *dst, char const *src);</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> dest<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abcde"</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>dest<span class="token punctuation">,</span><span class="token string">"xyz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>dest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// xyz</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>目标参数以前的内容将被覆盖，即使新的字符串比dest原先的内存更短。(NUL也会被复制)</p><p><img src="https://upload-images.jianshu.io/upload_images/15150075-5f82cd2ae2a6e440.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h6 id="9-3-2-连接字符串"><a href="#9-3-2-连接字符串" class="headerlink" title="9.3.2 连接字符串"></a>9.3.2 连接字符串</h6><p>char * strcat(char *dst, char const *src);</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> message<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">strcat</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">strcat</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span><span class="token string">" world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h6 id="9-3-3-函数的返回值。"><a href="#9-3-3-函数的返回值。" class="headerlink" title="9.3.3 函数的返回值。"></a>9.3.3 函数的返回值。</h6><p>strcpy和strcat都返回它们第一个参数的一份拷贝，就是指向目标字符数组的指针。</p><h6 id="9-3-4-字符串比较"><a href="#9-3-4-字符串比较" class="headerlink" title="9.3.4 字符串比较"></a>9.3.4 字符串比较</h6><p>int strcmp(char const *s1, char const *s2);</p><pre><code>int main(){    int ret = strcmp(&quot;duwei&quot;,&quot;zhangsan&quot;);    /*    if (ret){ // ret的值有三种情况：大于0，等于0，小于0。将其用bool值表达是一种坏风格，正确的方式是将其与0值进行比较        printf(&quot;duwei &gt; zhangsan&quot;);    }    */    if (ret &gt; 0){        printf(&quot;duwei &gt; zhangsan&quot;);    }    return 0;}</code></pre><h5 id="9-5-字符串查找"><a href="#9-5-字符串查找" class="headerlink" title="9.5 字符串查找"></a>9.5 字符串查找</h5><h6 id="9-5-1-查找一个字符"><a href="#9-5-1-查找一个字符" class="headerlink" title="9.5.1 查找一个字符"></a>9.5.1 查找一个字符</h6><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> message<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"learn C language."</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token function">strchr</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回第一次出现的位置</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p1 - message = %lu\n"</span><span class="token punctuation">,</span>p1<span class="token operator">-</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token function">strrchr</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回最后一次出现的位置</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p2 - message = %lu\n"</span><span class="token punctuation">,</span>p2<span class="token operator">-</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h6 id="9-5-2-查找任何几个字符"><a href="#9-5-2-查找任何几个字符" class="headerlink" title="9.5.2 查找任何几个字符"></a>9.5.2 查找任何几个字符</h6><p>char *strpbrk(char const *str, char const *group); 查找一组字符串在字符串中第一次出现的位置。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> message<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"learn C language."</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">strpbrk</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span><span class="token string">"zC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回z或者C第一次出现的位置，</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h6 id="9-5-3-查找一个子串"><a href="#9-5-3-查找一个子串" class="headerlink" title="9.5.3 查找一个子串"></a>9.5.3 查找一个子串</h6><p>char *strstr(char const *s1, char const *s2);</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> message<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"learn C language."</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">strstr</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span><span class="token string">"lang"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="9-9-内存操作"><a href="#9-9-内存操作" class="headerlink" title="9.9 内存操作"></a>9.9 内存操作</h5>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C Primer Plus</title>
      <link href="2021/03/18/C%20Primer%20Plus/"/>
      <url>2021/03/18/C%20Primer%20Plus/</url>
      
        <content type="html"><![CDATA[<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span> </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span> </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stddef.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> LEN 40</span><span class="token macro property">#<span class="token directive keyword">define</span> MAX 41</span><span class="token comment" spellcheck="true">/*常量：在程序使用之前已经预设定好，在整个程序的运行过程中没有变化变量：在程序运行期间可能会被改变或者赋值数据：    显示十进制数：%d    显示八进制数：%o    显示十六进制数：%x指针&amp;数组：    数组名是首元素地址：        arr[i]=*(arr+i) 二者等价        特殊情况：            1. sizeof(数组名) - 数组名表示整个数组            2. &amp;数组名 - 数组名表示整个数组    指针操作：        赋值：可以把地址赋给指针        解引用：*运算符获得指针指向地址上存储的值        取地址：&amp;运算符，指针也拥有自己的地址        指针与整数相加：int *a = 1; a+1 即 a的地址 + sizeof(int)*1，步长为a指向的数据类型的大小        指针求差        比较：如果要使用关系运算符比较两个指针，那么要确保两个指针指向同一数据类型的对象        解引用未初始化的指针：严重的错误            int main(void){                int *pt; //错误写法                int *pt = NULL; //正确写法                *pt = 100; // pt在定义之后未被初始化，其值是一个随机值，不能确定100的存储位置，这可能不会出什么错，但是也有可能擦写数据或代码，导致程序崩溃，因此创建指针必须初始化，特殊情况下可以将指针指向NULL                printf("%d\n", *p);                return 0;            }    const：        1、把const或者非const数据的地址初始化为指向const的指针或者为其赋值是合法的。            int main(void){                int arr1[10] = {1,2,3,4,5,6,7,8,9,10};                const int arr2[10] = {11,12,13,14,15,16,17,18,19,20};                 const int * pt = arr1; //把pt指向的int类型的值声明为const(注意是值而非地址)，所以不能够用*pt修改数组的值，但是能修改pt所指向的地址                pt = arr2;                pt = &amp;arr1[3];                return 0;            }        2、只能把非const数据的地址赋给普通指针，            int main(void){                int arr1[10] = {1,2,3,4,5,6,7,8,9,10};                const int arr2[10] = {11,12,13,14,15,16,17,18,19,20};                const int * pt = arr1;                int * pt2 = arr1;                pt2 = arr2; //非法，只能将非const的数据的地址赋值给普通指针，否则通过指针就能改变const数组中的数组，显然不合理。                pt2 = &amp;arr1[3];                return 0;            }        3、创建一个不能改变指向地址的指针，但是能改变指针指向的地址的值                int main(void){                    int arr1[10] = {1,2,3,4,5,6,7,8,9,10};                    const int arr2[10] = {11,12,13,14,15,16,17,18,19,20};                    const int * pt = arr1;                    int * pt2 = arr1;                    pt2 = &amp;arr1[3];                    int * const pt3 = arr1;                    pt3 = &amp;arr1[3]; //非法                    *(pt3+1) = 100;                     printf("new = %d\n",arr1[1]);                    return 0;                }    指针和多维数组：        int main(void){            int arr[3][4];            printf("%d\n",**arr); // arr = arr[0] = &amp;arr[0][0],**arr 与 *&amp;arr[0][0]等价，**arrd第一次解引用表示arr[0],此时仍然是个地址所以需要再次解引用            printf("arr = %p, arr[0] = %p, arr[0][0] = %p\n",arr,arr[0],&amp;arr[0][0]); // arr = 0x7ffeeeec7be0, arr[0] = 0x7ffeeeec7be0, arr[0][0] = 0x7ffeeeec7be0            return 0;        }    指向数组的指针：        int *p[]; //指针数组        int (*p)[]; // 数组指针                ----例题：                    int main(void){                        int arr[10] = {100 ,2,3,4,5,6,7,8,9,10};                        int res = max(arr);                        printf("%d\n",res);                        return 0;                    }                    int max(int *arr){                        int temp;                        for (int i = 1; i &lt; 10; ++i)                        {                            if (arr[0]&lt;arr[i])                            {                                temp = arr[0];                                arr[0] = arr[i];                                arr[i] = temp;                            }                        }                        return arr[0];                    }分配内存 malloc 和 free    之前所使用的的存储类别有一个共同之处：在确定存储类别之后，根据已定制好的内存管理规则，将自动选择其作用域和存储期，然而还有更灵活的选择，即使用库函数分配和管理内存。    int main(){    double * ptd1;    ptd1 = (double *)malloc(30 * sizeof(double));  //为30个double类型的值申请内存空间，并让ptd指向该片内存的首地址。double类型且长度为30的数组    if (ptd1==NULL){        printf("内存分配失败\n");        exit(-1);    }    free(ptd1); //释放内存    long * ptd2;    ptd2 = (long *)calloc(100,sizeof(long));    printf("ptd2 = %d\n",ptd2);    free(ptd2);    return 0;}    可以认为程序把它的可用内存分为三部分：一部分供具有外部链接、内部链接和无连接的静态变量使用；一部分供自动变量使用；一部分供动态内存分配。    int num1 = 100; //文件作用域，外部链接    static int num2 = 100; //文件作用域，内部链接。    //无论外部还是内部链接，文件作用域变量都具有静态存储期(随程序执行创建，程序结束销毁，在程序执行和结束期间一直存在)    //块级作用域具有自动存储器。当程序进入定义这些变量的块时，为这些变量分配内存，当退出这个块时，释放刚才为变量分配的内存。(变长数组略有不同，它的存储器从生命到块结尾)    //块级作用域也能具有静态存储期。在块中声明变量时，加上static关键字。但是只有执行其所在的函数时才能访问，该函数可以提供改变量的存储地址以便间接的访问对象，例如返回一个指针    //静态变量：该变量在内存中原地不动，并不是值不可改变。    void trystat(void){        int fade = 1; //函数执行一次，初始化一次        static int stay = 1; //只在编译阶段初始化一次        printf("fade = %d and stay = %d\n",fade++,stay++);    }    void test(void){        extern int num1; //可选重复声明        printf("%d\n",num1);    }----------------------------------------------------------------------------------    C的存储类别：(静态存储期：随着程序运行创建，程序结束销毁，在这期间一直存在；文件作用域：可以多个程序文件使用；自动存储期：当程序进入定义这些变量的块时，为这些变量分配内存，当退出这个块时，释放刚才为变量分配的内存；静态存储期：在块中声明变量时，加上static关键字。但是只有执行其所在的函数时才能访问，该函数可以提供改变量的存储地址以便间接的访问对象)        自动：在块中不带存储类别说明符或带auto(默认)存储类说明符声明的变量(或者作为函数头中的形参)属于自动存储类别。        寄存器：在块中带register存储类别说明符声明的变量(或作为函数头中的形参)属于寄存器存储类别，具有自动存储区、块作用域、无链接且无法获取其地址。        静态、无链接：在块中带有static存储类别说明符声明的变量，具有静态存储期、块作用域、无链接，只在编译时初始化一次        静态、外部链接：在所有函数外部且没有使用static存储类别说明符，具有静态存储期、文件作用域、外部链接。只能在编译器被初始化一次        静态、内部链接：在所有函数外使用了static存储类别说明符，具有静态存储期、文件作用域、内部链接。只能在编译器被初始化一次        动态分配的内存：由malloc()相关函数分配。        类型限定符：const、volatile、restrict、_Automic，const限定符限定数据在程序运行时不能改变。对指针使用const时，可限定指针本身不能改变或者指向的数据不能改变。----------------------------------------------------------------------------------文件输入与输出：    r:只读打开    w:覆盖写    a:追加写    r+:读写    w+:读，覆盖写    a+:读，追加写    int main(){        int ch; //读文件时存储每个字符的地方        FILE *fp; //文件指针        int count = 0;        fp = fopen("test.txt","r");        if (fp==NULL){            return 0;        }        for (;(ch = getc(fp))!=EOF;){ //getc() putc() 要传递文件的指针。            putc(ch,stdout);            count++;         }        fclose(fp);        printf("\n%d\n", count);        return 0;    }    ---------------    文件读写demo:        int main(){            int ch;            FILE *fp,*wfp;            int count = 0;            wfp = fopen("test.txt","a+");            if ((fp=fopen("/Users/duwei/ingress-controller-manager.yaml","r"))==NULL)            {                printf("%s\n",strerror(errno)); //strerror(errno)            }            for (;(ch = getc(fp)) != EOF;)            {                putc(ch,wfp);            }            fclose(fp);            return 0;        }    ---------------    rewind：        int main(){            FILE *fp;            char str1[10],str2[10],str3[10];            int year;            fp = fopen("test.txt","w+");            fputs("we are in 2020",fp);            rewind(fp);//写完时文件描述符在末尾，rewind将文件描述符拉回文件开始的地方            fscanf(fp,"%s %s %s %de",&amp;str1,&amp;str2,&amp;str3,&amp;year);            printf("Read String1 |%s|\n", str1 );            printf("Read String2 |%s|\n", str2 );            printf("Read String3 |%s|\n", str3 );            printf("Read Integer |%d|\n", year );            fprintf(stderr, "end.\n");            fclose(fp);            return 0;        }结构体：    ---------------    struct book{        char title[100];        char author[100];        int value;    };    void setV(struct book bk);    int main(){        struct book  library[100];        library[0].value = 99;        printf("out func,value = %d\n",library[0].value );        setV(library[0]);        printf("out func,value = %d\n",library[0].value );    }    void setV(struct book bk){        bk.value=999;        printf("in func,value = %d\n",bk.value);    }    stdout:        out func,value = 99        in func,value = 999        out func,value = 99    结论：结构体是值传递。    ---------------    对齐规则：    1、第一个成员在与结构体变量偏移量为0的地址处。(c1为起始位置)    2、其它成员变量要对齐到某个数(对齐数，vs默认为8，我用的gcc，对齐数就是成员自身大小)的整数倍的地址处。(对齐数: 编译器默认的对齐数 与 该成员大小 比较，小的就是该成员的对齐数。a大小为4，编译器默认的是8，那么该成员的对齐数就是4，    所以a的位置要为4的倍数处，所以a的位置为4，另外a占四个字节。同理c2的对齐数是1(1与8比较)，所以c2的位置为8。)    3、结构体总大小为最大对齐数(每个成员变量都有一个对齐数)的整数倍。(s1中的最大对齐数为4[来自a]，当前三个变量占了0-8也就是9个字节，所以结构体s1的整体大小为3*4=12字节)    4、如果嵌套了结构的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数(含嵌套结构体的对齐数)的整数倍。     在设计结构体时候，将占用空间小的成员尽量集中在一起。     #pragma pack(4) //设置默认对齐数    struct S1    {    char c1;    int a;    char c2;    };        _________________    ____         __________                                  0 |_________________|    c1              |                                      1 |_________________|    |               |                                        2 |_________________|    |               |                      3 |_________________|   _|__ 4 |_________________|    a          s1: 12个字节,1、2、3、9、10、11浪费掉 5 |_________________|                    |    6 |_________________|                    | 7 |_________________|   ____             | 8 |_________________|   _c2_             | 9 |_________________|                    |10 |_________________|                    | 11 |_________________|               _____|____12 |_________________|13 |_________________|14 |_________________|   |_________________|   |_________________|   |_________________|   |_________________|   |_________________|   |_________________|   |_________________|    同理s2如下：    struct S2    {    char c1;    char c2;    int a;    };    _________________    ____         _________ 0 |_________________|   _c1_            | 1 |_________________|   _c2_            | 2 |_________________|                   | 3 |_________________|   ____ 4 |_________________|    a          s1: 8 个字节,2、3浪费掉 5 |_________________|                   |    6 |_________________|                   | 7 |_________________|   ____        ____|_____ 8 |_________________|                     9 |_________________|                    10 |_________________|                    11 |_________________|           12 |_________________|13 |_________________|14 |_________________|   |_________________|   |_________________|   |_________________|   |_________________|   |_________________|   |_________________|   |_________________|   struct S3    {    double d;    char c;    int i;    };   struct S4    {    char c1;   struct S3 s3;    double d;    };————————----------——————————————    struct S{    int a;    char c;    double d;    };void Init(struct S * tmp){    tmp->a = 100;    tmp->c = 'd';    tmp->d = 3.14;}int main(){    struct S s = {0};    Init(&amp;s);    printf("%d\n", s.a);}————————----------——————————————位段：(二进制位)    1、位段的成员可以使 int、unsigned int、signed int 或者是char（属于整型家族）类型。    2、位段的空间上是按照需要以4个字节(int)或者一个字节(char)的方式来开辟的。    3、位段涉及很多不确定因素，不跨平台，注重可移植的程序应避免使用位段。    4、每一次开辟的内存，从右往左使用。            struct S             {                int _a:2; //2代表只需要两个比特位                int _b:5; //5代表只需要五个比特位                int _c:10;                int _d:30;            };            //47个比特位 需要 6字节*8bit = 48比特            int main()            {                struct S s;                printf("%d\n", sizeof(s)); //结果为8，int类型所以一次开辟四个字节，开辟两次。                return 0;            }            ——————————————————————————————————                    struct S                     {                        char a:3;                        char b:4;                        char c:5;                        char d:4;                    };                    int main()                    {                                                   |               |               |               |                        struct S s = {0};                                | | | | | | | | | | | | | | | | | | | | | | | | |                        s.a = 10; //二进制：1010，但是长度只给了3            |  b    |  a  |     |    b    |       |   d   |                        s.b = 20;                        s.c = 3;                        s.d = 4;                        printf("%d\n", sizeof(s)); // 类型是char：开辟一个字节放入a，再放入b，此时一个字节被占用了7个比特，剩下的1个比特不足以存放c，所以再开辟一个字节放入5，剩下的3个字节不足以存放d，so再次开辟一个字节。浪费了8比特。                        printf("%d\n", s.a);                        return 0;                    }————————————————————————————枚举：    enum Sex    {        MALE,        FAMALE,        SECRET    };    enum Color    {        RED, //0        GREEN, //1        BLUE //2    };    int main(){        enum Sex s = MALE;        enum Color c = BLUE;        printf("%d,%d,%d\n", RED,GREEN,BLUE);    }————————————————————————————union:    union Un    {        char c;         int i; //对齐数为4        char arr[5]; //对齐数是1而不是5，最小占用内存为 最大对齐数的整数倍    };    int main()    {        union Un u;        printf("%lu\n", sizeof(u));        printf("%p\n", &amp;u);        printf("%p\n", &amp;u.c);    }————————————————————————————动态内存分配：    _____________________________________    |          局部变量                  |    |          函数形参                  |    |                                   |    |                                   |    |                                   |  栈区    |                                   |    |                                   |    |                                   |    |                                   |    |———————————————————————————————————|    |      动态内存分配                   |    |                                   |    |                                   |    |                                   |    |                                   |    |                                   |    |                                   |  堆区    |                                   |    |                                   |    |                                   |    |                                   |    |                                   |    |                                   |    |———————————————————————————————————|    |                                   |    |        全局变量                    |    |        静态变量                    |    |                                   |    |                                   |    |                                   |  静态区    |                                   |    |                                   |    |                                   |    |                                   |    |                                   |    |                                   |    —————————————————————————————————————            int main()            {            int * p1 = (int *)malloc(10*sizeof(int)); //初始化之后默认值是随机的，int * p = realloc(NULL,40)            if (p1 == NULL)            {                printf("%s\n", strerror(errno));            }            else            {                for (int i = 0; i &lt; 10; ++i)                {                    printf("p1 = %d\n", p1[i]);                }            }            free(p1);            p1 = NULL;            printf("\n");            int * p2 = (int *)calloc(10,sizeof(int));  //初始化之后默认值是0            if (p2 == NULL)            {                printf("%s\n", strerror(errno));            }            else            {                for (int i = 0; i &lt; 10; ++i)                {                printf("p2 = %d\n", *(p2+i));                }            }            free(p2);            p2 = NULL;            printf("\n");            int * p3 = (int *)malloc(20);            if (p3 == NULL)            {                printf("%s\n", strerror(errno));            }            else            {                for (int i = 0; i &lt; 5; ++i)                {                    *(p3+i) = i;                }            }            int * p4 = realloc(p3,40); //调整已开辟内存的大小。            // 1、如果p3指向的内存空间后有足够的空间可以追加，则直接追加后返回p3。            // 2、如果p3指向的内存空间后没有足够的空间可以追加，则开辟一块全新的内存区域，将原来内存中的数据拷贝至新内存，释放旧内存空间，返回新开辟的内存空间地址            if (p4!=NULL)            {                p3 = p4;            }            for (int i = 0; i &lt; 40; ++i)            {                printf("p3 = %d\n", *(p4+i));            }            free(p3);            p3 = NULL;            return 0;        }*/</span><span class="token comment" spellcheck="true">// #pragma pack(4) //设置默认对齐数</span><span class="token comment" spellcheck="true">// void GetMemory(char **p)</span><span class="token comment" spellcheck="true">// {</span><span class="token comment" spellcheck="true">//     p = (char *)malloc(100);</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// void Test(void)</span><span class="token comment" spellcheck="true">// {</span><span class="token comment" spellcheck="true">//     char * str = NULL;</span><span class="token comment" spellcheck="true">//     GetMemory(&amp;str);</span><span class="token comment" spellcheck="true">//     strcpy(str,"hello world");</span><span class="token comment" spellcheck="true">//     printf(str);</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// int main()</span><span class="token comment" spellcheck="true">// {</span><span class="token comment" spellcheck="true">//     //str传给GetMemory()函数，传的是str而不是str的地址，所以p是str的值拷贝，p的值为NULL，函数里将申请的内存的地址赋给p，GetMemory执行完毕之后，</span><span class="token comment" spellcheck="true">//     //p是临时变量被销毁，所以str的值还是NULL</span><span class="token comment" spellcheck="true">//     Test();</span><span class="token comment" spellcheck="true">//     return 0;</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// char *GetMemory(void)</span><span class="token comment" spellcheck="true">// {</span><span class="token comment" spellcheck="true">//      char p[] = "hello world";</span><span class="token comment" spellcheck="true">//     return p;</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// void Test(void)</span><span class="token comment" spellcheck="true">// {</span><span class="token comment" spellcheck="true">//     char * str = NULL;</span><span class="token comment" spellcheck="true">//     str = GetMemory();</span><span class="token comment" spellcheck="true">//     printf(str);</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// int main()</span><span class="token comment" spellcheck="true">// {</span><span class="token comment" spellcheck="true">//     Test();</span><span class="token comment" spellcheck="true">//     return 0;</span><span class="token comment" spellcheck="true">// }</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>    FILE<span class="token operator">*</span> pf <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span><span class="token string">"wb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>pf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fclose</span><span class="token punctuation">(</span>pf<span class="token punctuation">)</span><span class="token punctuation">;</span>    pf <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c primer plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言预处理</title>
      <link href="2021/03/18/C%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86/"/>
      <url>2021/03/18/C%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/image/image-20201020173044074.png" alt="image-20201020173044074"></p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> g_val <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="1、预编译-预处理-gcc-E-test-c-gt-test-i，文本操作"><a href="#1、预编译-预处理-gcc-E-test-c-gt-test-i，文本操作" class="headerlink" title="1、预编译/预处理(gcc -E test.c &gt; test.i，文本操作)"></a>1、预编译/预处理(gcc -E test.c &gt; test.i，文本操作)</h4><ol><li><p>#include</p><p>头文件的包含</p></li><li><p>删除注释</p></li><li><p>#define</p><p>进行符号替换</p></li></ol><h4 id="2、编译-gcc-S-test-i，将c代码编译成汇编代码"><a href="#2、编译-gcc-S-test-i，将c代码编译成汇编代码" class="headerlink" title="2、编译(gcc -S test.i，将c代码编译成汇编代码)"></a>2、编译(gcc -S test.i，将c代码编译成汇编代码)</h4><ol><li>语法分析</li><li>词法分析</li><li>语义分析</li><li>符号汇总</li></ol><h4 id="3、汇编-gcc-c-test-s"><a href="#3、汇编-gcc-c-test-s" class="headerlink" title="3、汇编(gcc -c test.s)"></a>3、汇编(gcc -c test.s)</h4><p>将汇编代码转换成二进制指令</p><h4 id="4、链接"><a href="#4、链接" class="headerlink" title="4、链接"></a>4、链接</h4><ol><li>合并段表</li><li>符号表的合并和重新定位</li></ol><h5 id="5、宏"><a href="#5、宏" class="headerlink" title="5、宏"></a>5、宏</h5><p>函数在调用的时候会有函数调用和返回的开销。</p><p>宏在预处理阶段就完成了替换，没有调用和返回的开销。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现linux命令</title>
      <link href="2021/03/18/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0linux%E5%91%BD%E4%BB%A4/"/>
      <url>2021/03/18/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<ul><li><p>tail</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span></code></pre></li></ul><p>  #define FILE_LINE_LEN 1024</p><p>  long g_curr_offset = 0;</p><p>  int32_t c_tail(const char *file);<br>  int32_t c_tail(const char *file)<br>  {<br>      if (!file){<br>          return -1;<br>      }<br>      FILE *fp = fopen(file,”r”);<br>      if (!fp){<br>          printf(“can not open %s\n”,file);<br>          return -2;<br>      }<br>      fseek(fp, g_curr_offset, SEEK_SET);</p><pre><code>  char text[FILE_LINE_LEN];  uint32_t len;  while (!feof(fp)){      memset(text, 0x0, FILE_LINE_LEN);      fgets(text, FILE_LINE_LEN, fp);      len = strlen(text);      if (0 == len || &#39;\n&#39; != text[len -1]){          continue;      }      text[len-1] = 0;      g_curr_offset += len;      printf(&quot;%s\n&quot;,text);  }  fclose(fp);  return 0;</code></pre><p>  }</p><p>  int main(int argc, char *argv[])<br>  {<br>      if (argc != 2) {<br>          printf(“Usage: exe file_name\n”);<br>          exit(-1);<br>      }</p><pre><code>  while (1) {      c_tail(argv[1]);  }  return 0;</code></pre><p>  }</p><pre><code></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PracticeSql</title>
      <link href="2021/03/18/PracticeSql/"/>
      <url>2021/03/18/PracticeSql/</url>
      
        <content type="html"><![CDATA[<pre class=" language-mysql"><code class="language-mysql">select TrueName,IDCard,Mobile from xb_mem_info where IDCard like '%1999%' limit 10;select id,TrueName,IDCard,soundex(TrueName) from xb_mem_info where soundex(TrueName)=soundex('杜维');select upper(NickName) as new,NickName from xb_mem_info limit 10;select id,Mobile,TrueName,IDCard,Mobile+id as sumid from xb_mem_info where id=3;select concat(curdate(),' ',curtime());select count(1) from xb_mem_info;    select count(*) from xb_mem_info;select max(Mobile) from xb_mem_info;select distinct name from student ; 去重select count(distinct name) from student;select stutel,count(*) as newnum from student group by stutel ;不同的stutel出现的次数select name,count(*) as newnum from student group by name having count(*)>3;select name,count(*) as newnum from student group by name having name='duwei1'; having过滤分组，where过滤行select name,count(*)  from student where stutel>13487459071 group by name having count(*) >2;(select name,count(*) from student group by name order by count(*) desc;select name,count(*) from student group by name having count(*) >= 1 order by count(*) desc;)create database if not exists learn;</code></pre><p><img src="/image/image-20191231170722883.png" alt="image-20191231170722883"></p><p><img src="/image/image-20191231170801573.png" alt="image-20191231170801573"></p><p><img src="/image/image-20191231171401086.png" alt="image-20191231171401086"></p><p><img src="/image/image-20191231174815794.png" alt="image-20191231174815794"></p><p><img src="/image/image-20191231181937032.png" alt="image-20191231181937032"></p><p>复制表数据至另一个表</p><p><img src="/image/image-20200102171303711.png" alt="image-20200102171303711"></p><p><img src="/image/image-20200102173859668.png" alt="image-20200102173859668"></p><p><img src="/image/image-20200102181132702.png" alt="image-20200102181132702"></p><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE IF NOT EXISTS teacher (    id int PRIMARY KEY AUTO_INCREMENT COMMENT 'id 主键',    name varchar(20) NOT NULL COMMENT '姓名',    telnum varchar(11) COMMENT '手机号码',    addr varchar(100) DEFAULT 'unknow address' COMMENT '地址') ENGINE = innodb;</code></pre><p>添加、删除索引</p><p><img src="/image/image-20200229012250765.png" alt="image-20200229012250765"></p><p>修改列名</p><p><img src="/image/image-20200229012336903.png" alt="image-20200229012336903"></p><p>添加列</p><p><img src="/image/image-20200229012405184.png" alt="image-20200229012405184"></p><p><img src="/image/image-20200229012417290.png" alt="image-20200229012417290"></p><p>复制表操作</p><pre class=" language-mysql"><code class="language-mysql">create table new_table like old_table; //仅复制表结构create table new_table select column form old_table;//仅复制表数据truncate table table_name;//清空表(删除再创建)delete from table;//仅删除数据</code></pre><hr><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>一、值类型</p><p>1、整形</p><table><thead><tr><th align="center">类型</th><th align="center">字节</th><th align="center">范围</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">4</td><td align="center">-2^31~2^31-1</td></tr><tr><td align="center">mediumint</td><td align="center">3</td><td align="center">-2^23~2^23-1</td></tr><tr><td align="center">smallint</td><td align="center">2</td><td align="center">-2^15~2^15-1</td></tr><tr><td align="center">tinyint</td><td align="center">1</td><td align="center">-2^7~2^7-1</td></tr><tr><td align="center">bigint</td><td align="center">8</td><td align="center">-2^63~2^63-1</td></tr></tbody></table><p>无符号整数（unsigned），无符号没有负数，整数部分是有符号的两倍。</p><pre class=" language-mysql"><code class="language-mysql">mysql> create table stu(    -> id smallint unsigned auto_increment primary key comment '主键',    -> age tinyint unsigned not null comment '年龄',    ->  money bigint unsigned comment '存款'    -> );Query OK, 0 rows affected (0.01 sec)mysql> desc stu;+-------+----------------------+------+-----+---------+----------------+| Field | Type                 | Null | Key | Default | Extra          |+-------+----------------------+------+-----+---------+----------------+| id    | smallint(5) unsigned | NO   | PRI | NULL    | auto_increment || age   | tinyint(3) unsigned  | NO   |     | NULL    |                || money | bigint(20) unsigned  | YES  |     | NULL    |                |+-------+----------------------+------+-----+---------+----------------+3 rows in set (0.00 sec)mysql> insert into stu values (null,5,11);Query OK, 1 row affected (0.00 sec)mysql> select * from stu;+----+-----+-------+| id | age | money |+----+-----+-------+|  1 |   5 |    11 |+----+-----+-------+1 row in set (0.00 sec)mysql> drop table stu;Query OK, 0 rows affected (0.01 sec)mysql> create table stu(    -> id int(5),    -> age int(5) zerofill    -> );Query OK, 0 rows affected (0.01 sec)mysql> desc stu;+-------+--------------------------+------+-----+---------+-------+| Field | Type                     | Null | Key | Default | Extra |+-------+--------------------------+------+-----+---------+-------+| id    | int(5)                   | YES  |     | NULL    |       || age   | int(5) unsigned zerofill | YES  |     | NULL    |       |+-------+--------------------------+------+-----+---------+-------+2 rows in set (0.00 sec)mysql> insert into stu values(1,11);Query OK, 1 row affected (0.00 sec)mysql> select * from stu;+------+-------+| id   | age   |+------+-------+|    1 | 00011 |+------+-------+1 row in set (0.00 sec)mysql> insert into stu values(1111111,1111111);Query OK, 1 row affected (0.00 sec)mysql> select * from stu;+---------+---------+| id      | age     |+---------+---------+|       1 |   00011 || 1111111 | 1111111 |+---------+---------+2 rows in set (0.00 sec)</code></pre><hr><p>2、浮点型（精度超出则会四舍五入，精确度会丢失）</p><table><thead><tr><th align="center">浮点型</th><th align="center">占用字节</th><th align="center">范围</th></tr></thead><tbody><tr><td align="center">float（单精度）</td><td align="center">4</td><td align="center">-3.4E+38~3.4E+38</td></tr><tr><td align="center">double（双精度）</td><td align="center">8</td><td align="center">-1.8E+308~1.8E+308</td></tr></tbody></table><p>浮点数声明：float(M,D) double(M,D)</p><p>M:总位数</p><p>D:小数位数</p><pre class=" language-mysql"><code class="language-mysql">mysql> create table t1(    -> num1 float(5,2),    -> num2 double(4,1)    -> );Query OK, 0 rows affected (0.02 sec)mysql> insert into t1 values(1.23,1.23)    -> ;Query OK, 1 row affected (0.01 sec)mysql> select * from t1;+------+------+| num1 | num2 |+------+------+| 1.23 |  1.2 |+------+------+1 row in set (0.00 sec)mysql> insert into t1 values(1555.23,122222.23); ERROR 1264 (22003): Out of range value for column 'num1' at row 1mysql> insert into t1 values(123.233336,12.23444);Query OK, 1 row affected (0.01 sec)mysql> select * from t1;+--------+------+| num1   | num2 |+--------+------+|   1.23 |  1.2 || 123.23 | 12.2 |+--------+------+2 rows in set (0.00 sec)mysql> insert into t1 values(9.9999,9.999);Query OK, 1 row affected (0.00 sec)mysql> select * from t1;+--------+-------+| num1   | num2  |+--------+-------+|   1.23 |   1.2 || 123.23 |  12.2 || 999.99 | 999.9 ||  10.00 |  10.0 |+--------+-------+4 rows in set (0.00 sec)</code></pre><p>3、定点数（精度不会丢失）</p><p>语法：decimal(M,D)</p><p>定点数都是变长的，大致每9个数字用四个字节来存储。定点数之所以能保存精确小数，因为整数和小数是分开存储的。占用的资源比浮点数要多。</p><p>定点数和浮点数都支持显示宽度和无符号数。</p><pre class=" language-mysql"><code class="language-mysql">mysql> create table t4(    -> num decimal(20,19)    -> );Query OK, 0 rows affected (0.01 sec)mysql> insert into t4 values (1.1234567890123456789);Query OK, 1 row affected (0.00 sec)mysql> select * from t4;+-----------------------+| num                   |+-----------------------+| 1.1234567890123456789 |+-----------------------+1 row in set (0.00 sec)</code></pre><p>二、字符型</p><p>varchar：小于等于规定的长度，回收多余字符，节省空间。</p><p>char：小于等于规定的长度，不回收多余字符，执行效率比变长高。</p><table><thead><tr><th align="center">数据类型</th><th align="center">描述</th><th align="center">长度</th></tr></thead><tbody><tr><td align="center">char(长度)</td><td align="center">定长</td><td align="center">最大255</td></tr><tr><td align="center">varchar(长度)</td><td align="center">变长</td><td align="center">最大65535（理论值）</td></tr><tr><td align="center">tinytext</td><td align="center">大段文本</td><td align="center">2^8-1=255</td></tr><tr><td align="center">text</td><td align="center">大段文本</td><td align="center">2^16-1=65535</td></tr><tr><td align="center">mediumtext</td><td align="center">大段文本</td><td align="center">2^24-1</td></tr><tr><td align="center">longtext</td><td align="center">大段文本</td><td align="center">2^32-1</td></tr></tbody></table><pre class=" language-mysql"><code class="language-mysql">mysql> create table t3(    -> name varchar(10),    -> sex char(1)    -> );Query OK, 0 rows affected (0.01 sec)mysql> insert into t3(name) values('12345678900');ERROR 1406 (22001): Data too long for column 'name' at row 1mysql> insert into t3(name) values('1234567890');Query OK, 1 row affected (0.00 sec)mysql> select * from t3;+------------+------+| name       | sex  |+------------+------+| 1234567890 | NULL |+------------+------+mysql> insert into t3(name) values('123456');Query OK, 1 row affected (0.00 sec)mysql> select * from t3;+------------+------+| name       | sex  |+------------+------+| 1234567890 | NULL || 123456     | NULL |+------------+------+2 rows in set (0.00 sec)</code></pre><p>三、枚举（enmu）</p><p>优点： 运行速度快（数字比字符串运算速度快）</p><p>​            限制数据</p><p>​            节省空间</p><pre class=" language-mysql"><code class="language-mysql">mysql> create table t5(    -> name varchar(20),    -> sex enum('男','女','保密')    -> );Query OK, 0 rows affected (0.02 sec)mysql> insert into t5 values('tom','男');Query OK, 1 row affected (0.00 sec)mysql> insert into t5 values('jim','女');Query OK, 1 row affected (0.00 sec)mysql> insert into t5 values('marry','未知');ERROR 1265 (01000): Data truncated for column 'sex' at row 1 #只能插入枚举值mysql> insert into t5 values('yls','保密');Query OK, 1 row affected (0.00 sec)mysql> select * from t5;+------+--------+| name | sex    |+------+--------+| tom  | 男     || jim  | 女     || yls  | 保密   |+------+--------+3 rows in set (0.00 sec)mysql> select sex+0 from t5; #内部通过数字存储+-------+| sex+0 |+-------+|     1 ||     2 ||     3 |+-------+3 rows in set (0.01 sec)mysql> insert into t5 values('qss','3'); #能直接插入数字Query OK, 1 row affected (0.01 sec)mysql> select * from t5;+------+--------+| name | sex    |+------+--------+| tom  | 男     || jim  | 女     || yls  | 保密   || qss  | 保密   |+------+--------+4 rows in set (0.00 sec)</code></pre><p>四、集合（set）最多64个选项</p><pre class=" language-mysql"><code class="language-mysql">mysql> create table t6(    -> hobby set('爬山','读书','golang')    -> );Query OK, 0 rows affected (0.02 sec)mysql> insert into t6 values('爬山');Query OK, 1 row affected (0.00 sec)mysql> insert into t6 values('爬山','读书');ERROR 1136 (21S01): Column count doesn't match value count at row 1mysql> insert into t6 values('爬山,读书');Query OK, 1 row affected (0.01 sec)mysql> select * from t6;+---------------+| hobby         |+---------------+| 爬山          || 爬山,读书     |+---------------+2 rows in set (0.00 sec)mysql> insert into t6 values('读书,爬山'); #插入顺序不一样，但是显示顺序会一样。Query OK, 1 row affected (0.01 sec)mysql> select * from t6;+---------------+| hobby         |+---------------+| 爬山          || 爬山,读书     || 爬山,读书     |+---------------+3 rows in set (0.00 sec)</code></pre><p>五、时间类型</p><table><thead><tr><th align="center">数据类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">datetime</td><td align="center">日期时间，占用8个字节</td></tr><tr><td align="center">date</td><td align="center">日期，占用3个字节</td></tr><tr><td align="center">time</td><td align="center">时间，占用3个字节</td></tr><tr><td align="center">timestamp</td><td align="center">时间戳，占用4个字节</td></tr><tr><td align="center">year</td><td align="center">年份，占用1个字节</td></tr></tbody></table><p>1、datetime 格式：年-月-日 小时：分钟：秒 （范围：0001-9999年）</p><pre class=" language-mysql"><code class="language-mysql">mysql> create table t7(    -> field datetime    -> );Query OK, 0 rows affected (0.01 sec)mysql> insert into t7 values('2020-02-29 04:25:29');Query OK, 1 row affected (0.00 sec)mysql> select * from t7;+---------------------+| field               |+---------------------+| 2020-02-29 04:25:29 |+---------------------+1 row in set (0.00 sec)</code></pre><p>2、date</p><pre class=" language-mysql"><code class="language-mysql">mysql> create table t8(    -> field date    -> );Query OK, 0 rows affected (0.01 sec)mysql> insert into t8 values('2020-02-29');Query OK, 1 row affected (0.00 sec)mysql> select * from t8;+------------+| field      |+------------+| 2020-02-29 |+------------+1 row in set (0.00 sec)</code></pre><p>3、timestamp（日期形式）</p><p>4、year</p><p>最多只能表示255个年份，范围1901-2155</p><p>5、time 表示时间或者时间间隔</p><p>六、boolean</p><pre class=" language-mysql"><code class="language-mysql">mysql> create table t9(    -> field boolean    -> );Query OK, 0 rows affected (0.01 sec)mysql> insert into t9 values (true),(false);Query OK, 2 rows affected (0.00 sec)Records: 2  Duplicates: 0  Warnings: 0mysql> select * from t9;+-------+| field |+-------+|     1 ||     0 |+-------+2 rows in set (0.00 sec)</code></pre><hr><h5 id="列属性-null-not-null"><a href="#列属性-null-not-null" class="headerlink" title="列属性(null | not null)"></a>列属性(null | not null)</h5><p>default:默认值</p><pre class=" language-mysql"><code class="language-mysql">mysql> create table t10(    -> id int unsigned,    -> addr varchar(20) not null default '不详'    -> );Query OK, 0 rows affected (0.01 sec)mysql> insert into t10 values(1,'杭州'),(2,default);Query OK, 2 rows affected (0.01 sec)Records: 2  Duplicates: 0  Warnings: 0mysql> select * from t10;+------+--------+| id   | addr   |+------+--------+|    1 | 杭州   ||    2 | 不详   |+------+--------+2 rows in set (0.00 sec)</code></pre><p>auto_increment:auto_increment必须是主键，但是主键不一定是自增。</p><p>​                          给自增列插入数据，使用null关键字。</p><pre><code>                      自增列上的数据被删除，默认情况下此记录编号不再使用。</code></pre><p>唯一键：</p><p>​            特点：不能重复，可以为空，同一张表可以拥有多个唯一键</p><p>​            作用：保证数据不能重复，保证数据完整性，加快数据访问</p><p>​            添加唯一键：</p><p>​            </p><pre class=" language-mysql"><code class="language-mysql">mysql> create table t14(    -> id int primary key,    -> name varchar(20) unique    -> );Query OK, 0 rows affected (0.02 sec)-----------------------------------------------------------------------------------------------mysql> create table t15(    -> id int primary key,    -> name varchar(20)    -> );Query OK, 0 rows affected (0.01 sec)mysql> alter table t15 add unique(name);Query OK, 0 rows affected (0.01 sec)Records: 0  Duplicates: 0  Warnings: 0mysql> desc t15;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | NO   | PRI | NULL    |       || name  | varchar(20) | YES  | UNI | NULL    |       |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec)-----------------------------------------------------------------------------------------------mysql> create table t16(    -> id int,    -> name varchar(20),    -> addr varchar(20)    -> );Query OK, 0 rows affected (0.01 sec)mysql> alter table t16 add unique(name),add unique(addr);Query OK, 0 rows affected (0.01 sec)Records: 0  Duplicates: 0  Warnings: 0mysql> desc t16;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | YES  |     | NULL    |       || name  | varchar(20) | YES  | UNI | NULL    |       || addr  | varchar(20) | YES  | UNI | NULL    |       |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec)-----------------------------------------------------------------------------------------------mysql> create table t17(    -> id int,    -> name varchar(20),    -> addr varchar(20)    -> );Query OK, 0 rows affected (0.01 sec)mysql> alter table t16 add unique(name,addr); #name、addr组合成唯一键Query OK, 0 rows affected (0.01 sec)Records: 0  Duplicates: 0  Warnings: 0mysql> desc t16;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | YES  |     | NULL    |       || name  | varchar(20) | YES  | UNI | NULL    |       || addr  | varchar(20) | YES  | UNI | NULL    |       |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec)</code></pre><p>​            查看唯一键：</p><pre class=" language-mysql"><code class="language-mysql">mysql> show create table t15\G*************************** 1. row ***************************       Table: t15Create Table: CREATE TABLE `t15` (  `id` int(11) NOT NULL,  `name` varchar(20) DEFAULT NULL,  PRIMARY KEY (`id`),  UNIQUE KEY `name` (`name`)) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec)mysql> show create table t16\G*************************** 1. row ***************************       Table: t16Create Table: CREATE TABLE `t16` (  `id` int(11) DEFAULT NULL,  `name` varchar(20) DEFAULT NULL,  `addr` varchar(20) DEFAULT NULL,  UNIQUE KEY `name` (`name`),  UNIQUE KEY `addr` (`addr`),  UNIQUE KEY `name_2` (`name`,`addr`)) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec)</code></pre><p>​            删除唯一键:</p><pre class=" language-mysql"><code class="language-mysql">mysql> show create table t16\G*************************** 1. row ***************************       Table: t16Create Table: CREATE TABLE `t16` (  `id` int(11) DEFAULT NULL,  `name` varchar(20) DEFAULT NULL,  `addr` varchar(20) DEFAULT NULL,  UNIQUE KEY `name` (`name`),  UNIQUE KEY `addr` (`addr`),  UNIQUE KEY `name_2` (`name`,`addr`)) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec)mysql> alter table t16 drop index name_2;Query OK, 0 rows affected (0.02 sec)Records: 0  Duplicates: 0  Warnings: 0mysql> show create table t16\G*************************** 1. row ***************************       Table: t16Create Table: CREATE TABLE `t16` (  `id` int(11) DEFAULT NULL,  `name` varchar(20) DEFAULT NULL,  `addr` varchar(20) DEFAULT NULL,  UNIQUE KEY `name` (`name`),  UNIQUE KEY `addr` (`addr`)) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec)</code></pre><p>primary key:</p><p>​                    唯一标识表中记录的一个或者一组列</p><p>​                    不能重复，不能为空</p><p>​                    一个表只能有一个主键，可以由多个字段组成</p><p>​                    保证数据完整性，加快查询速度</p><p>选择主键原则：</p><p>​                    </p><hr><h6 id="添加主键："><a href="#添加主键：" class="headerlink" title="添加主键："></a>添加主键：</h6><pre class=" language-mysql"><code class="language-mysql">mysql> create table t11(    -> id varchar(5) primary key,    -> name varchar(10) not null    -> );Query OK, 0 rows affected (0.01 sec)mysql> insert into t11 values('s2531','tom'),('s2532','berry');Query OK, 2 rows affected (0.00 sec)Records: 2  Duplicates: 0  Warnings: 0mysql> insert into t11 values('s2531','tom');ERROR 1062 (23000): Duplicate entry 's2531' for key 'PRIMARY'mysql> insert into t11 values(null,'tom');ERROR 1048 (23000): Column 'id' cannot be null</code></pre><h6 id="添加主键的方法"><a href="#添加主键的方法" class="headerlink" title="添加主键的方法"></a>添加主键的方法</h6><pre class=" language-mysql"><code class="language-mysql">mysql> create table t11(    -> id varchar(5) primary key,    -> name varchar(10) not null    -> );Query OK, 0 rows affected (0.02 sec)-----------------------------------------------------------------------------------------------mysql> create table t12(    -> id int,    -> name varchar(10),    -> primary key(id)    -> );Query OK, 0 rows affected (0.02 sec)-----------------------------------------------------------------------------------------------mysql> create table t13(    -> id int,    -> name varchar(10)    -> );Query OK, 0 rows affected (0.01 sec)mysql> alter table t13 add primary key(id);Query OK, 0 rows affected (0.01 sec)Records: 0  Duplicates: 0  Warnings: 0mysql> desc t13;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | NO   | PRI | NULL    |       || name  | varchar(10) | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec)</code></pre><h6 id="删除主键："><a href="#删除主键：" class="headerlink" title="删除主键："></a>删除主键：</h6><pre class=" language-mysql"><code class="language-mysql">mysql> alter table t13 drop primary key;Query OK, 0 rows affected (0.02 sec)Records: 0  Duplicates: 0  Warnings: 0mysql> desc t13;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | NO   |     | NULL    |       || name  | varchar(10) | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec)</code></pre><h5 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h5><p>引用完整性</p><p>外键</p><pre class=" language-mysql"><code class="language-mysql">mysql> create table stuinfo(    -> stunum char(4) primary key,    -> name varchar(10) not null    -> );Query OK, 0 rows affected (0.01 sec)mysql> create table stumarks(    -> stuid char(4) primary key,    -> score tinyint unsigned,    -> foreign key (stuid) references stuinfo(stunum)    -> );Query OK, 0 rows affected (0.01 sec)-----------------------------------------------------------------------------------------------mysql> insert into stumarks values('s101',88);ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`school`.`stumarks`, CONSTRAINT `stumarks_ibfk_1` FOREIGN KEY (`stuid`) REFERENCES `stuinfo` (`stunum`))/* 主表中不存在s101，从表是无法插入的 */mysql> insert into stuinfo values('s101','tom');Query OK, 1 row affected (0.00 sec)mysql> insert into stumarks values('s101',88);Query OK, 1 row affected (0.00 sec)-----------------------------------------------------------------------------------------------mysql> delete from stuinfo where stunum='s101';ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`school`.`stumarks`, CONSTRAINT `stumarks_ibfk_1` FOREIGN KEY (`stuid`) REFERENCES `stuinfo` (`stunum`))mysql> delete from stumarks where stuid='s101';Query OK, 1 row affected (0.00 sec)mysql> delete from stuinfo where stunum='s101';Query OK, 1 row affected (0.01 sec)/*删除主表的数据必须先删除从表中的对应数据*/-----------------------------------------------------------------------------------------------mysql> drop table stumarks;Query OK, 0 rows affected (0.00 sec)mysql> drop table stuinfo;Query OK, 0 rows affected (0.00 sec)mysql> create table stuinfo(    -> stunum char(4) primary key,    -> name varchar(10) not null    -> );Query OK, 0 rows affected (0.01 sec)mysql> create table stumarks(    -> stuid char(4) primary key,    -> score tinyint unsigned    -> );Query OK, 0 rows affected (0.01 sec)mysql> alter table stumarks add foreign key(stuid) references stuinfo(stunum);Query OK, 0 rows affected (0.02 sec)Records: 0  Duplicates: 0  Warnings: 0/*修改表的时候添加外键*/-----------------------------------------------------------------------------------------------mysql> show create table stumarks\G*************************** 1. row ***************************       Table: stumarksCreate Table: CREATE TABLE `stumarks` (  `stuid` char(4) NOT NULL,  `score` tinyint(3) unsigned DEFAULT NULL,  PRIMARY KEY (`stuid`),  CONSTRAINT `stumarks_ibfk_1` FOREIGN KEY (`stuid`) REFERENCES `stuinfo` (`stunum`)) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec)mysql> alter table stumarks drop foreign key stumarks_ibfk_1;Query OK, 0 rows affected (0.01 sec)Records: 0  Duplicates: 0  Warnings: 0/*删除外键*/-----------------------------------------------------------------------------------------------mysql> create table stuinfo(    -> stunum char(4) primary key,    -> name varchar(10) not null    -> );Query OK, 0 rows affected (0.01 sec)mysql> create table stumarks(    -> stuid int auto_increment primary key,    -> stunum char(4),    -> score tinyint unsigned,    -> foreign key (stunum) references stuinfo(stunum) on delete set null on update cascade    -> );Query OK, 0 rows affected (0.01 sec)mysql> insert into stuinfo values('100',tom);ERROR 1054 (42S22): Unknown column 'tom' in 'field list'mysql> insert into stuinfo values('100','tom');Query OK, 1 row affected (0.00 sec)mysql> insert into stumarks values(null,'100',88);Query OK, 1 row affected (0.00 sec)mysql> select * from stuinfo;+--------+------+| stunum | name |+--------+------+| 100    | tom  |+--------+------+1 row in set (0.00 sec)mysql> select * from stumarks;+-------+--------+-------+| stuid | stunum | score |+-------+--------+-------+|     1 | 100    |    88 |+-------+--------+-------+1 row in set (0.00 sec)mysql> update stuinfo set stunum='101' where stunum='100';Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql> select * from stumarks;+-------+--------+-------+| stuid | stunum | score |+-------+--------+-------+|     1 | 101    |    88 |+-------+--------+-------+1 row in set (0.00 sec)mysql> delete from stuinfo where stunum='101';Query OK, 1 row affected (0.00 sec)mysql> select * from stuinfo;Empty set (0.00 sec)mysql> select * from stumarks;+-------+--------+-------+| stuid | stunum | score |+-------+--------+-------+|     1 | NULL   |    88 |+-------+--------+-------+1 row in set (0.00 sec)/*级联操作：当主表中的数据删除是，从表中对应的记录置空；更新时也对应更新*/</code></pre><blockquote><pre class=" language-mysql"><code class="language-mysql">/*in 、not in*/mysql> select id,truename as '姓名',idcard from xb_mem_info where id not in (10,330,499,331) limit 5;+----+-----------+--------------------+| id | 姓名      | idcard             |+----+-----------+--------------------+|  1 | 5990      | NULL               ||  3 | 蔡伟优    | 360727198706152011 ||  4 | 黄杰      | 360727199108280093 ||  5 | 谭辉金    | 360729199606260020 ||  6 | 黄美霞    | 36072719870519202X |+----+-----------+--------------------+5 rows in set (0.01 sec)mysql> select id,truename as '姓名',idcard from xb_mem_info where id in (10,330,499,331) limit 5;+-----+-----------+--------------------+| id  | 姓名      | idcard             |+-----+-----------+--------------------+|  10 | 蔡素华    | 360727198902202020 || 330 | 9375      | NULL               || 331 | 2782      | NULL               || 499 | 陈书芹    | 410727197812236921 |+-----+-----------+--------------------+4 rows in set (0.00 sec)-----------------------------------------------------------------------------------------------/*between、not between*/mysql> select id,truename,idcard from xb_mem_info where id  between 10 and 15 limit 6;+----+-----------+--------------------+| id | truename  | idcard             |+----+-----------+--------------------+| 10 | 蔡素华    | 360727198902202020 || 11 | 5729      | NULL               || 12 | 陈奎龙    | 500226199001052237 || 13 | 3330      | NULL               || 14 | 王忠诚    | 500381199401114118 || 15 | 莫黎      | 511025198608230010 |+----+-----------+--------------------+6 rows in set (0.00 sec)mysql> select id,truename,idcard from xb_mem_info where id not between 10 and 15 limit 6;+----+-----------+--------------------+| id | truename  | idcard             |+----+-----------+--------------------+|  1 | 5990      | NULL               ||  3 | 蔡伟优    | 360727198706152011 ||  4 | 黄杰      | 360727199108280093 ||  5 | 谭辉金    | 360729199606260020 ||  6 | 黄美霞    | 36072719870519202X ||  7 | 黄燕芳    | 360727199309232020 |+----+-----------+--------------------+6 rows in set (0.00 sec)-----------------------------------------------------------------------------------------------/*is null、is not null*/mysql> select id,truename,idcard from xb_mem_info where idcard is null limit 10;+----+----------+--------+| id | truename | idcard |+----+----------+--------+|  1 | 5990     | NULL   || 11 | 5729     | NULL   || 13 | 3330     | NULL   || 17 | 1468     | NULL   || 20 | NULL     | NULL   || 21 | 9474     | NULL   || 22 | 5469     | NULL   || 23 | 9453     | NULL   || 25 | 2643     | NULL   || 26 | 4491     | NULL   |+----+----------+--------+10 rows in set (0.00 sec)mysql> select id,truename,idcard from xb_mem_info where idcard is not null limit 10;+----+-----------+--------------------+| id | truename  | idcard             |+----+-----------+--------------------+|  3 | 蔡伟优    | 360727198706152011 ||  4 | 黄杰      | 360727199108280093 ||  5 | 谭辉金    | 360729199606260020 ||  6 | 黄美霞    | 36072719870519202X ||  7 | 黄燕芳    | 360727199309232020 ||  8 | 王经媛    | 360732199709234122 ||  9 | 刘利盛    | 360727198907082013 || 10 | 蔡素华    | 360727198902202020 || 12 | 陈奎龙    | 500226199001052237 || 14 | 王忠诚    | 500381199401114118 |+----+-----------+--------------------+10 rows in set (0.00 sec)-----------------------------------------------------------------------------------------------/*sum()*/mysql> select sum(id) from xb_mem_info;+----------+| sum(id)  |+----------+| 60856657 |+----------+1 row in set (0.01 sec)-----------------------------------------------------------------------------------------------/*avg()*/mysql> select avg(idcard) from xb_mem_info;+----------------------+| avg(idcard)          |+----------------------+| 3.556618801202589e17 |+----------------------+1 row in set, 789 warnings (0.01 sec)-----------------------------------------------------------------------------------------------/*max()*/mysql> select max(idcard) from xb_mem_info;+--------------------+| max(idcard)        |+--------------------+| 659001199107054831 |+--------------------+1 row in set (0.00 sec)-----------------------------------------------------------------------------------------------/*min*/mysql> select min(idcard) from xb_mem_info;+--------------------+| min(idcard)        |+--------------------+| 110101198112240038 |+--------------------+1 row in set (0.01 sec)-----------------------------------------------------------------------------------------------/*count()*/mysql> select count(*) from xb_mem_info;+----------+| count(*) |+----------+|    11029 |+----------+1 row in set (0.00 sec)mysql> select count(1) from xb_mem_info;+----------+| count(1) |+----------+|    11029 |+----------+1 row in set (0.00 sec)执行效率上：  列名为主键，count(列名)会比count(1)快  列名不为主键，count(1)会比count(列名)快  如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）  如果有主键，则 select count（主键）的执行效率是最优的  如果表只有一个字段，则 select count（*）最优。https://blog.csdn.net/iFuMI/article/details/77920767----------------------------------------------------------------------------------------/*order by*/mysql> select id,truename,idcard from xb_mem_info where idcard is not null order by idcard limit 10;+------+-----------+--------------------+| id   | truename  | idcard             |+------+-----------+--------------------+| 8847 | 曹磊      | 110101198112240038 || 6870 | 李曌      | 11010119870608102X || 6854 | 郭思酉    | 11010119930224451X ||  934 | 刘晨晞    | 110102197902222725 || 1190 | 杨宽      | 110102198007070432 || 7085 | 王璞      | 110102198103131530 || 5252 | 杨雨      | 110102198806162405 || 3243 | 霍建      | 110103197801230650 || 7744 | 孟龙      | 110103198712181214 || 5967 | 何林      | 110104196302251256 |+------+-----------+--------------------+10 rows in set (0.00 sec)mysql> select id,truename,idcard from xb_mem_info where idcard is not null order by idcard desc limit 10;+-------+-------------------------+--------------------+| id    | truename                | idcard             |+-------+-------------------------+--------------------+|  3671 | 杨先锋                  | 659001199107054831 ||  7297 | 孙正钰                  | 65900119910511161X ||  5523 | 孟蕊                    | 659001198612115725 ||  2194 | 胡安·巴合夏别克         | 654301199308090013 || 10193 | 哈里哈什·胡沙因         | 654301198405201868 ||   912 | 晁永康                  | 65422219980303391X ||  6237 | 哈依那尔·叶尔肯         | 654221199506131437 ||  1598 | 刘洋                    | 65420219950519631X ||  9606 | 郭玉忠                  | 654123198710133299 ||  2521 | 屈荣兰                  | 654122198810251325 |+-------+-------------------------+--------------------+10 rows in set (0.01 sec)----------------------------------------------------------------------------------------/*group by*/mysql> select * from test;+----+-----------+------+------+| id | name      | sex  | age  |+----+-----------+------+------+|  1 | 蔡伟优    | 男   |   33 ||  2 | 黄杰      | 男   |   29 ||  3 | 谭辉金    | 男   |   24 ||  4 | 黄美霞    | 女   |   30 ||  5 | 黄燕芳    | 女   |   27 |+----+-----------+------+------+5 rows in set (0.00 sec)mysql> select avg(age) as avg_age,sex from test group by sex;+---------+------+| avg_age | sex  |+---------+------+| 28.6667 | 男   || 28.5000 | 女   |+---------+------+2 rows in set (0.00 sec)----------------------------------------------------------------------------------------/*distinct*/select distinct name from test;----------------------------------------------------------------------------------------/*内连接：inner join*/①：select column from t1 inner join t2 on t1.commen_column=t2.commen_column;②：select column from t1,t2 where t1.commen_column=t2.commen_column;③：select from t1 inner join t2 on t1.commen_column=t2.commen_column inner join t3 on t2.commen_column=t3.commen_column;----------------------------------------------------------------------------------------/*左外连接：left join*/select column from t1 left join t2 on t1.commen_column=t2.commen_column;----------------------------------------------------------------------------------------/*添加索引*/mysql> desc stu;+-------+--------------------------+------+-----+---------+-------+| Field | Type                     | Null | Key | Default | Extra |+-------+--------------------------+------+-----+---------+-------+| id    | int(5)                   | YES  |     | NULL    |       || age   | int(5) unsigned zerofill | YES  |     | NULL    |       |+-------+--------------------------+------+-----+---------+-------+2 rows in set (0.00 sec)mysql> create index idx_id on stu(id); #Query OK, 0 rows affected (0.03 sec)Records: 0  Duplicates: 0  Warnings: 0mysql> show index from stu;+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| stu   |          1 | idx_id   |            1 | id          | A         |           2 |     NULL | NULL   | YES  | BTREE      |         |               |+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+1 row in set (0.00 sec)----------------------------------------------------------------------------------------/*添加索引*/mysql> desc t10;+-------+------------------+------+-----+---------+-------+| Field | Type             | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| id    | int(10) unsigned | YES  |     | NULL    |       || addr  | varchar(20)      | NO   |     | 不详    |       |+-------+------------------+------+-----+---------+-------+2 rows in set (0.00 sec)mysql> show index from t10;Empty set (0.00 sec)mysql> alter table t10 add index idx_addr(addr);Query OK, 0 rows affected (0.01 sec)Records: 0  Duplicates: 0  Warnings: 0mysql> show index from t10;+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| t10   |          1 | idx_addr |            1 | addr        | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+1 row in set (0.00 sec)----------------------------------------------------------------------------------------/*创建表时添加索引*/mysql> create table t18(    -> id int,    -> name varchar(10),    -> index idx_name (name)    -> );Query OK, 0 rows affected (0.01 sec)mysql> show index from t18;+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| t18   |          1 | idx_name |            1 | name        | A         |           0 |     NULL | NULL   | YES  | BTREE      |         |               |+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+1 row in set (0.00 sec)mysql> drop index idx_name on t18; /*删除索引*/Query OK, 0 rows affected (0.02 sec)Records: 0  Duplicates: 0  Warnings: 0mysql> show index from t18;Empty set (0.00 sec)/*唯一索引*/create unique index index_name table_name (column_name);alter table table_name add unqiue index index_name (column)----------------------------------------------------------------------------------------/*rand()*/mysql> select truename from xb_mem_info order by rand() limit 5; //随机取值+-----------+| truename  |+-----------+| 杨昌龙    || 高胜兵    || 陆惠玲    || 石兴      || 1108      |+-----------+5 rows in set (0.01 sec)mysql> select truename from xb_mem_info order by rand() limit 5;+-----------+| truename  |+-----------+| 陈常华    || 吴宾宾    || 刘宏斌    || 8011      || 漆艳玲    |+-----------+5 rows in set (0.02 sec)mysql> select truename from xb_mem_info order by rand() limit 5;+-----------+| truename  |+-----------+| 张雨      || 彭宏扬    || 施树伟    || 易亚平    || 陈泳希    |+-----------+5 rows in set (0.02 sec)</code></pre></blockquote><hr><h6 id="查询表每个索引的大小"><a href="#查询表每个索引的大小" class="headerlink" title="查询表每个索引的大小"></a>查询表每个索引的大小</h6><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>       <span class="token function">sum</span><span class="token punctuation">(</span>stat_value<span class="token punctuation">)</span> pages<span class="token punctuation">,</span>       table_name part<span class="token punctuation">,</span>       index_name<span class="token punctuation">,</span>       concat<span class="token punctuation">(</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span>stat_value<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000000</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'M'</span><span class="token punctuation">,</span><span class="token string">' rows'</span><span class="token punctuation">)</span> <span class="token operator">*</span> @<span class="token variable">@innodb_page_size</span> size<span class="token keyword">FROM</span>       mysql<span class="token punctuation">.</span>innodb_index_stats<span class="token keyword">WHERE</span>           table_name <span class="token operator">=</span> <span class="token string">'你的表名'</span>       <span class="token operator">AND</span> database_name <span class="token operator">=</span> <span class="token string">'你的数据库名'</span>       <span class="token operator">AND</span> stat_description <span class="token operator">LIKE</span> <span class="token string">'Number of pages in the index'</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span>       table_name<span class="token punctuation">,</span> index_name<span class="token punctuation">;</span></code></pre><h6 id="查询表索引总大小"><a href="#查询表索引总大小" class="headerlink" title="查询表索引总大小"></a>查询表索引总大小</h6><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> CONCAT<span class="token punctuation">(</span><span class="token function">ROUND</span><span class="token punctuation">(</span><span class="token function">SUM</span><span class="token punctuation">(</span>index_length<span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">' MB'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token string">'Total Index Size'</span> <span class="token keyword">FROM</span> <span class="token keyword">TABLES</span>  <span class="token keyword">WHERE</span> table_schema <span class="token operator">=</span> <span class="token string">'库名'</span> <span class="token operator">and</span> table_name<span class="token operator">=</span><span class="token string">'表名'</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql_base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c陷阱与缺陷</title>
      <link href="2021/03/18/c%E9%99%B7%E9%98%B1%E4%B8%8E%E7%BC%BA%E9%99%B7/"/>
      <url>2021/03/18/c%E9%99%B7%E9%98%B1%E4%B8%8E%E7%BC%BA%E9%99%B7/</url>
      
        <content type="html"><![CDATA[<h5 id="1-5-字符与字符串"><a href="#1-5-字符与字符串" class="headerlink" title="1.5 字符与字符串"></a>1.5 字符与字符串</h5><ul><li>用单引号引起的一个字符实际上代表一个证书，整数值对应于该字符在编译器采用的字符集中的序列值。</li><li>用双引号引起的字符串，代表的是指向一个无名数组起始字符的指针。</li></ul><h5 id="2-1-理解函数声明"><a href="#2-1-理解函数声明" class="headerlink" title="2.1 理解函数声明"></a>2.1 理解函数声明</h5><ul><li><pre class=" language-c"><code class="language-c"><span class="token keyword">float</span> <span class="token operator">*</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*()的优先级比*高，*g()等价于*(g()): g是一个函数，该函数的返回值时一个指向浮点数的指针。(*h)(): h是一个函数指针，返回值时浮点数类型。(float (*)())表示一个“指向返回值为浮点类型的函数的指针”的类型转换符。*/</span></code></pre></li></ul><p>  (<em>(void(</em>)())0)();<br>  /*<br>  (<em>fp)()<br>  fp是个指针<br>  fp 替换 (void(</em>)())0<br>  0强制类型转换成一个函数指针，该函数无返回值无参数<br>  */</p><p>  void sigfunc(int);<br>  /*<br>  声明一个指向sigfunc函数的指针变量：void (*psf)(int)<br>  */</p><pre><code></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="2021/03/18/Nginx/"/>
      <url>2021/03/18/Nginx/</url>
      
        <content type="html"><![CDATA[<h5 id="初识nginx"><a href="#初识nginx" class="headerlink" title="初识nginx"></a>初识nginx</h5><h6 id="nginx-命令行"><a href="#nginx-命令行" class="headerlink" title="nginx 命令行:"></a>nginx 命令行:</h6><table><thead><tr><th align="left">指令</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">-c</td><td align="left">指定使用的配置文件</td></tr><tr><td align="left">-t -T</td><td align="left">检查配置文件语法</td></tr><tr><td align="left">-g</td><td align="left">指定配置指令</td></tr><tr><td align="left">-p</td><td align="left">指定运行目录</td></tr><tr><td align="left">-v -V</td><td align="left">查看版本信息、编译参数</td></tr><tr><td align="left">-s</td><td align="left">发送信号[reload|stop|quit|reopen(重新打开一个文件记录日志)]</td></tr></tbody></table><h6 id="nginx热部署-was"><a href="#nginx热部署-was" class="headerlink" title="nginx热部署: was"></a>nginx热部署: was</h6><ol><li>重新编译nginx生成nginx(new)二进制文件，编译参数在原来的基础上添加。</li><li>备份nginx(old)，用nginx(new)二进制文件覆盖nginx(old)二进制文件。</li><li>找出nginx(old)的master进程的pid，kill -USR2 pid。(nginx会使用nginx(new)二进制文件启动，此时ps aux |grep nginx会看见两个master进程)</li><li>kill -WINCH old_nginx_pid，旧版本的worker进程会优雅结束，master进程仍然在运行(出现意外时，能够回退版本)。</li></ol><h6 id="nginx配置文件指令"><a href="#nginx配置文件指令" class="headerlink" title="nginx配置文件指令:"></a>nginx配置文件指令:</h6><pre class=" language-nginx"><code class="language-nginx"><span class="token keyword">gzip</span> on<span class="token punctuation">;</span><span class="token keyword">gzip_min_length</span> <span class="token number">1</span><span class="token punctuation">;</span>当发送的内容小于<span class="token number">1</span>字节时就不进行压缩<span class="token keyword">gzip_comp_level</span> <span class="token number">2</span><span class="token punctuation">;</span>压缩级别，级别越高越损耗性能<span class="token keyword">gzip_types</span> text<span class="token operator">/</span>plain application<span class="token operator">/</span>x<span class="token operator">-</span>javascript text<span class="token operator">/</span>css application<span class="token operator">/</span>xml text<span class="token operator">/</span>javascript image<span class="token operator">/</span>jpg image<span class="token operator">/</span>gig image<span class="token operator">/</span>png<span class="token punctuation">;</span>压缩对象<span class="token keyword">autoindex</span> on<span class="token punctuation">;</span>显示网站根目录结构<span class="token punctuation">(</span>eg<span class="token punctuation">:</span>下载<span class="token punctuation">)</span><span class="token keyword">set</span> <span class="token variable">$limit_rate</span> 1k<span class="token punctuation">;</span>限制发送到client的速度<span class="token punctuation">(</span>每秒1k<span class="token punctuation">)</span><span class="token keyword">access_log</span> <span class="token operator">/</span>data<span class="token operator">/</span>wwwlogs<span class="token operator">/</span>access<span class="token punctuation">.</span>log main<span class="token punctuation">;</span>记录nginx的访问日志<span class="token punctuation">,</span>main是<span class="token keyword">log_format</span>需要自己根据需求定义<span class="token keyword">proxy_cache_path</span> <span class="token operator">/</span>tmp<span class="token operator">/</span>nginxcache levels<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">2</span> keys_zone<span class="token operator">=</span>my_cache<span class="token punctuation">:</span>10m max_size<span class="token operator">=</span>10g inactive<span class="token operator">=</span>60m use_temp_path off<span class="token punctuation">;</span><span class="token keyword">upstream</span> test <span class="token punctuation">{</span>  <span class="token keyword">server</span> ip<span class="token punctuation">:</span>port<span class="token punctuation">;</span>  <span class="token keyword">server</span> ip<span class="token punctuation">:</span>port<span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">server</span><span class="token punctuation">{</span>  <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>  <span class="token keyword">proxy_cache</span> my_cache<span class="token punctuation">;</span>使用cache  <span class="token keyword">proxy_cache_key</span> <span class="token variable">$host</span><span class="token variable">$uri</span><span class="token variable">$is_arges</span><span class="token variable">$arges</span><span class="token punctuation">;</span>  <span class="token keyword">proxy_cache_valid</span> <span class="token number">200</span> <span class="token number">304</span> <span class="token number">302</span> 1d<span class="token punctuation">;</span>  <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span><span class="token punctuation">;</span>传header  <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Real<span class="token operator">-</span>IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>  <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Forwarded<span class="token operator">-</span>For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>  <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>test<span class="token punctuation">;</span> 反向代理    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="nginx架构"><a href="#nginx架构" class="headerlink" title="nginx架构"></a>nginx架构</h5><h6 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h6><p>多进程模式，master &amp; slave（master管理子进程）</p><h6 id="nginx进程管理：信号"><a href="#nginx进程管理：信号" class="headerlink" title="nginx进程管理：信号"></a>nginx进程管理：信号</h6><pre><code>master进程：监控work进程——CHLD信号（linux中子进程退出时会发送CHLD信号给父进程，当nginx子进程退出时master进程会收到CHLD信号，将子进程重新拉起）接受信号：TERM ，INT（立即退出，stop）；QUIT（优雅退出，quit）；HUP（重载配置文件，reload）；USR1（重新打开日志文件，reopen）；worker进程：TERM ，INT；QUIT；USR1；WINCH</code></pre><h6 id="reload真相"><a href="#reload真相" class="headerlink" title="reload真相"></a>reload真相</h6><pre class=" language-nginx"><code class="language-nginx">① 向master进程发送HUP信号（reload命令）。② master进程校验配置文件语法的正确性。③ master进程打开新的监听端口。④ master进程用新配置启动worker进程。⑤ master向老的worker进程发送QUIT信号。⑥ 老worker进程关闭监听句柄，处理完当前连接之后结束进程。注：如果重载中worker进程由于某些原因无法正常退出，就会一直占用系统资源，可以通过worker_shutdown_timeout指令设置worker进程退出的最大等待时间。</code></pre><p><img src="/image/image-20200409231857737.png" alt="image-20200409231857737"></p><h6 id="worker进程的优雅关闭（针对http请求）"><a href="#worker进程的优雅关闭（针对http请求）" class="headerlink" title="worker进程的优雅关闭（针对http请求）"></a>worker进程的优雅关闭（针对http请求）</h6><pre class=" language-nginx"><code class="language-nginx">① 设置定时器（worker_shutdown_timeout）。② 关闭监听句柄。（保证worker进程不会再接受新的连接请求）③ 关闭空闲链接。④ 在循环中等待全部连接关闭。（如果设置了worker_shutdown_timeout，那么即使连接没有处理完也会强行关闭）⑤ 退出进程。</code></pre><h6 id="nginx事件驱动模型"><a href="#nginx事件驱动模型" class="headerlink" title="nginx事件驱动模型"></a>nginx事件驱动模型</h6><p><img src="/image/image-20200411144011102.png" alt="image-20200411144011102"></p><h6 id="epoll的优劣势及原理"><a href="#epoll的优劣势及原理" class="headerlink" title="epoll的优劣势及原理"></a>epoll的优劣势及原理</h6>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++构造函数</title>
      <link href="2021/03/18/c++%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
      <url>2021/03/18/c++%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>using namespace std<span class="token punctuation">;</span>class Person<span class="token punctuation">{</span>public<span class="token punctuation">:</span>    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"调用无参构造"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        this<span class="token operator">-></span>name <span class="token operator">=</span> <span class="token string">"null"</span><span class="token punctuation">;</span>        this<span class="token operator">-></span>age <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">Person</span><span class="token punctuation">(</span>string name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"调用有参构造函数"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        this<span class="token operator">-></span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        this<span class="token operator">-></span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> Person<span class="token operator">&amp;</span> p<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"调用拷贝构造函数"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        this<span class="token operator">-></span>name <span class="token operator">=</span> p<span class="token punctuation">.</span>name<span class="token punctuation">;</span>        this<span class="token operator">-></span>age <span class="token operator">=</span> p<span class="token punctuation">.</span>age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Person operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Person<span class="token operator">&amp;</span> p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 如果直接返回对象，在返回时会多调用一次拷贝构造函数。如果返回值为引用，则不会调用拷贝构造。另外在传参的时候也尽量要使用引用，如果不使用则会增加一次拷贝构造函数的调用。</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"调用重载符="</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        this<span class="token operator">-></span>age <span class="token operator">=</span> p<span class="token punctuation">.</span>age<span class="token punctuation">;</span>        this<span class="token operator">-></span>name <span class="token operator">=</span> p<span class="token punctuation">.</span>name<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">Info</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> this<span class="token operator">-></span>name <span class="token operator">&lt;&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;&lt;</span> this<span class="token operator">-></span>age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>private<span class="token punctuation">:</span>    string name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    string family<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Person <span class="token function">p1</span><span class="token punctuation">(</span><span class="token string">"duwei"</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Person p2<span class="token punctuation">;</span>    p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>output<span class="token punctuation">:</span>    调用有参构造函数    调用无参构造    调用重载符<span class="token operator">=</span>    调用拷贝构造函数 <span class="token comment" spellcheck="true">// 由于重载符=返回的是非引用造成的</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>zabbix_dingdingAlert</title>
      <link href="2021/03/18/zabbix_dingdingAlert/"/>
      <url>2021/03/18/zabbix_dingdingAlert/</url>
      
        <content type="html"><![CDATA[<h5 id="1、go脚本"><a href="#1、go脚本" class="headerlink" title="1、go脚本"></a>1、go脚本</h5><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"os"</span>    <span class="token string">"script/utils"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    res <span class="token operator">:=</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    message <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"message:from zabbix\n%s"</span><span class="token punctuation">,</span> res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    utils<span class="token punctuation">.</span><span class="token function">SendDingMsg</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">SendDingMsg</span><span class="token punctuation">(</span>msg <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//请求地址模板</span>    webHook <span class="token operator">:=</span> <span class="token string">`https://oapi.dingtalk.com/robot/send?access_token=ac19ab391d99a7xa93128af4e9bacbeafea151926c1187640233a2f3199baba9`</span>    content <span class="token operator">:=</span> <span class="token string">`{"msgtype": "text",        "text": {"content": "`</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">`"}    }`</span>    <span class="token comment" spellcheck="true">//创建一个请求</span>    req<span class="token punctuation">,</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewRequest</span><span class="token punctuation">(</span><span class="token string">"POST"</span><span class="token punctuation">,</span> webHook<span class="token punctuation">,</span> strings<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// handle error</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    client <span class="token operator">:=</span> <span class="token operator">&amp;</span>http<span class="token punctuation">.</span>Client<span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//设置请求头</span>    req<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/json; charset=utf-8"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//发送请求</span>    resp<span class="token punctuation">,</span> err <span class="token operator">:=</span> client<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//关闭请求</span>    <span class="token keyword">defer</span> resp<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// handle error</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2、编译脚本之后上传到zabbix-server。</p><p>查看zabbix-server配置文件，找到AlertScriptsPath参数查看存放脚本位置：AlertScriptsPath=/usr/lib/zabbix/alertscripts，将编译好的二进制文件放入。</p><p><img src="/image/image-20200623134937978.png" alt="image-20200623134937978"></p><p><img src="/image/image-20200623135101553.png" alt="image-20200623135101553"></p><p><img src="/image/image-20200623135235813.png" alt="image-20200623135235813"></p><p><img src="/image/image-20200623135331131.png" alt="image-20200623135331131"></p><p><img src="/image/image-20200623135543572.png" alt="image-20200623135543572"></p><p><img src="/image/image-20200623135605546.png" alt="image-20200623135605546"></p><p><img src="/image/image-20200623135617557.png" alt="image-20200623135617557"></p><pre><code>默认信息:告警主机：{HOST.NAME}主机IP： {HOST.IP}告警时间：{EVENT.DATE} {EVENT.TIME}告警等级：{TRIGGER.SEVERITY}告警信息：{TRIGGER.NAME}问题详情：{ITEM.NAME}:{ITEM.VALUE}当前状态: {TRIGGER.STATUS}:{ITEM.VALUE1}事件ID： {EVENT.ID}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据的存储</title>
      <link href="2021/03/18/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/"/>
      <url>2021/03/18/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h3><p>有符号：原反补相同。</p><p>计算机中的整形有符号数有三种表示方法，即原码、反码、补码。</p><p>三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位三种表示法各不相同。</p><table><thead><tr><th align="left">方法名</th><th>方法</th></tr></thead><tbody><tr><td align="left">原码</td><td>直接按照正负数的形式翻译成二进制就可以</td></tr><tr><td align="left">反码</td><td>原码的符号位不变，将其它维依次按位取反</td></tr><tr><td align="left">补码</td><td>反码加一</td></tr></tbody></table><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 0(符号位) 0000000 00000000 00000000 00010100 -原码</span>    <span class="token comment" spellcheck="true">// 00000000 00000000 00000000 00010100 -反码</span>    <span class="token comment" spellcheck="true">// 00000000 00000000 00000000 00010100 -补码</span>    <span class="token comment" spellcheck="true">// 0x00000014 十六进制</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1(符号位) 0000000 00000000 00000000 00001010 -原码</span>    <span class="token comment" spellcheck="true">// 11111111 11111111 11111111 11110101 -反码</span>    <span class="token comment" spellcheck="true">// 11111111 11111111 11111111 11110110 -补码</span>    <span class="token comment" spellcheck="true">// 0xfffffff6</span>    a<span class="token operator">+</span>b<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//   00000000000000000000000000010100</span>    <span class="token comment" spellcheck="true">//   11111111111111111111111111110110</span>    <span class="token comment" spellcheck="true">// 1 00000000000000000000000000001010 33位，int只能存32位 所以第一个1舍弃，所以结果为10</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>对于整形来说：数据存放在内存中其实存放的是补码。</p><p><img src="/image/image-20201013175359498.png" alt="image-20201013175359498"></p><p>10000000 不进行计算，直接等于128</p><p>浮点数：</p><pre><code>9.01001.01.001*2^3 == (-1)^0 * 1.001 * 2^3  //(-1)^s * M * 2^E[S 1bit][E 8bit][M 23bit]S:符号位E:指数位(无符号)M:有效数字5.5101.1(-1)^0 * 1.011 * 2^2S = 0E = 2 + 127 = 129 = 10000001(二进制)M = 1.0110 10000001 011000000000000000000000100 0000 1011 0000 0000 0000 0000 00004 0 b 0 0 0 0 0(16进制)内存: 0x40b00000 (如下图，小端存储法)</code></pre><p><img src="/image/image-20201014222847217.png" alt="image-20201014222847217"></p><pre class=" language-c"><code class="language-c">    例题：    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> <span class="token operator">*</span>pFloat <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>n<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"n的值为：%d\n"</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*pFloat的值为：%f\n"</span><span class="token punctuation">,</span><span class="token operator">*</span>pFloat<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>pFloat <span class="token operator">=</span> <span class="token number">9.0</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"num的值为：%d\n"</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*pFloat的值为：%f\n"</span><span class="token punctuation">,</span><span class="token operator">*</span>pFloat<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 9.0: 1001.0</span>    <span class="token comment" spellcheck="true">//      1.001 * 2^3</span>    <span class="token comment" spellcheck="true">// (-1)^0 3+127 001</span>    <span class="token comment" spellcheck="true">// 0 10000010 00100000000000000000000</span>    <span class="token comment" spellcheck="true">// 0100 0001 0001 0000 0000 0000 0000 0000 因为是正数，所以 补码==原码==反码</span>    <span class="token comment" spellcheck="true">//转换成10进制为：1091567616</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c学习笔记</title>
      <link href="2021/03/18/c%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/18/c%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h6 id="1、数组名。"><a href="#1、数组名。" class="headerlink" title="1、数组名。"></a>1、数组名。</h6><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token comment" spellcheck="true">/*    int main(){    char *src = "duabcdwei";    char dest[100] = { 0 };    for (;(*dest++ = *src++);){        ;    }    printf("%s\n",dest);    return 0;} * 数组名是一个常量，不能进行自增。 * 所以这里的写法是错误的。 */</span><span class="token keyword">void</span> <span class="token function">strcpy_best2</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span>dest<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;src in = %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"src = %p,line = %d\n"</span><span class="token punctuation">,</span>src<span class="token punctuation">,</span><span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">&amp;</span>src<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>dest<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>src<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*     * 在此函数被调用时，数组的地址会拷贝给形参变量，src、dest是变量，所以能够进行自增     * */</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> dest<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> src<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"duwei"</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;src out = %p\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"src out = %p\n"</span><span class="token punctuation">,</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">strcpy_best2</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span>dest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"dest = %s\n"</span><span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"src = %s\n"</span><span class="token punctuation">,</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>output<span class="token punctuation">:</span>            <span class="token operator">&amp;</span>src out <span class="token operator">=</span> <span class="token number">0x7ffeed653a32</span>            src out <span class="token operator">=</span> <span class="token number">0x7ffeed653a32</span>            <span class="token operator">&amp;</span>src in <span class="token operator">=</span> <span class="token number">0x7ffeed653a08</span>            src <span class="token operator">=</span> <span class="token number">0x7ffeed653a32</span><span class="token punctuation">,</span>line <span class="token operator">=</span> <span class="token number">64</span>            dest <span class="token operator">=</span> dAwei            src <span class="token operator">=</span> dAwei 结论：数组名是常量，不能够被修改。</code></pre><h6 id="2、字符串-内存函数"><a href="#2、字符串-内存函数" class="headerlink" title="2、字符串+内存函数"></a>2、字符串+内存函数</h6><ul><li><p>size_t strlen(const char *);</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"length = %lu\n"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token string">"learn C"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>char * strcpy(char *dest, const char *src);</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> dest<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>dest<span class="token punctuation">,</span><span class="token string">"learn C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"dest = %s\n"</span><span class="token punctuation">,</span>dest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>char * strcat(char *dest, const char *src);</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"learn"</span><span class="token punctuation">;</span>    <span class="token function">strcat</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span><span class="token string">" C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"str = \"%s\"\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    strcat(str,str);</span><span class="token comment" spellcheck="true">//    printf("str = \"%s\"\n", str);</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>int strcmp(const char *str1, const char *str2);</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*     * 比较的是ascii码     * */</span>    <span class="token keyword">int</span> ret1 <span class="token operator">=</span> <span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"first"</span><span class="token punctuation">,</span> <span class="token string">"second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ret = %d\n"</span><span class="token punctuation">,</span>ret1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -1</span>    <span class="token keyword">int</span> ret2 <span class="token operator">=</span> <span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"first"</span><span class="token punctuation">,</span> <span class="token string">"first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ret = %d\n"</span><span class="token punctuation">,</span>ret2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0</span>    <span class="token keyword">int</span> ret3 <span class="token operator">=</span> <span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"second"</span><span class="token punctuation">,</span> <span class="token string">"first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ret = %d\n"</span><span class="token punctuation">,</span>ret3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>char <em>strstr(const char\</em>, const char*);</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"this is a simple string."</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>pch <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    pch <span class="token operator">=</span> <span class="token function">strstr</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">"simple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">strncpy</span><span class="token punctuation">(</span>pch<span class="token punctuation">,</span><span class="token string">"simple"</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"str = \"%s\""</span><span class="token punctuation">,</span> pch<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>char *strtok(char *str, const char  *sep); </p><p>sep参数是字符串，包含分隔符的字符集合。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"-this,a simple string."</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>pch<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Splitting string \"%s\" into tokens:\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    pch <span class="token operator">=</span> <span class="token function">strtok</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">",.-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pch <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>pch<span class="token punctuation">)</span><span class="token punctuation">;</span>        pch <span class="token operator">=</span> <span class="token function">strtok</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token string">",.-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>strtok会改变被操作字符串，所以一般先进行拷贝再操作</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token string">"duwei19961021@163.com"</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>sep <span class="token operator">=</span> <span class="token string">"@."</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> cp<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>cp<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>str <span class="token operator">=</span> <span class="token function">strtok</span><span class="token punctuation">(</span>cp<span class="token punctuation">,</span>sep<span class="token punctuation">)</span><span class="token punctuation">;</span>str <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> str <span class="token operator">=</span> <span class="token function">strtok</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>sep<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>char *strerror(int errnum);</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">200</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d: %s\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token function">strerror</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*0: Success1: Operation not permitted2: No such file or directory3: No such process4: Interrupted system call5: Input/output error6: No such device or address7: Argument list too long8: Exec format error9: Bad file descriptor10: No child processes11: Resource temporarily unavailable12: Cannot allocate memory13: Permission denied14: Bad address15: Block device required16: Device or resource busy17: File exists18: Invalid cross-device link19: No such device20: Not a directory21: Is a directory22: Invalid argument23: Too many open files in system24: Too many open files25: Inappropriate ioctl for device26: Text file busy27: File too large28: No space left on device29: Illegal seek30: Read-only file system31: Too many links32: Broken pipe33: Numerical argument out of domain34: Numerical result out of range35: Resource deadlock avoided36: File name too long37: No locks available38: Function not implemented39: Directory not empty40: Too many levels of symbolic links41: Unknown error 4142: No message of desired type43: Identifier removed44: Channel number out of range45: Level 2 not synchronized46: Level 3 halted47: Level 3 reset48: Link number out of range49: Protocol driver not attached50: No CSI structure available51: Level 2 halted52: Invalid exchange53: Invalid request descriptor54: Exchange full55: No anode56: Invalid request code57: Invalid slot58: Unknown error 5859: Bad font file format60: Device not a stream61: No data available62: Timer expired63: Out of streams resources64: Machine is not on the network65: Package not installed66: Object is remote67: Link has been severed68: Advertise error69: Srmount error70: Communication error on send71: Protocol error72: Multihop attempted73: RFS specific error74: Bad message75: Value too large for defined data type76: Name not unique on network77: File descriptor in bad state78: Remote address changed79: Can not access a needed shared library80: Accessing a corrupted shared library81: .lib section in a.out corrupted82: Attempting to link in too many shared libraries83: Cannot exec a shared library directly84: Invalid or incomplete multibyte or wide character85: Interrupted system call should be restarted86: Streams pipe error87: Too many users88: Socket operation on non-socket89: Destination address required90: Message too long91: Protocol wrong type for socket92: Protocol not available93: Protocol not supported94: Socket type not supported95: Operation not supported96: Protocol family not supported97: Address family not supported by protocol98: Address already in use99: Cannot assign requested address100: Network is down101: Network is unreachable102: Network dropped connection on reset103: Software caused connection abort104: Connection reset by peer105: No buffer space available106: Transport endpoint is already connected107: Transport endpoint is not connected108: Cannot send after transport endpoint shutdown109: Too many references: cannot splice110: Connection timed out111: Connection refused112: Host is down113: No route to host114: Operation already in progress115: Operation now in progress116: Stale file handle117: Structure needs cleaning118: Not a XENIX named type file119: No XENIX semaphores available120: Is a named type file121: Remote I/O error122: Disk quota exceeded123: No medium found124: Wrong medium type125: Operation canceled126: Required key not available127: Key has expired128: Key has been revoked129: Key was rejected by service130: Owner died131: State not recoverable132: Operation not possible due to RF-kill133: Memory page has hardware error*/</span></code></pre></li><li><p>void *memcpy(void * dest, const void * src, size_t num);</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">struct</span> Person<span class="token punctuation">{</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span> person<span class="token punctuation">,</span>person_copy<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> my_name<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"duwei19961021"</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">,</span>my_name<span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>my_name<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    person<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>person_copy<span class="token punctuation">,</span> <span class="token operator">&amp;</span>person<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"person_copy:%s,%d\n"</span><span class="token punctuation">,</span>person_copy<span class="token punctuation">.</span>name<span class="token punctuation">,</span>person_copy<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>void *memmove(void * dest, const void * src, size_t num);</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"memmove can be very useful......"</span><span class="token punctuation">;</span>    <span class="token function">memmove</span><span class="token punctuation">(</span>str<span class="token operator">+</span><span class="token number">20</span><span class="token punctuation">,</span>str<span class="token operator">+</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"str:\"%s\""</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>int memcmp(const void *ptr1, const void *ptr2, size_t num);</p><pre><code></code></pre></li><li><p>printf</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1234</span><span class="token punctuation">,</span>b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5678</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%+-6d%+-6d%\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* * %和d之间的  * + 表示输出数字的正负号 * - 号表示s输出数据向左对齐 * 6表示输出宽度 * 如果数据宽度不够则左对齐，右边补空格 * */</span></code></pre></li><li><p>||、&amp;&amp;优先级</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">--</span> <span class="token operator">||</span> b<span class="token operator">--</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">--</span>c<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d,%d,%d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d,%d,%d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>c<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* * 逻辑与(&amp;&amp;)的优先级比逻辑或(||)的优先级高 * 先进行 b-- &amp;&amp; --c * 再将其结果和a--进行逻辑或 * */</span></code></pre></li><li><p>switch中使用continue</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123456</span><span class="token punctuation">,</span>b<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>        b<span class="token operator">=</span>a<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>        a<span class="token operator">/</span><span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">default</span><span class="token punctuation">:</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>b<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>b<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>b<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">4</span><span class="token punctuation">:</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>b<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* * 这里使用continue会导致switch所有分支在执行完成之后返回到外层的while循环， * 因此default不会被执行 * */</span></code></pre></li><li><p>局部变量覆盖全局变量</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> c <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    a<span class="token operator">++</span><span class="token punctuation">;</span>b<span class="token operator">++</span><span class="token punctuation">;</span><span class="token operator">++</span>c<span class="token punctuation">;</span><span class="token operator">++</span>d<span class="token punctuation">;</span>    <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token operator">+</span>c<span class="token operator">+</span>d<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> k<span class="token punctuation">,</span>a<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d,"</span><span class="token punctuation">,</span><span class="token function">func</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* * 在main()函数作用域中，局部变量a屏蔽全局变量a。 * func()函数和main()函数作用域属于同级，func()中没有a变量，所以去全局中找 * */</span></code></pre></li><li><p>ddddd</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C专家编程</title>
      <link href="2021/03/18/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"/>
      <url>2021/03/18/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="1-9-传参时的数据类型"><a href="#1-9-传参时的数据类型" class="headerlink" title="1.9 传参时的数据类型"></a>1.9 传参时的数据类型</h5><ul><li><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">foo</span><span class="token punctuation">(</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>output<span class="token punctuation">:</span>warning<span class="token punctuation">:</span> passing <span class="token string">'char **'</span> to parameter of type <span class="token string">'const char **'</span> discards qualifiers in nested pointer types</code></pre><p>每个实参都应该具有自己的类型，这样它的值就可以赋值给与它所对应的形参类型的对象(该对象的类型不能含有限定符)。这就是说函数传参类似于赋值。</p></li></ul><p>  要使上述赋值合法，必须满足下列条件之一:</p><p>  两个操作数都是指向有限定符或者无限定符的相同类型指针，左边指针所指向的类型必须具有右边指针所指向类型的全部限定符。</p><pre class=" language-c"><code class="language-c">  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">char</span> <span class="token operator">*</span>cp<span class="token punctuation">;</span>      <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>ccp<span class="token punctuation">;</span>      ccp <span class="token operator">=</span> cp<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/*   * 左操作数是一个指向const限定符的char指针。   * 右操作数是一个指向没有限定符的char指针。   * char类型与char类型是相容的，左操作数所指向的类型具有右操作数所指向类型的限定符，加上自身的限定符const。   * 反之: cp = ccp 在编译时会产生警告。   * */</span></code></pre><pre class=" language-c"><code class="language-c">  <span class="token keyword">const</span> <span class="token keyword">float</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//指向一个具有const限定符的float类型的指针，意思是p所指向的指针能改变，但是*p所指向的值不能改变</span></code></pre><h5 id="3-2-声明"><a href="#3-2-声明" class="headerlink" title="3.2 声明"></a>3.2 声明</h5><ul><li><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> grape1<span class="token punctuation">;</span>    <span class="token keyword">int</span> num1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token operator">*</span>grape1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: read-only variable is not assignable</span>    grape1 <span class="token operator">=</span> <span class="token operator">&amp;</span>num1<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token keyword">const</span> <span class="token operator">*</span> grape2<span class="token punctuation">;</span>    <span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token operator">*</span>grape2 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: read-only variable is not assignable</span>    grape2 <span class="token operator">=</span> <span class="token operator">&amp;</span>num2<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> grape_jelly<span class="token punctuation">;</span>    <span class="token keyword">int</span> num3 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    grape_jelly <span class="token operator">=</span> <span class="token operator">&amp;</span>num3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: read-only variable is not assignable</span>    <span class="token operator">*</span>grape_jelly <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> grape_jim<span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token keyword">const</span> <span class="token operator">*</span> <span class="token keyword">const</span> grape_jim2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//两种写法都表示对象和指针都为只读</span><span class="token punctuation">}</span></code></pre></li><li><p>函数的返回值不能是一个函数，像foo()()是非法。</p></li><li><p>函数的返回值不能是一个数组，foo()[]是非法。</p></li><li><p>数组里面不能有函数，foo<a href=""></a>是非法。</p></li><li><p>函数的返回值允许是一个函数指针，如：int(* func())()。func() 返回 int (*)()函数</p></li><li><p>函数的返回值允许是一个指向数组的指针，如：int(*  foo())[]。foo()返回 int (*)[]数组指针。</p></li><li><p>数组里面允许有函数指针，如：int(* foo[])()。* foo[]指针数组，数组类型是一个参数为void、返回值为int的函数的指针</p></li></ul><h6 id="3-2-1-结构"><a href="#3-2-1-结构" class="headerlink" title="3.2.1 结构"></a>3.2.1 结构</h6><ul><li><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> Person <span class="token punctuation">{</span>    <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span> stu1<span class="token punctuation">,</span><span class="token operator">*</span>stu2<span class="token punctuation">;</span><span class="token keyword">struct</span> s_tag <span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> s_tag orange<span class="token punctuation">,</span>lime<span class="token punctuation">,</span>lemon<span class="token punctuation">;</span><span class="token keyword">struct</span> s_tag <span class="token function">twofold</span><span class="token punctuation">(</span><span class="token keyword">struct</span> s_tag s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        s<span class="token punctuation">.</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        lime<span class="token punctuation">.</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"line%d, lime[10] = %d\n"</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">,</span>lime<span class="token punctuation">.</span>a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lemon <span class="token operator">=</span> <span class="token function">twofold</span><span class="token punctuation">(</span>lime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"line%d, lime[10] = %d\n"</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">,</span>lime<span class="token punctuation">.</span>a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 结构体是值传递</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"line%d, lemon[10] = %d\n"</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">,</span>lemon<span class="token punctuation">.</span>a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    orange <span class="token operator">=</span> lemon<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"line%d, orange[10] = %d\n"</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">,</span>orange<span class="token punctuation">.</span>a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr><h6 id="4-3-1-数组和指针是如何访问的"><a href="#4-3-1-数组和指针是如何访问的" class="headerlink" title="4.3.1 数组和指针是如何访问的"></a>4.3.1 数组和指针是如何访问的</h6><p>x = y;</p><ul><li>符号x的含义是x所代表的地址，被称为左值，左值在编译时可知，左值表示存储结果的地方。</li><li>符号y的含义是y所代表的地址的内容，被称为右值，右值知道运行时才知。</li><li>c语言术语–可修改的左值，表示允许左值出现在赋值语句的左边。数组名用于确定对象在内存中的位置，也是左值，但它不能作为赋值对象。因此，数组名是个左值但是不可修改的左值。</li></ul></li></ul><h6 id="4-3-2-定义为指针，以数组方式引用。"><a href="#4-3-2-定义为指针，以数组方式引用。" class="headerlink" title="4.3.2 定义为指针，以数组方式引用。"></a>4.3.2 定义为指针，以数组方式引用。</h6><ul><li><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token string">"abcdefgh"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化指针时所创建的字符串常量通常被定义为只读</span><span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abcdefgh"</span><span class="token punctuation">;</span><span class="token keyword">char</span> b <span class="token operator">=</span> <span class="token string">'d'</span><span class="token punctuation">;</span></code></pre><p>ps: 每个符号的地址在编译时可知。</p><ul><li><p>通过p取得字符 ‘d’: 通过编译器符号表找到p的地址，解引用得到一个地址，这个地址再加上偏移量得到字符 ‘d’。</p><p><img src="/image/image-20201028213940753.png" alt="image-20201028213940753"></p></li><li><p>通过数组名a取得字符 ‘d’: 数组名用于确定对象在内存中的位置。通过编译器符号表找到a的地址，取地址(a+3)得到字符 ‘d’。</p><p><img src="/image/image-20201028214000875.png" alt="image-20201028214000875"></p></li><li><p>通过b取得字符’d’:</p><p><img src="/image/image-20201028215340364.png" alt="image-20201028215340364"></p></li><li><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">char</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"duwei1996"</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">extern</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 一段错误代码，这段代码用我现在的编译器都编译不过去，书上用的编译器可能比较老能编译过去。</span></code></pre></li></ul></li></ul><h5 id="4-5-数组和指针的其它区别"><a href="#4-5-数组和指针的其它区别" class="headerlink" title="4.5 数组和指针的其它区别"></a>4.5 数组和指针的其它区别</h5><table><thead><tr><th align="left">指针</th><th align="left">数组</th></tr></thead><tbody><tr><td align="left">保存数据的地址</td><td align="left">保存数据的值</td></tr><tr><td align="left">间接访问数据，先取得指针的内容，把它作为地址，然后提取这个地址的数据。如果指针有个下标[ i ]，就把指针的内容加上i作为地址，从中提取数据。</td><td align="left">直接访问数据，a[i]只是意见单的a+i为地址取得数据</td></tr><tr><td align="left">通常用于动态数据结构</td><td align="left">通常用于存储固定数目且数据类型相同的元素</td></tr><tr><td align="left">相关的函数为malloc()和free()</td><td align="left">隐式分配和删除</td></tr><tr><td align="left">通常指向匿名数据</td><td align="left">自身即为数据名</td></tr></tbody></table><h5 id="6-2-段"><a href="#6-2-段" class="headerlink" title="6.2 段"></a>6.2 段</h5><ol><li><p>编译”hello world”程序，指向ls -l得到可执行文件总体大小，运行size得到文件里各段的大小。</p><p><img src="/image/image-20201029094100939.png" alt="image-20201029094100939"></p></li><li><p>增加一个全局的int[1000]的数组声明。</p><p><img src="/image/image-20201029094242979.png" alt="image-20201029094242979"></p></li><li><p>在数组声明中增加初始值。</p><p><img src="/image/image-20201029094418912.png" alt="image-20201029094418912"></p></li><li><p>在函数内部声明一个巨大的数组。</p><p><img src="/image/image-20201029094607207.png" alt="image-20201029094607207"></p></li></ol><h5 id="6-6-auto、static"><a href="#6-6-auto、static" class="headerlink" title="6.6 auto、static"></a>6.6 auto、static</h5><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">favorite_fruit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">char</span> deciduous<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"apple"</span><span class="token punctuation">;</span>  retrun deciduous<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>进入该函数时，自动变量deciduous在堆栈中分配，函数执行结束后，变量不复存在，它所占用的堆栈空间被回收，可能再任何时候被覆盖，指针就失去了有效性(引用不存在的东西)，被称为悬垂指针。如果想返回一个指向在函数内部定义的变量的指针，要把那个变量声明为static，这样就能保证该变量被保存在数据段中而不是堆栈中。</p><h5 id="9-1-什么时候指针与数组相同"><a href="#9-1-什么时候指针与数组相同" class="headerlink" title="9.1 什么时候指针与数组相同"></a>9.1 什么时候指针与数组相同</h5><ul><li><p>声明</p><p>extern，如extern char a[]; 不能改写成指针的形式(extern char *a)。</p><p>定义，如char a[10]; 不能改写成指针的形式。</p><p>函数的参数，如 func(char a[]);既可以写数组形式也可以写指针形式。</p></li><li><p>在表达式中使用</p><p>如 a = c[i]; 既可以写数组形式也可以写指针形式。</p></li><li><p>对于编译器而言，一个数组就是一个地址，一个指针是一个地址的地址。</p></li></ul><p>数组和指针是相同的三条规则</p><ol><li><p>表达式中的数组名(与声明不同)被编译器当做一个指向该数组第一个元素的指针。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 可以通过下面任何一种方法访问a[i]</span>p <span class="token operator">=</span> a<span class="token punctuation">;</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>p <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>p <span class="token operator">=</span> a <span class="token operator">+</span> i<span class="token punctuation">;</span> <span class="token operator">*</span>p<span class="token punctuation">;</span></code></pre></li><li><p>c语言把数组下标作为指针的偏移量。</p></li><li><p>作为函数参数的数组名等同于指针。</p></li></ol><h5 id="9-3-为什么c语言把数组形参当做指针"><a href="#9-3-为什么c语言把数组形参当做指针" class="headerlink" title="9.3 为什么c语言把数组形参当做指针"></a>9.3 为什么c语言把数组形参当做指针</h5><p>所有非数组形式的数据均以传值形式(对实参作一份拷贝并传递给调用的函数，函数不能修改作为实参的的实际变量的值，而只能修改传递给它的那份拷贝。)调用，然而，如果要拷贝整个数组，无论在时间上还是在内存空间上的开销都可能是非常大的。而且在大部分情况下并不需要整个数组的拷贝。所有数组在传递时都转换为指向数组起始地址的指针，而其它参数均采用传值。函数的返回值决不能是一个函数数组，而只能是指向数组或者函数的指针。</p><p><img src="/image/image-20201029140956101.png" alt="image-20201029140956101"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile</title>
      <link href="2021/03/18/Dockerfile/"/>
      <url>2021/03/18/Dockerfile/</url>
      
        <content type="html"><![CDATA[<h3 id="NGINX"><a href="#NGINX" class="headerlink" title="NGINX"></a>NGINX</h3><pre class=" language-Dockerfile"><code class="language-Dockerfile">FROM centos:centos7RUN /usr/bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \    && mkdir /data/logs -p \    && mkdir /data/www -p \    && rm -rf /etc/yum.repos.d/* \    && curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo\    && yum -y install wget \    && curl -o /etc/yum.repos.d/nginx.repo http://172.16.72.173/nginx_config/nginx.repo \    && yum clean all \     && yum repolist \    && yum -y install nginxRUN rm -rf /etc/nginx/conf.d/default.conf \    && curl -o /etc/nginx/nginx.conf http://172.16.72.173/v2/nginx_config/nginx.conf \    && sed -i 's/user  nginx;/user  www;/' /etc/nginx/nginx.conf \    && useradd www -s /sbin/nologin CMD ["nginx","-g","daemon off;"]</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre class=" language-dockerfile"><code class="language-dockerfile">FROM centos:centos7RUN /usr/bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \    && mkdir /data/www -p \    && mkdir /data/logs/ -p \    && rm -rf /etc/yum.repos.d/* \    && curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo \    && curl -o /etc/yum.repos.d/Centos-7-epel.repo https://mirrors.aliyun.com/repo/epel.repo \    && yum clean all \     && yum repolist \    && curl -o /usr/local/src/php-7.1.3.tar.gz http://172.16.72.173/packages/php-7.1.3.tar.gz \    && cd /usr/local/src && tar xf php-7.1.3.tar.gz \    && yum clean all \    && yum repolist \    && yum -y install cmake doxygen php-mysqlnd autoconf make freetype-devel openssl-devel gcc gcc-c++ bison libxml2-devel curl-devel libjpeg-devel libpng-devel libc-client-devel libmcrypt-devel librabbitmq-devel \    && cd /usr/local/src/php-7.1.3 \    && groupadd -g 1001 www \    && useradd -g 1001 -M -s /sbin/nologin www \    && ./configure --prefix=/usr/local/php \       --exec-prefix=/usr/local/php \       --bindir=/usr/local/php/bin \       --sbindir=/usr/local/php/sbin \       --includedir=/usr/local/php/include \       --libdir=/usr/local/php/lib/php \       --mandir=/usr/local/php/php/man \       --with-config-file-path=/usr/local/php/etc \       --with-mcrypt=/usr/include \       --without-pear \       --disable-phar \       --with-mhash \       --with-openssl \       --with-pdo-mysql=shared,mysqlnd \       --with-gd \       --with-iconv \       --with-zlib \       --enable-zip \       --enable-inline-optimization \       --disable-debug \       --disable-rpath \       --enable-shared \       --enable-xml \       --enable-bcmath \       --enable-shmop \       --enable-sysvsem \       --enable-mbregex \       --enable-mbstring \       --enable-ftp \       --enable-gd-native-ttf \       --enable-pcntl \       --enable-sockets \       --with-xmlrpc \       --enable-soap \       --without-pear \       --with-gettext \       --enable-session \       --with-curl=/usr/include/x86_64-linux-gnu/curl \       --with-jpeg-dir \       --with-freetype-dir \       --enable-opcache \       --enable-fpm \       --with-fpm-user=www \       --with-fpm-group=www \       --without-gdbm \    && make \    && make install \    && curl http://172.16.72.173/packages/redis-5.0.2.tgz -o /usr/local/src/php-7.1.3/ext/redis-5.0.2.tgz \    && cd /usr/local/src/php-7.1.3/ext/ \    && tar xf redis-5.0.2.tgz \    && cd redis-5.0.2 \    && /usr/local/php/bin/phpize \    && ./configure \       --with-php-config=/usr/local/php/bin/php-config \    && make && make install \    && cd /usr/local/src/php-7.1.3/ext/fileinfo \    && /usr/local/php/bin/phpize \    && ./configure \       --with-php-config=/usr/local/php/bin/php-config --enable-fileinfo\    && make \    && make install \    && curl http://172.16.72.173/packages/amqp-1.9.3.tgz -o /usr/local/src/php-7.1.3/ext/amqp-1.9.3.tgz \    && cd /usr/local/src/php-7.1.3/ext \    && tar xf  amqp-1.9.3.tgz \    && cd amqp-1.9.3 \    && /usr/local/php/bin/phpize \    && ./configure \       --with-php-config=/usr/local/php/bin/php-config \    && make \    && make install \    && curl http://172.16.72.173/packages/mongodb-1.5.3.tgz -o /usr/local/src/php-7.1.3/ext/mongodb-1.5.3.tgz \    && cd /usr/local/src/php-7.1.3/ext \    && tar xf mongodb-1.5.3.tgz \    && cd mongodb-1.5.3 \    && /usr/local/php/bin/phpize \    && ./configure \       --with-php-config=/usr/local/php/bin/php-config \    && make && make install \     && cd /usr/local/src/php-7.1.3/ext/mysqli \    && /usr/local/php/bin/phpize \    && ./configure \       --with-php-config=/usr/local/php/bin/php-config \    && make \    && make install \    && rm -rf /usr/local/src/* \    && yum -y autoremove gcc gcc-c++ make autoconf cmake\    && yum clean all \    && curl http://172.16.72.173/v2/php_config/php-fpm.conf -o /usr/local/php/etc/php-fpm.conf \    && curl http://172.16.72.173/v2/php_config/php.ini -o /usr/local/php/etc/php.ini \    && curl http://172.16.72.173/v2/php_config/www.conf -o /usr/local/php/etc/php-fpm.d/www.conf </code></pre><h3 id="SUPERVISOR"><a href="#SUPERVISOR" class="headerlink" title="SUPERVISOR"></a>SUPERVISOR</h3><pre class=" language-dockerfile"><code class="language-dockerfile">FROM centos:centos7RUN /usr/bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \    && mkdir /data/www -p \    && mkdir /data/logs/ -p \    && rm -rf /etc/yum.repos.d/* \    && curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo \    && curl -o /etc/yum.repos.d/Centos-7-epel.repo https://mirrors.aliyun.com/repo/epel.repo \    && yum clean all \     && yum repolist \    && curl -o /usr/local/src/php-7.1.3.tar.gz http://172.16.72.173/packages/php-7.1.3.tar.gz \    && cd /usr/local/src && tar xf php-7.1.3.tar.gz \    && yum clean all \    && yum repolist \    && yum -y install cmake python-setuptools doxygen php-mysqlnd autoconf make freetype-devel openssl-devel gcc gcc-c++ bison libxml2-devel curl-devel libjpeg-devel libpng-devel libc-client-devel libmcrypt-devel librabbitmq-devel \    && cd /usr/local/src/php-7.1.3 \    && groupadd -g 1001 www \    && useradd -g 1001 -M -s /sbin/nologin www \    && ./configure --prefix=/usr/local/php \       --exec-prefix=/usr/local/php \       --bindir=/usr/local/php/bin \       --sbindir=/usr/local/php/sbin \       --includedir=/usr/local/php/include \       --libdir=/usr/local/php/lib/php \       --mandir=/usr/local/php/php/man \       --with-config-file-path=/usr/local/php/etc \       --with-mcrypt=/usr/include \       --without-pear \       --disable-phar \       --with-mhash \       --with-openssl \       --with-pdo-mysql=shared,mysqlnd \       --with-gd \       --with-iconv \       --with-zlib \       --enable-zip \       --enable-inline-optimization \       --disable-debug \       --disable-rpath \       --enable-shared \       --enable-xml \       --enable-bcmath \       --enable-shmop \       --enable-sysvsem \       --enable-mbregex \       --enable-mbstring \       --enable-ftp \       --enable-gd-native-ttf \       --enable-pcntl \       --enable-sockets \       --with-xmlrpc \       --enable-soap \       --without-pear \       --with-gettext \       --enable-session \       --with-curl=/usr/include/x86_64-linux-gnu/curl \       --with-jpeg-dir \       --with-freetype-dir \       --enable-opcache \       --enable-fpm \       --with-fpm-user=www \       --with-fpm-group=www \       --without-gdbm \    && make \    && make install \    && curl http://172.16.72.173/packages/redis-5.0.2.tgz -o /usr/local/src/php-7.1.3/ext/redis-5.0.2.tgz \    && cd /usr/local/src/php-7.1.3/ext/ \    && tar xf redis-5.0.2.tgz \    && cd redis-5.0.2 \    && /usr/local/php/bin/phpize \    && ./configure \       --with-php-config=/usr/local/php/bin/php-config \    && make && make install \    && cd /usr/local/src/php-7.1.3/ext/fileinfo \    && /usr/local/php/bin/phpize \    && ./configure \       --with-php-config=/usr/local/php/bin/php-config --enable-fileinfo\    && make \    && make install \    && curl http://172.16.72.173/packages/amqp-1.9.3.tgz -o /usr/local/src/php-7.1.3/ext/amqp-1.9.3.tgz \    && cd /usr/local/src/php-7.1.3/ext \    && tar xf  amqp-1.9.3.tgz \    && cd amqp-1.9.3 \    && /usr/local/php/bin/phpize \    && ./configure \       --with-php-config=/usr/local/php/bin/php-config \    && make \    && make install \    && curl http://172.16.72.173/packages/mongodb-1.5.3.tgz -o /usr/local/src/php-7.1.3/ext/mongodb-1.5.3.tgz \    && cd /usr/local/src/php-7.1.3/ext \    && tar xf mongodb-1.5.3.tgz \    && cd mongodb-1.5.3 \    && /usr/local/php/bin/phpize \    && ./configure \       --with-php-config=/usr/local/php/bin/php-config \    && make && make install \     && cd /usr/local/src/php-7.1.3/ext/mysqli \    && /usr/local/php/bin/phpize \    && ./configure \       --with-php-config=/usr/local/php/bin/php-config \    && make \    && make install \    && curl -o /usr/local/src/supervisor-3.4.0-1.el7.noarch.rpm http://172.16.72.173/packages/supervisor-3.4.0-1.el7.noarch.rpm \    && curl -o /usr/local/src/python-meld3-0.6.10-1.el7.x86_64.rpm http://172.16.72.173/packages/python-meld3-0.6.10-1.el7.x86_64.rpm \    && rpm -ivh /usr/local/src/python-meld3-0.6.10-1.el7.x86_64.rpm \    && rpm -ivh /usr/local/src/supervisor-3.4.0-1.el7.noarch.rpm \    && rm -rf /usr/local/src/* \    && yum -y autoremove gcc gcc-c++ make autoconf cmake\    && yum clean all \    && curl http://172.16.72.173/v2/php_config/php-fpm.conf -o /usr/local/php/etc/php-fpm.conf \    && curl http://172.16.72.173/v2/php_config/php.ini -o /usr/local/php/etc/php.ini \    && curl http://172.16.72.173/v2/php_config/www.conf -o /usr/local/php/etc/php-fpm.d/www.conf </code></pre><h3 id="REDIS"><a href="#REDIS" class="headerlink" title="REDIS"></a>REDIS</h3><pre class=" language-dockerfile"><code class="language-dockerfile">FROM centos:centos7RUN yum -y install epel-release \    && yum -y install redis \    && sed -i 's/^bind 127.0.0.1/bind 0.0.0.0/' /etc/redis.conf \    && sed -i 's/^# requirepass foobared/requirepass 3IPvlX81kaflqzB/' /etc/redis.conf CMD ["/usr/bin/redis-server","/etc/redis.conf"] </code></pre><h3 id="GOLANG"><a href="#GOLANG" class="headerlink" title="GOLANG"></a>GOLANG</h3><pre class=" language-dockerfile"><code class="language-dockerfile">FROM centos:centos7ADD go1.13.5.linux-amd64.tar.gz /usr/local/ RUN mkdir -p /data/wwwENV GOROOT /usr/local/go/ENV PATH $PATH:$GOROOT/bin:$GOPATH/binENV GOPATH /data/www/ENV PATH $PATH:$GOPATH/binENV GO111MODULE onENV GOPROXY https://goproxy.cn,directWORKDIR /data/www/src/yanxiangbookCMD ["bee","run"]</code></pre><h3 id="CODEBOX"><a href="#CODEBOX" class="headerlink" title="CODEBOX"></a>CODEBOX</h3><pre class=" language-dockerfile"><code class="language-dockerfile">FROM registry.cn-hangzhou.aliyuncs.com/ysg_baseimage/codebox:v1RUN mkdir /data/wwwroot/ -p && adduser www -s /sbin/nologin -D -H</code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dockerfile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>make</title>
      <link href="2021/03/18/make/"/>
      <url>2021/03/18/make/</url>
      
        <content type="html"><![CDATA[<h5 id="make简介"><a href="#make简介" class="headerlink" title="make简介"></a>make简介</h5><p>Linux自动化构建工具，方便工程的编译。</p><h6 id="单文件Makefile"><a href="#单文件Makefile" class="headerlink" title="单文件Makefile"></a>单文件Makefile</h6><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">for</span><span class="token punctuation">:</span>for.c    <span class="token operator">@</span>gcc -o <span class="token variable">$@</span> for.c<span class="token builtin">.PHONY</span><span class="token punctuation">:</span>clean<span class="token symbol">clean</span><span class="token punctuation">:</span>    <span class="token operator">@</span>rm -rf for <span class="token comment" spellcheck="true">#加上@符号，在执行make时就不会将输出显示在终端上</span></code></pre><h6 id="多文件Makefile"><a href="#多文件Makefile" class="headerlink" title="多文件Makefile"></a>多文件Makefile</h6><pre class=" language-shell"><code class="language-shell">root$ tree.├── bar.c├── bar.h├── Makefile└── test.c</code></pre><p>bar.h</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">pragma</span> onece</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> N 101</span></code></pre><p>bar.c</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"bar.h"</span></span><span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> bar<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>bar<span class="token punctuation">,</span><span class="token string">'\0'</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> label<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"|/-\\"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bar<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'#'</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%-100s][%3d%%][%c]\r"</span><span class="token punctuation">,</span>bar<span class="token punctuation">,</span>i<span class="token punctuation">,</span>label<span class="token punctuation">[</span>i<span class="token operator">%</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>test.c</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"bar.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Makefile</p><pre class=" language-makefile"><code class="language-makefile">cc <span class="token operator">=</span> gcc <span class="token comment" spellcheck="true">#定义变量不需要带引号</span>targetFile <span class="token operator">=</span> test.o bar.obin<span class="token operator">=</span>test<span class="token symbol"><span class="token variable">$</span>(bin)</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>targetFile<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 表示一个依赖关系 $(bin) 的编译生成可执行文件依赖于 $(targetFile)</span>    <span class="token variable">$</span><span class="token punctuation">(</span>cc<span class="token punctuation">)</span> -o <span class="token variable">$@</span> <span class="token variable">$^</span> <span class="token comment" spellcheck="true"># $@ 代表依赖关系中的目标文件也就是$(bin)=test,$^ 代表依赖文件列表也就是$(targetFile)=test.o bar.o</span><span class="token symbol">%.o</span><span class="token punctuation">:</span>%.c    <span class="token variable">$</span><span class="token punctuation">(</span>cc<span class="token punctuation">)</span> -c  <span class="token variable">$&lt;</span> <span class="token comment" spellcheck="true"># $&lt; 代表当前目录下所有 %.c文件的集合</span><span class="token builtin">.PHONY</span><span class="token punctuation">:</span>clean<span class="token symbol">clean</span><span class="token punctuation">:</span>    rm -rf <span class="token variable">$</span><span class="token punctuation">(</span>targetFile<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>bin<span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zabbix_key</title>
      <link href="2021/03/18/zabbix_key/"/>
      <url>2021/03/18/zabbix_key/</url>
      
        <content type="html"><![CDATA[<h5 id="proc-num-lt-name-gt-lt-user-gt-lt-state-gt-lt-cmdline-gt-（进程数量。）"><a href="#proc-num-lt-name-gt-lt-user-gt-lt-state-gt-lt-cmdline-gt-（进程数量。）" class="headerlink" title="proc.num[&lt;name&gt;,&lt;user&gt;,&lt;state&gt;,&lt;cmdline&gt;] （进程数量。）"></a>proc.num[&lt;name&gt;,&lt;user&gt;,&lt;state&gt;,&lt;cmdline&gt;] （进程数量。）</h5><p><img src="/image/image-20200525113154329.png" alt="image-20200525113154329"></p><pre class=" language-shell"><code class="language-shell">[operate@zabbix ~]$ zabbix_get -s 47.98.232.109 -p 10050 -k "proc.num[,www,,]" 428[operate@zabbix ~]$ zabbix_get -s 47.98.232.109 -p 10050 -k "proc.num[nginx,www,,]"8[operate@zabbix ~]$ zabbix_get -s 47.98.232.109 -p 10050 -k "proc.num[php-fpm,www,,]"420</code></pre><hr><h5 id="net-if-in-if-lt-mode-gt-（网卡流入量统计。）"><a href="#net-if-in-if-lt-mode-gt-（网卡流入量统计。）" class="headerlink" title="net.if.in[if,&lt;mode&gt;]（网卡流入量统计。）"></a>net.if.in[if,&lt;mode&gt;]（网卡流入量统计。）</h5><p><img src="/image/image-20200525111344653.png" alt="image-20200525111344653"></p><pre class=" language-shell"><code class="language-shell">[operate@zabbix ~]$ zabbix_get -s 47.98.232.109 -p 10050 -k "net.if.in[eth0,]"7439402782114[operate@zabbix ~]$ zabbix_get -s 47.98.232.109 -p 10050 -k "net.if.in[eth0,errors]"0[operate@zabbix ~]$ zabbix_get -s 47.98.232.109 -p 10050 -k "net.if.in[eth0,packets]"19550922396[operate@zabbix ~]$ zabbix_get -s 47.98.232.109 -p 10050 -k "net.if.in[eth0,dropped]"0</code></pre><hr><h5 id="net-if-out-if-lt-mode-gt-（网卡流出量统计。）"><a href="#net-if-out-if-lt-mode-gt-（网卡流出量统计。）" class="headerlink" title="net.if.out[if,&lt;mode&gt;] （网卡流出量统计。）"></a>net.if.out[if,&lt;mode&gt;] （网卡流出量统计。）</h5><p><img src="/image/image-20200525111406296.png" alt="image-20200525111406296"></p><h5 id="net-if-total-if-lt-mode-gt-（网卡的进出流量统计信息的总和。）"><a href="#net-if-total-if-lt-mode-gt-（网卡的进出流量统计信息的总和。）" class="headerlink" title="net.if.total[if,&lt;mode&gt;] （网卡的进出流量统计信息的总和。）"></a>net.if.total[if,&lt;mode&gt;] （网卡的进出流量统计信息的总和。）</h5><p><img src="/image/image-20200525111504950.png" alt="image-20200525111504950"></p><hr><h5 id="net-tcp-listen-port-（检查此TCP端口是否处于监听状态。）"><a href="#net-tcp-listen-port-（检查此TCP端口是否处于监听状态。）" class="headerlink" title="net.tcp.listen[port] （检查此TCP端口是否处于监听状态。）"></a>net.tcp.listen[port] （检查此TCP端口是否处于监听状态。）</h5><p><img src="/image/image-20200525111552167.png" alt="image-20200525111552167"></p><pre class=" language-shell"><code class="language-shell">[operate@zabbix ~]$ zabbix_get -s 47.98.232.109 -p 10050 -k "net.tcp.listen[443]"0[operate@zabbix ~]$ zabbix_get -s 47.98.232.109 -p 10050 -k "net.tcp.listen[80]"1[operate@zabbix ~]$ zabbix_get -s 47.98.232.109 -p 10050 -k "net.tcp.listen[9000]"1</code></pre><hr><h5 id="net-tcp-port-lt-ip-gt-port-检查是否可以将TCP连接到指定的端口。"><a href="#net-tcp-port-lt-ip-gt-port-检查是否可以将TCP连接到指定的端口。" class="headerlink" title="net.tcp.port[&lt;ip&gt;,port] (检查是否可以将TCP连接到指定的端口。)"></a>net.tcp.port[&lt;ip&gt;,port] (检查是否可以将TCP连接到指定的端口。)</h5><p><img src="/image/image-20200525111914954.png" alt="image-20200525111914954"></p><pre class=" language-shell"><code class="language-shell">[operate@zabbix ~]$ zabbix_get -s 47.98.232.109 -p 10050 -k "net.tcp.port[,80]"1[operate@zabbix ~]$ zabbix_get -s 47.98.232.109 -p 10050 -k "net.tcp.port[,8080]"0[operate@zabbix ~]$ zabbix_get -s 47.98.232.109 -p 10050 -k "net.tcp.port[,9000]"1[operate@zabbix ~]$ zabbix_get -s 47.98.232.109 -p 10050 -k "net.tcp.port[47.98.232.213,9000]"0[operate@zabbix ~]$ zabbix_get -s 47.98.232.109 -p 10050 -k "net.tcp.port[47.98.232.213,80]"1</code></pre><hr><h5 id="net-tcp-service-service-lt-ip-gt-lt-port-gt-检查服务是否正在运行并接受TCP连接。"><a href="#net-tcp-service-service-lt-ip-gt-lt-port-gt-检查服务是否正在运行并接受TCP连接。" class="headerlink" title="net.tcp.service[service,&lt;ip&gt;,&lt;port&gt;] (检查服务是否正在运行并接受TCP连接。)"></a>net.tcp.service[service,&lt;ip&gt;,&lt;port&gt;] (检查服务是否正在运行并接受TCP连接。)</h5><p><img src="/image/image-20200525113647463.png" alt="image-20200525113647463"></p><pre class=" language-shell"><code class="language-shell">[operate@zabbix ~]$ zabbix_get -s 47.98.232.109 -p 10050 -k "net.tcp.service[http,47.98.232.109,80]"1[operate@zabbix ~]$ zabbix_get -s 47.98.232.109 -p 10050 -k "net.tcp.service[https,47.98.232.109,443]"0</code></pre><hr><h5 id="net-tcp-service-perf-（检测TCP服务性能。）"><a href="#net-tcp-service-perf-（检测TCP服务性能。）" class="headerlink" title="net.tcp.service.perf （检测TCP服务性能。）"></a>net.tcp.service.perf （检测TCP服务性能。）</h5><p><img src="/image/image-20200525114022965.png" alt="image-20200525114022965"></p><pre class=" language-shell"><code class="language-shell">[operate@zabbix ~]$ zabbix_get -s 47.98.232.109 -p 10050 -k "net.tcp.service.perf[http,47.98.232.109,80]"0.001654</code></pre><hr><h5 id="net-tcp-service-perf-service-lt-ip-gt-lt-port-gt-（进程CPU利用率百分比。）"><a href="#net-tcp-service-perf-service-lt-ip-gt-lt-port-gt-（进程CPU利用率百分比。）" class="headerlink" title="net.tcp.service.perf[service,&lt;ip&gt;,&lt;port&gt;] （进程CPU利用率百分比。）"></a>net.tcp.service.perf[service,&lt;ip&gt;,&lt;port&gt;] （进程CPU利用率百分比。）</h5><p><img src="/image/image-20200525114323650.png" alt="image-20200525114323650"></p><hr><h5 id="proc-mem-lt-name-gt-lt-user-gt-lt-mode-gt-lt-cmdline-gt-lt-memtype-gt-（用户进程使用的内存。）"><a href="#proc-mem-lt-name-gt-lt-user-gt-lt-mode-gt-lt-cmdline-gt-lt-memtype-gt-（用户进程使用的内存。）" class="headerlink" title="proc.mem[&lt;name&gt;,&lt;user&gt;,&lt;mode&gt;,&lt;cmdline&gt;,&lt;memtype&gt;] （用户进程使用的内存。）"></a>proc.mem[&lt;name&gt;,&lt;user&gt;,&lt;mode&gt;,&lt;cmdline&gt;,&lt;memtype&gt;] （用户进程使用的内存。）</h5><p><img src="/image/image-20200525115108988.png" alt="image-20200525115108988"></p><pre class=" language-shell"><code class="language-shell">[operate@zabbix ~]$ zabbix_get -s 47.98.232.109 -p 10050 -k "proc.mem[,root]"101788995584</code></pre><hr><h5 id="system-cpu-load-lt-cpu-gt-lt-mode-gt-（CPU负载。）"><a href="#system-cpu-load-lt-cpu-gt-lt-mode-gt-（CPU负载。）" class="headerlink" title="system.cpu.load[&lt;cpu&gt;,&lt;mode&gt;] （CPU负载。）"></a>system.cpu.load[&lt;cpu&gt;,&lt;mode&gt;] （CPU负载。）</h5><p><img src="/image/image-20200525115459054.png" alt="image-20200525115459054"></p><hr><h5 id="system-cpu-util-lt-cpu-gt-lt-type-gt-lt-mode-gt-（CPU利用率。）"><a href="#system-cpu-util-lt-cpu-gt-lt-type-gt-lt-mode-gt-（CPU利用率。）" class="headerlink" title="system.cpu.util[&lt;cpu&gt;,&lt;type&gt;,&lt;mode&gt;] （CPU利用率。）"></a>system.cpu.util[&lt;cpu&gt;,&lt;type&gt;,&lt;mode&gt;] （CPU利用率。）</h5><p><img src="/image/image-20200525115542742.png" alt="image-20200525115542742"></p><hr><h5 id="system-run-command-lt-mode-gt-（在主机上运行指定的命令-注意-要启用此功能，Zabbix-agent配置文件-必须包含EnableRemoteCommands-1-选项。）"><a href="#system-run-command-lt-mode-gt-（在主机上运行指定的命令-注意-要启用此功能，Zabbix-agent配置文件-必须包含EnableRemoteCommands-1-选项。）" class="headerlink" title="system.run[command,&lt;mode&gt;] （在主机上运行指定的命令,注意: 要启用此功能，Zabbix agent配置文件 必须包含EnableRemoteCommands=1 选项。）"></a>system.run[command,&lt;mode&gt;] （在主机上运行指定的命令,<em>注意</em>: 要启用此功能，<a href="https://www.zabbix.com/documentation/4.0/zh/manual/appendix/config/zabbix_agentd" target="_blank" rel="noopener">Zabbix agent配置文件</a> 必须包含EnableRemoteCommands=1 选项。）</h5><p><img src="/image/image-20200525115644321.png" alt="image-20200525115644321"></p><hr><h5 id="vfs-file-cksum-file-（文件checksum校验，由UNIX-cksum算法计算实现。）"><a href="#vfs-file-cksum-file-（文件checksum校验，由UNIX-cksum算法计算实现。）" class="headerlink" title="vfs.file.cksum[file] （文件checksum校验，由UNIX cksum算法计算实现。）"></a>vfs.file.cksum[file] （文件checksum校验，由UNIX cksum算法计算实现。）</h5><p><img src="/image/image-20200525132414428.png" alt="image-20200525132414428"></p><pre class=" language-shell"><code class="language-shell">zabbix_get -s 47.98.232.109 -p 10050 -k "vfs.file.cksum[/usr/local/nginx/conf/vhost/novel.conf]"</code></pre><hr><h5 id="vfs-file-exists-file-（检测文件是否存在。）"><a href="#vfs-file-exists-file-（检测文件是否存在。）" class="headerlink" title="vfs.file.exists[file] （检测文件是否存在。）"></a>vfs.file.exists[file] （检测文件是否存在。）</h5><p><img src="/image/image-20200525133105157.png" alt="image-20200525133105157"></p><hr><h5 id="vfs-file-size-file-（文件大小-按字节-。）"><a href="#vfs-file-size-file-（文件大小-按字节-。）" class="headerlink" title="vfs.file.size[file] （文件大小(按字节)。）"></a>vfs.file.size[file] （文件大小(按字节)。）</h5><p><img src="/image/image-20200525133246973.png" alt="image-20200525133246973"></p><hr><h5 id="vfs-fs-inode-fs-lt-mode-gt-（inode的数量或百分比。）"><a href="#vfs-fs-inode-fs-lt-mode-gt-（inode的数量或百分比。）" class="headerlink" title="vfs.fs.inode[fs,&lt;mode&gt;] （inode的数量或百分比。）"></a>vfs.fs.inode[fs,&lt;mode&gt;] （inode的数量或百分比。）</h5><p><img src="/image/image-20200525133447450.png" alt="image-20200525133447450"></p><pre class=" language-shell"><code class="language-shell">[root@zabbix ~]# zabbix_get -s 47.98.232.109 -p 10050 -k "vfs.fs.inode[/,used]"228387[root@zabbix ~]# zabbix_get -s 47.98.232.109 -p 10050 -k "vfs.fs.inode[/,pused]"8.712273</code></pre><hr><h5 id="vfs-fs-size-fs-lt-mode-gt-（磁盘空间，以字节为单位，用百分比表示。）"><a href="#vfs-fs-size-fs-lt-mode-gt-（磁盘空间，以字节为单位，用百分比表示。）" class="headerlink" title="vfs.fs.size[fs,&lt;mode&gt;]（磁盘空间，以字节为单位，用百分比表示。）"></a>vfs.fs.size[fs,&lt;mode&gt;]（磁盘空间，以字节为单位，用百分比表示。）</h5><p><img src="/image/image-20200525133845172.png" alt="image-20200525133845172"></p><pre class=" language-shell"><code class="language-shell">[root@zabbix ~]# zabbix_get -s 47.98.232.109 -p 10050 -k "vfs.fs.size[/,pused]"32.847219</code></pre><hr><h5 id="vm-memory-size-lt-mode-gt-（内存大小，以字节为单位，以百分比表示。）"><a href="#vm-memory-size-lt-mode-gt-（内存大小，以字节为单位，以百分比表示。）" class="headerlink" title="vm.memory.size[&lt;mode&gt;] （内存大小，以字节为单位，以百分比表示。）"></a>vm.memory.size[&lt;mode&gt;] （内存大小，以字节为单位，以百分比表示。）</h5><p><img src="/image/image-20200525134122329.png" alt="image-20200525134122329"></p><pre class=" language-shell"><code class="language-shell">[root@zabbix ~]# zabbix_get -s 47.98.232.109 -p 10050 -k "vm.memory.size[cached]"8009416704[root@zabbix ~]# zabbix_get -s 47.98.232.109 -p 10050 -k "vm.memory.size[buffers]"329150464[root@zabbix ~]# zabbix_get -s 47.98.232.109 -p 10050 -k "vm.memory.size[used]"12454846464[root@zabbix ~]# zabbix_get -s 47.98.232.109 -p 10050 -k "vm.memory.size[pused]"74.776654</code></pre><hr><h5 id="web-page-get-host-lt-path-gt-lt-port-gt-（获取网页内容）"><a href="#web-page-get-host-lt-path-gt-lt-port-gt-（获取网页内容）" class="headerlink" title="web.page.get[host,&lt;path&gt;,&lt;port&gt;] （获取网页内容）"></a>web.page.get[host,&lt;path&gt;,&lt;port&gt;] （获取网页内容）</h5><p><img src="/image/image-20200525134654792.png" alt="image-20200525134654792"></p><pre class=" language-shell"><code class="language-shell">[root@zabbix ~]# zabbix_get -s 47.98.232.109 -p 10050 -k "web.page.get[www.baidu.com,/,80]"</code></pre><hr><h5 id="web-page-perf-host-lt-path-gt-lt-port-gt-（加载完整网页的时间（以秒为单位）。）"><a href="#web-page-perf-host-lt-path-gt-lt-port-gt-（加载完整网页的时间（以秒为单位）。）" class="headerlink" title="web.page.perf[host,&lt;path&gt;,&lt;port&gt;] （加载完整网页的时间（以秒为单位）。）"></a>web.page.perf[host,&lt;path&gt;,&lt;port&gt;] （加载完整网页的时间（以秒为单位）。）</h5><p><img src="/image/image-20200525134853019.png" alt="image-20200525134853019"></p><pre class=" language-shell"><code class="language-shell">[root@zabbix ~]# zabbix_get -s 47.98.232.109 -p 10050 -k "web.page.perf[www.baidu.com,/,80]"0.023391</code></pre><hr><h5 id="web-page-regexp-host-lt-path-gt-lt-port-gt-lt-regexp-gt-lt-length-gt-lt-output-gt-（在网页上查找字符串。）"><a href="#web-page-regexp-host-lt-path-gt-lt-port-gt-lt-regexp-gt-lt-length-gt-lt-output-gt-（在网页上查找字符串。）" class="headerlink" title="web.page.regexp[host,&lt;path&gt;,&lt;port&gt;,&lt;regexp&gt;,&lt;length&gt;,&lt;output&gt;] （在网页上查找字符串。）"></a>web.page.regexp[host,&lt;path&gt;,&lt;port&gt;,&lt;regexp&gt;,&lt;length&gt;,&lt;output&gt;] （在网页上查找字符串。）</h5><p><img src="/image/image-20200525135217382.png" alt="image-20200525135217382"></p><pre class=" language-shell"><code class="language-shell">[root@zabbix ~]# zabbix_get -s 47.98.232.109 -p 10050 -k "web.page.regexp[www.baidu.com,/,80,baidu,100,1]"1</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针</title>
      <link href="2021/03/18/%E6%8C%87%E9%92%88/"/>
      <url>2021/03/18/%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h3 id="1、函数指针"><a href="#1、函数指针" class="headerlink" title="1、函数指针"></a>1、函数指针</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token function">signal</span><span class="token punctuation">(</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// signal是一个函数声明</span><span class="token comment" spellcheck="true">// signal函数的参数有2个，第一个是int，第二个是函数指针，改函数指针的参数是int，返回类型是void</span><span class="token comment" spellcheck="true">// signal函数的返回类型也是一个函数指针：该函数指针指向的函数的参数是int，返回类型是void</span><span class="token comment" spellcheck="true">//简化</span><span class="token keyword">typedef</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>pfun_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pfun_t <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> pfun_t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">my_strcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> dest<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>pfArr<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="2、qsort-demo"><a href="#2、qsort-demo" class="headerlink" title="2、qsort demo"></a>2、qsort demo</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stdlib.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token keyword">struct</span> student<span class="token punctuation">{</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">CmpStudentAge</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> e1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> e2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> student<span class="token operator">*</span><span class="token punctuation">)</span>e1<span class="token punctuation">)</span><span class="token operator">-></span>age<span class="token operator">-</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> student<span class="token operator">*</span><span class="token punctuation">)</span>e2<span class="token punctuation">)</span><span class="token operator">-></span>age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">CmpStudentName</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> e1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> e2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> student<span class="token operator">*</span><span class="token punctuation">)</span>e1<span class="token punctuation">)</span><span class="token operator">-></span>name<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> student<span class="token operator">*</span><span class="token punctuation">)</span>e2<span class="token punctuation">)</span><span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> student s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"lisi"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"duwei"</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> student<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> student<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">qsort</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> len<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> CmpStudentName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*     * 第一个参数：待排序数组的首元素地址     * 第二个参数：待排序数组的元素个数     * 第三个参数：待排序数组的每个元素的大小，单位是字节     * 第四个参数：是函数指针，比较两个元素的函数的地址，需要自己实现     *           函数指针的两个参数是：待比较的两个元素的地址     * */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s "</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="3、简单实现qsort-，冒泡排序版。"><a href="#3、简单实现qsort-，冒泡排序版。" class="headerlink" title="3、简单实现qsort()，冒泡排序版。"></a>3、简单实现qsort()，冒泡排序版。</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> person<span class="token punctuation">{</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> buf1<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> buf2<span class="token punctuation">,</span> <span class="token keyword">int</span> width<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> width<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span> tmp <span class="token operator">=</span> <span class="token operator">*</span>buf1<span class="token punctuation">;</span>        <span class="token operator">*</span>buf1 <span class="token operator">=</span> <span class="token operator">*</span>buf2<span class="token punctuation">;</span>        <span class="token operator">*</span>buf2 <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        buf1<span class="token operator">++</span><span class="token punctuation">;</span>        buf2<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span>base<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">,</span> <span class="token keyword">int</span> width<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>cmp<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> e1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> e2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sz <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cmp</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>base<span class="token operator">+</span>j<span class="token operator">*</span>width<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>base<span class="token operator">+</span><span class="token punctuation">(</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>width<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/*                 * 冒泡排序此处省略。                 * void类型的指针无法进行指针加减操作，所以先将其转换成char*类型，然后通过函数传参传入待排序数组中元素的size(即width，单位字节)，                 * 然后通过 base + j*width 进行地址操作，保证每次操作都能够跳跃一个元素。                 * */</span>                <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>base<span class="token operator">+</span>j<span class="token operator">*</span>width<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>base<span class="token operator">+</span><span class="token punctuation">(</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>width<span class="token punctuation">,</span> width<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">CmpPersonAge</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> e1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> e2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> person<span class="token operator">*</span><span class="token punctuation">)</span>e1<span class="token punctuation">)</span><span class="token operator">-></span>age<span class="token operator">-</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> person<span class="token operator">*</span><span class="token punctuation">)</span>e2<span class="token punctuation">)</span><span class="token operator">-></span>age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">CmpPersonName</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> e1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> e2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> person<span class="token operator">*</span><span class="token punctuation">)</span>e1<span class="token punctuation">)</span><span class="token operator">-></span>name<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> person<span class="token operator">*</span><span class="token punctuation">)</span>e2<span class="token punctuation">)</span><span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">cmp_int</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> e1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> e2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>e1 <span class="token operator">-</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>e2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> person p<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"lisi"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"duwei"</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> person<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> width <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> person<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">bubble_sort</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>sz<span class="token punctuation">,</span>width<span class="token punctuation">,</span>CmpPersonAge<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s "</span><span class="token punctuation">,</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">bubble_sort</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp_int<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4、练习题"><a href="#4、练习题" class="headerlink" title="4、练习题"></a>4、练习题</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*     * 针对64位操作系统     * 1. sizeof(数组名) - 数组名表示整个数组     * 2. &amp;数组名 - 数组名表示整个数组     * */</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 16 表示计算数组的大小(特殊)</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8 表示数组a中第一个元素的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 4 表示数组中的第一个元素的值</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8 表示数组a中第二个元素的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 4 表示数组中第二个元素的值</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8 表示数组的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 16 *和&amp;抵消，a表示数组，在此表示计算数组的大小</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8 &amp;a是地址，地址加一还是地址且步长为被加地址的长度</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8 []的优先级比&amp;高，因此表示数组a第一个元素的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8 地址加1还是地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-------\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这种方式创建一个字符串，需要手动加上'\0'作为字符串结束符</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 6 计算数组的大小，而非字符串的长度</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 第一个字符的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 第一个字符的长度</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 第二个字符的长度</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8 表示数组的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8 跳过整个数组之后的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8 跳过第一个元素之后的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-------\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"strlen(arr)=%d\n"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 随机值，因为没有'\0'的位置不确定</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"strlen(arr+0)=%d\n"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>arr<span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 随机值</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"strlen(&amp;arr)=%d\n"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 随机值</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"strlen(&amp;arr+1)=%d\n"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 随机值</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"strlen(&amp;arr[0]+1)=%d\n"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 随机值</span>    <span class="token comment" spellcheck="true">// printf("strlen(*arr)=%d\n",strlen(*arr)); // error</span>    <span class="token comment" spellcheck="true">// printf("strlen(arr[1])=%d\n",strlen(arr[1])); // err</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> arr2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abcdef"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这种方式会自动在字符串末尾加上'\0'</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 7 还有个字符结束符 '\0'，所以数组实际长度为7</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr2<span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>arr2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-------\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 6</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>arr2<span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//6</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//6</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 随机值</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 5</span>    <span class="token comment" spellcheck="true">// printf("%d\n",strlen(*arr2)); // error,a[0]为a,a的阿斯卡码为97，strlen(97)报错</span>    <span class="token comment" spellcheck="true">// printf("%d\n",strlen(arr2[1])); // error,arr2[1]为b，b的阿斯卡码值为98，strlen(98)报错</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-------\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token string">"abcdef"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// char p[] = "abcdef";</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8 p是指针</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 字符串的第一个字符</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 等价于 *(p+0)</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-------\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 6</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 5</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 随机值</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 随机值</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 5</span>    <span class="token comment" spellcheck="true">// printf("%d\n",strlen(*p)); // error</span>    <span class="token comment" spellcheck="true">// printf("%d\n",strlen(p[0])); // error</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-------\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(a2)=%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 48</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(a2[0][0])=%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 4</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(a2[0]=%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// *(a2+0) = 16</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(a2[0]+1)=%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(*(a2[0]+1))=%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>a2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a2[0]表示第一个数组(元素个数为3的)，地址+1表示跳跃到下一个元素，所以表示a[0][1]=4</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(a2+1)=%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(*(a2+1)=%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>a2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表示第二个数组(元素个数为3的) 所以为16</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(&amp;a2[0]+1)=%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(*(&amp;a2[0]+1))=%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 16</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(*a2)=%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>a2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 16</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(a2[3])=%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 16</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="5、易错题"><a href="#5、易错题" class="headerlink" title="5、易错题"></a>5、易错题</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d,%d\n"</span><span class="token punctuation">,</span><span class="token operator">*</span><span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*    (&amp;a+1)表示跳跃一个数组的长度，也就是元素5后的第一个内存地址，再将其转换成int*指针。     *(a+1)等价于a[1]，结果为2；*(ptr-1)，ptr是元素5后的地址，其类型为int*，在对其进行指针操作的时候其步长为4，所以在-1时会将其内存地址往前移四个字节也就是元素5的地址，所以结果为5.     _______________________    | 1 | 2 | 3 | 4 | 5 |ptr|     */</span><span class="token punctuation">}</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> Test<span class="token punctuation">{</span>    <span class="token keyword">int</span> Num<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>pcName<span class="token punctuation">;</span>    <span class="token keyword">short</span> sDate<span class="token punctuation">;</span>    <span class="token keyword">char</span> cha<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">short</span> sBa<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* * 假设p的值为0x100000 * 已知，结构体Test类型的变量大小是20字节 * */</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> Test<span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x100000</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span>p<span class="token operator">+</span><span class="token number">0x1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0x100014</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>p <span class="token operator">+</span> <span class="token number">0x1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0x100001, 0x100000转换成10进制为1048576，再+1位1048577，因为打印的是%p，所有会将其显示为16进制，结果为0x100001</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>p <span class="token operator">+</span> <span class="token number">0x1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0x100004</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*     * 小端存储     * */</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>ptr1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>ptr2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>a <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x\n"</span><span class="token punctuation">,</span>ptr1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0x4</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x\n"</span><span class="token punctuation">,</span><span class="token operator">*</span>ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2000000</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*     * a数组的内存分部如下：     * |01 00 00 00|02 00 00 00|03 00 00 00|04 00 00 00|     * int(a)+1表示指向a地址的后一个字节(01后的那个位置也就是00)，然后再转换成int*类型，解引用ptr2时会往后读取四个字节即：00 00 00 02     * 因为是小端存储，所以结果为 02000000     * */</span><span class="token punctuation">}</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p,%d\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>p<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>p<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="/image/image-20201017173549428.png" alt="image-20201017173549428"></p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> aa<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>aa<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>ptr2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>aa<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// *(aa+1) 等价于 aa[1]也就是第二个数组的数组名</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d,%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>ptr2<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 10,5</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"work"</span><span class="token punctuation">,</span><span class="token string">"at"</span><span class="token punctuation">,</span><span class="token string">"alibaba"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span>pa <span class="token operator">=</span> a<span class="token punctuation">;</span>    pa<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span><span class="token operator">*</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*     * a是一个指针数组，数组有三个char*类型的指针，将a赋值给char**pa，pa还是一个指针     * 指针+1会根据自己的类型来决定步长，而pa的类型就是一个指针，所以步长为8字节(64位操作系统)，     * pa也就是a，再加上八个字节，指向了a数组中的第二个元素。所以打印结果为at     * */</span><span class="token punctuation">}</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>c<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"ENTER"</span><span class="token punctuation">,</span> <span class="token string">"NEW"</span><span class="token punctuation">,</span> <span class="token string">"POINT"</span><span class="token punctuation">,</span> <span class="token string">"FIRST"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span>cp<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>c<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">,</span>c<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>c<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>cpp <span class="token operator">=</span> cp<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">++</span>cpp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// POINT</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span><span class="token operator">*</span><span class="token operator">--</span><span class="token operator">*</span><span class="token operator">++</span>cpp <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ER</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span><span class="token operator">*</span>cpp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// cpp[-2] 等价于 *(cpp-2),所以得到 **(cpp-2) + 3 ,结果ST</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>cpp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// *(*(cpp-1)-1) + 1  ,结果EW</span><span class="token punctuation">}</span></code></pre><p><img src="/image/image-20201019170726316.png" alt="image-20201019170726316"></p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property">#<span class="token directive keyword">define</span> OFFSETOF(struct_name, member_name) (int)&amp;(((struct_name*)0)->member_name)</span><span class="token keyword">struct</span> S<span class="token punctuation">{</span>    <span class="token keyword">char</span> c1<span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">char</span> c2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">OFFSETOF</span><span class="token punctuation">(</span><span class="token keyword">struct</span> S<span class="token punctuation">,</span>c1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">OFFSETOF</span><span class="token punctuation">(</span><span class="token keyword">struct</span> S<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">OFFSETOF</span><span class="token punctuation">(</span><span class="token keyword">struct</span> S<span class="token punctuation">,</span>c2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//预处理之后:</span><span class="token comment" spellcheck="true">/*struct S{ char c1; int a; char c2;};int main(){ printf("%d\n",sizeof(struct S)); printf("%d\n",(int)&amp;(((struct S*)0)->c1)); printf("%d\n",(int)&amp;(((struct S*)0)->a)); printf("%d\n",(int)&amp;(((struct S*)0)->c2)); return 0;}*/</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jenkins结合rsync同步代码</title>
      <link href="2021/03/18/jenkins%E7%BB%93%E5%90%88rsync%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81/"/>
      <url>2021/03/18/jenkins%E7%BB%93%E5%90%88rsync%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>背景：之前发布代码一直使用的一个jenkins插件 Publish over SSH，如果是java语言不存在问题，每次只拷贝一个jar包，但是如果是前端或者php这种类型的代码会存在问题：假如在gitlab仓库删除一个文件，jenkins拉取更新再通过Publish over SSH推送到服务器。这个过程中在gitlab仓库被删除的文件在远端服务器上是不会被删除的，因为Publish over SSH只会做增量更新。如果代码经常添加删除文件，那么远程机器上的代码文件就会越堆越多。</p></blockquote><h6 id="web机器："><a href="#web机器：" class="headerlink" title="web机器："></a>web机器：</h6><p>安装rsync</p><pre class=" language-shell"><code class="language-shell">[root@yanxiang_test webapp]# cat /etc/rsyncd.conf# /etc/rsyncd: configuration file for rsync daemon mode#同步过来后文件的主组uid = nginx gid = nginxuse chroot = yesmax connections = 200timeout = 300pid file = /var/run/rsyncd.pidlock file = /var/run/rsync.locklog file = /var/log/rsyncd.logignore errorsread only = falselist = falsehosts allow = *hosts deny =10.0.8.9#要在本机创建的用户auth users = ysg#内容格式为 user:passwd#文件权限600secrets file = /etc/rsync.password#同步到本机的目录[webapp]path = /var/webapp/[root@yanxiang_test webapp]# cat /etc/rsync.passwordysg:123456xxx[root@yanxiang_test webapp]#</code></pre><h6 id="jenkins机器："><a href="#jenkins机器：" class="headerlink" title="jenkins机器："></a>jenkins机器：</h6><p>安装rsync</p><pre class=" language-shell"><code class="language-shell">[root@izbp1gldj1nzq5934tk5czz ~]# cat /etc/rsync.password#文件权限600#只需要存储密码就行了，和web机器的密码一样123456xxx[root@izbp1gldj1nzq5934tk5czz ~]# rsync -rltDqzp --no-o --no-g  --delete /root/.jenkins/workspace/go_script ysg@172.16.72.173::webapp --exclude ".git"    --password-file=/etc/rsync.password#参数解释# -r 递归# -l 复制符号链接为符号链接# -t 保留修改时间# --no-o --no-g 不改变主组# --delete 删除差异文件# /root/.jenkins/workspace/go_script 同步目录# --exclude ".git" 需要排除的目录或者文件，多个--exclude指定多个目录或文件# --password-file ysg用户和远程机器认证的密码</code></pre><p>jenkins上的配置：</p><p><img src="/image/image-20201110131652289.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkinsfile</title>
      <link href="2021/03/18/Jenkinsfile/"/>
      <url>2021/03/18/Jenkinsfile/</url>
      
        <content type="html"><![CDATA[<pre class=" language-java"><code class="language-java">pipeline <span class="token punctuation">{</span>    agent any <span class="token comment" spellcheck="true">//agent指令是必须的，它为jenkins流水线分配一个执行器和工作区</span>    stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Build'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Building..'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Test'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Testing..'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Deploy'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Deploying....'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Deploy'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            when <span class="token punctuation">{</span>              expression <span class="token punctuation">{</span>                currentBuild<span class="token punctuation">.</span>result <span class="token operator">==</span> null <span class="token operator">||</span> currentBuild<span class="token punctuation">.</span>result <span class="token operator">==</span> <span class="token string">'SUCCESS'</span>               <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            steps <span class="token punctuation">{</span>                sh <span class="token string">'make publish'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>jenkinsfile支持使用单引号和双引号声明一个字符，但是只有双引号的字符串才支持$符的字符串插入值。</p><pre class=" language-java"><code class="language-java">def singlyQuoted <span class="token operator">=</span> <span class="token string">'Hello'</span>def doublyQuoted <span class="token operator">=</span> <span class="token string">"World"</span>def username <span class="token operator">=</span> <span class="token string">'Jenkins'</span>echo <span class="token string">'Hello Mr. ${username}'</span>echo <span class="token string">"I said, Hello Mr. ${username}"</span>执行结果为：Hello Mr<span class="token punctuation">.</span> $<span class="token punctuation">{</span>username<span class="token punctuation">}</span>I said<span class="token punctuation">,</span> Hello Mr<span class="token punctuation">.</span> Jenkins</code></pre><p>使用环境变量</p><p>第一种是jenkins自带的全局变量：BUILD_ID、BUILD_URL、BUILD_TAG等</p><pre class=" language-java"><code class="language-java">pipeline <span class="token punctuation">{</span>    agent any    stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">"Running ${env.BUILD_ID} on ${env.JENKINS_URL}"</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>第二种是自定义的环境变量</p><pre class=" language-java"><code class="language-java">pipeline <span class="token punctuation">{</span>    agent any    environment <span class="token punctuation">{</span>         CC <span class="token operator">=</span> <span class="token string">'clang'</span>    <span class="token punctuation">}</span>    stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            environment <span class="token punctuation">{</span>                 DEBUG_FLAGS <span class="token operator">=</span> <span class="token string">'-g'</span>            <span class="token punctuation">}</span>            steps <span class="token punctuation">{</span>                sh <span class="token string">'printenv'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//用在最高层的 pipeline 块的 environment 指令适用于流水线的所有步骤。</span><span class="token comment" spellcheck="true">//定义在 stage 中的 environment 指令只适用于 stage 中的步骤。</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkinsfile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx小技巧</title>
      <link href="2021/03/18/Nginx%E6%97%A5%E5%BF%97%E8%8E%B7%E5%8F%96header/"/>
      <url>2021/03/18/Nginx%E6%97%A5%E5%BF%97%E8%8E%B7%E5%8F%96header/</url>
      
        <content type="html"><![CDATA[<h5 id="获取请求header"><a href="#获取请求header" class="headerlink" title="获取请求header"></a>获取请求header</h5><p>对于一个发送给nginx的请求，如果在想要在nginx日志中记录header信息，可以使用 将 $http_HeaderName 配置到日志格式即log_format中。</p><pre class=" language-conf"><code class="language-conf">log_format headd escape=json '[$time_local] $remote_addr $status $body_bytes_sent $request_time $host $request_method $server_protocol [$http_referer] [$request_body] [$http_user_agent] [$request_uri] "content_type": "$http_content_type" "androidid": "$http_androidid" "appsystem": "$http_appsystem" "brand": "$http_brand" "brandname":"http_brandname" "imei":"$http_imei" "key": "$http_key" "language": "$http_language" "mac":"$http_mac" "manufacturer": "$http_manufacturer" "model": "$http_model" "modelname": "$http_modelname" "os": "$http_os" "osType": "$http_osType" "osVersionCode": "$http_osVersionCode" "osVersionName": "$http_osVersionName" "platformVersionCode": "$http_platformVersionCode" "platformVersionName": "$http_platformVersionName" "product": "$http_product"';</code></pre><h5 id="request-body为json格式存储日志"><a href="#request-body为json格式存储日志" class="headerlink" title="request_body为json格式存储日志"></a>request_body为json格式存储日志</h5><p>如果不进行特殊配置，request_body中的内容：</p><pre class=" language-log"><code class="language-log">{\x22username\x22:\x22xiaoli\x22,\x22age\x22:12}</code></pre><p>需要对日志格式进行配置：</p><pre class=" language-conf"><code class="language-conf">log_format main2 escape=none '$request_body';</code></pre><p>配置之后：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"username"</span><span class="token operator">:</span><span class="token string">"xiaoli"</span><span class="token punctuation">,</span><span class="token property">"age"</span><span class="token operator">:</span><span class="token number">12</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程</title>
      <link href="2021/03/18/%E8%BF%9B%E7%A8%8B/"/>
      <url>2021/03/18/%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>定义：进程是程序执行时的一个实例。从内核角度来看：进程是承担操作系统所分配的资源(cpu时间、内存等)的实体。</p><h4 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h4><h5 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h5><ol><li><p>可运行状态（TASK_RUNNING）</p><p>进程要么在cpu上执行，要么准备执行</p></li><li><p>可中断等待状态（TASK_INTERRUPTIBLE）</p><p>进程被挂起（睡眠），直到某个条件变为真。硬件中断、传递一个信号都可以作为唤醒条件。</p></li><li><p>不可中断等待状态（TASK_UNINTERRUPTIBLE）</p><p>与可中断等待状态类似，但是存在一个例外：把信号传递到睡眠进程无法修改它的状态。</p></li><li><p>暂停状态（TASK_STOPPED）</p><p>进程的执行被暂停。当进程收到SIGSTOP、SIGTSTP、SOGTTIN、SIGTTOU等信号后进入暂停状态。</p></li><li><p>跟踪状态（TASK_TRACED）</p></li><li><p>僵死状态（EXIT_ZOMBIE）</p><p>也成僵尸状态。进程执行已终止，但是由于父进程并未调用wait或waitpid系统调用来收集死亡进程的相关信息，内核不能丢弃包含在死进程描述符中的数据，因为父进程可能还会用到。</p></li><li><p>僵死撤销状态（EXIT_DEAD）</p><p>进程的最终状态。父进程调用wait或waitpid等系统调用收集死进程的信息之后，由操作系统删除死进程的数据且释放死进程的相关资源。</p></li></ol><h5 id="进程链表（双向链表）"><a href="#进程链表（双向链表）" class="headerlink" title="进程链表（双向链表）"></a>进程链表（双向链表）</h5><p>进程链表把所有的进程描述符链接起来。每个task_struct结构都包含一个list_head类型的tasks字段，这个类型的prev和next字段分别指向前面和后面的task_struct元素。</p><p>进程链表的头是init_task，即0号进程。</p><p><img src="https://img.3amupupup.online/task_struct-list.png" alt="进程链表"></p><h5 id="TASK-RUNNING状态的进程链表"><a href="#TASK-RUNNING状态的进程链表" class="headerlink" title="TASK_RUNNING状态的进程链表"></a>TASK_RUNNING状态的进程链表</h5><p>当内核寻找一个新进程在CPU上运行时，必须只考虑可运行进程（TASK_RUNNING状态的进程）。</p><p>提高调度程序运行速度的诀窍时建立多个可运行进程链表，每种进程优先级对应一个不同的链表。</p><h5 id="进程资源限制"><a href="#进程资源限制" class="headerlink" title="进程资源限制"></a>进程资源限制</h5><p>每个进程都有一组相关的资源限制，限制指定了进程能够使用的系统资源数量。这些限制避免用户过度使用系统资源。</p><ul><li>RLIMIT_AS：进程地址空间的最大数（字节为单位）。当进程使用malloc或者相关函数扩大它的进程空间时，内核会检查这个值。</li><li>RLIMIT_CPU：进程使用cpu的最长时间（秒为单位），如果进程超过了这个限制，内核就向它发送一个SIGXCPU信号，如果不终止，则发送SIGKILL信号。</li><li>RLIMIT_DATA：堆大小的最大值。</li><li>RLIMIT_RSS：进程能够拥有的虚拟内存页的最大数量。</li><li>RLIMIT_STACK：进程栈的最大值。</li></ul><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p>为了控制进程的执行，内核必须有能力挂起正在cpu上执行的进程，并恢复以前挂起的某个进程的执行。</p><h5 id="硬件上下文"><a href="#硬件上下文" class="headerlink" title="硬件上下文"></a>硬件上下文</h5><p>每个进程拥有自己的地址空间，但是所有进程必须共享CPU寄存器。因此，在恢复一个进程执行之前，内核必须确保每个寄存器装入了挂起进程时的值。</p><p><strong>进程恢复执行前必须装入寄存器的一组数据称为硬件上下文</strong>。</p><p>进程切换只发生在内核态。在执行切换之前，用户态进程使用的所有寄存器内容都已保存在内核态堆栈上。</p><h5 id="任务状态段（Task-Stat-Segment：TSS）"><a href="#任务状态段（Task-Stat-Segment：TSS）" class="headerlink" title="任务状态段（Task Stat Segment：TSS）"></a>任务状态段（Task Stat Segment：TSS）</h5><p>用来存放硬件上下文。</p><blockquote><p>任务切换(硬切换)需要用到TSS来保存全部寄存器(2.4以前使用jmp来实现切换)，中断发生时也需要从TSS中读取ring0的esp0，那么，进程使用相同的TSS，任务切换怎么办？ 其实2.4以后不再使用硬切换，而是使用软切换，寄存器不再保存在TSS中了，而是保存在task-&gt;thread中，只用TSS的esp0和IO许可位图，所以，在进程切换过程中，只需要更新TSS中的esp0(内核态栈顶指针)、io bitmap。</p></blockquote><h5 id="thread字段"><a href="#thread字段" class="headerlink" title="thread字段"></a>thread字段</h5><p>每次硬件上下文切换时，被替换进程的上下文必须保存在别处。因为linux为每个处理器而不是每个进程使用tss。</p><p>因此每个进程描述符(task_struct)包含一个类型为thread_struct的thread字段，只要进程被切换出去，内核就把其硬件上下文保存在这个结构中。</p><h5 id="执行进程切换"><a href="#执行进程切换" class="headerlink" title="执行进程切换"></a>执行进程切换</h5><p>暂时略</p><h4 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h4><p>传统的unix操作系统：子进程复制父进程所拥有的的资源。效率低下，因为子进程要复制父进程的整个地址空间，且子进程几乎不必读和修改父进程所拥有的所有资源。</p><p>现代unix解决办法：</p><ul><li>写时复制。允许父子进程读相同的物理页，只要二者中有一个试图写一个物理页，内核就把这个页拷贝到另一个物理页，并将这个新的物理页分配给试图写的这个进程。</li><li>轻量级进程允许父子进程共享进程在内核的很多数据结构，如页表、打开的文件表等。</li><li>vfork()系统调用创建的进程能其父进程的内存地址空间。</li></ul><h4 id="fork"><a href="#fork" class="headerlink" title="fork:"></a>fork:</h4><p>fork()函数man手册：</p><ul><li>fork函数通过调用它的进程复制出一个新的进程(谁调用它复制谁，准确说是共享（比如代码段），对于私有数据采用写时复制机制)。</li><li>子进程的父进程id与父进程相同</li><li>子进程不继承父进程的内存锁</li><li>子进程的资源利用率和cpu使用时间计数会被置0。</li><li>子进程信号集为空(进程运行过程中收到的信号都会保存在一个集合中)。</li><li>子进程不继承父进程的信号量(引自百度百科：<a href="https://baike.baidu.com/item/信号量/9807501" target="_blank" rel="noopener">信号量</a>的值与相应资源的使用情况有关，当它的值大于 0 时，表示当前可用的资源数的数量；当它的值小于 0 时，其绝对值表示等待使用该资源的进程个数。信号量的值仅能由 PV 操作来改变。)</li><li>子进程不继承父进程的记录锁(The child does not inherit record locks from its parent (fcntl(2)))</li><li>子进程不继承父进程的计时器。</li></ul><p>fork调用的一个奇妙之处就是它仅仅被调用一次但是返回两次：</p><p><img src="http://img.3amupupup.online/do_fork.png" alt="do_fork"></p><p>为什么能返回两次：父进程创建子进程时，子进程共享父进程上下文，其中上下文包含程序计数器，它里面存储的是程序要执行的下一条cpu指令。程序执行到return之前，子进程已完成创建，并且通过wake_up_new_task函数将子进程添加到可调度队列中去了，此时子进程共享父进程的程序计数器，它们的程序计数器里的指令都指向tracehook_report_clone_complete函数，因此当子进程拿到cpu时，会从tracehook_report_clone_complete开始执行直至return。因此调用fork函数会有两次返回，一次是父进程中另一次是在子进程中。</p><p>函数，当子进程拿到cpu时，会执行程序计数器中的指令即return，所以fork函数会返回两次，一次是在父进程中，一次是在子进程中)。</p><p>它可能有三种不同的返回值：</p><ol><li>在父进程中，fork()返回新创建的子进程的pid。</li><li>在子进程中，fork()返回0。</li><li>如果fork()出现错误，返回一个负值。</li></ol><p>在fork函数执行完毕之后，如果创建进程成功，则出现两个进程，一个是子进程一个是父进程。在父进程中返回新创建子进程的pid，在子进程中返回0，可以通过fork返回值判断当前进程是父进程还是子进程。</p><p>另外根据程序的输出信息：父进程中的age结果为-1，子进程中的age为1，但是age的地址在父子进程中相同。父进程和子进程共享内存，但是不共享私有数据，使用了写时复制的机制。但是pid不同(现阶段认知)。内存地址相同但是值却不相同，这里需要学习一下操作系统-虚拟内存。这里解释下：虽然父子进程中的age的内存地址相同，但是他们彼此独立不可见，虚拟内存地址相同但是它们各自对应的物理地址不相同。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pid<span class="token punctuation">;</span>    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fork() error.\n)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        age<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am child and my pid = %d, age = %d, addr = %p\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>age<span class="token punctuation">,</span><span class="token operator">&amp;</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        age<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am parent and my Pid=%d, age = %d, addr = %p\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>age<span class="token punctuation">,</span><span class="token operator">&amp;</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 编译执行结果：</span><span class="token comment" spellcheck="true">// I am parent and my Pid=13086, age = -1, addr = 0x7fffc4e4dc98</span><span class="token comment" spellcheck="true">// I am child and my pid = 13087, age = 1, addr = 0x7fffc4e4dc98</span></code></pre><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><h4 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h4><p>pid_t waitpid(pid_t pid, int *statusp, int options);</p><p>当options=0时，waitpid挂起调用进程的执行，直到它的等待集合中的一个进程终止；如果这个集合中的一个进程在刚调用的时刻就已经终止，那么waitpid立即返回。</p><ol><li><p>判定等待集合的成员</p><p>等待集合的成员是由 pid 参数决定的：</p><ol><li>pid &gt; 0 ，等待的集合就是一个单独的子进程，它的进程id等于pid。</li><li>pid = -1，那么等待就是父进程的所有子进程组成的集合中的任意子进程。</li><li>pid &lt; -1，回收进程组id为abs(pid)的一组进程，也就是所有子进程。</li><li>pid = 0，回收 与调用进程组id相同组内的子进程。</li></ol></li><li><p>修改默认行为</p><ul><li><p>0</p><p>与wait基本没有区别。</p></li><li><p>WNOHANG</p><p>如果等待集合中的任何子进程都没有终止，那么立即返回(返回值为0)，如果有子进程退出返回退出子进程的pid，失败返回-1(没有子进程或者子进程死光了)。在等待子进程终止的同时如果想做其它事情，这个选项很有用。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> status<span class="token punctuation">;</span>    <span class="token keyword">int</span> pid<span class="token punctuation">;</span>    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I'm child.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>status<span class="token punctuation">,</span>WNOHANG<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child exit.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I'm parent.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用 WNOHANG 父进程不会等待自己成退出，所以执行效果是: 父进程、子进程执行各自的代码，父进程执行完毕之后退出，因为子进程sleep(3)，所以子进程在输出打印之后三秒钟退出。</span></code></pre></li><li><p>WUNTRACED</p><p>挂起调动进程的执行，直到等待集合中的一个进程变成已终止或者停止。返回的pid为导致返回的已终止或被停止子进程的pid。默认的行为是只返回已终止子进程。在想要检查已终止或已停止的子进程时，这个选项比较有用。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> status<span class="token punctuation">;</span>    <span class="token keyword">int</span> pid<span class="token punctuation">;</span>    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child run and pid = %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I'm child.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>status<span class="token punctuation">,</span>WUNTRACED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child exit who pid = %d.\n"</span><span class="token punctuation">,</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I'm parent.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// root$ ./a.out</span><span class="token comment" spellcheck="true">// child run and pid = 26334</span><span class="token comment" spellcheck="true">// I'm child.</span><span class="token comment" spellcheck="true">// child exit who pid = 26334.</span><span class="token comment" spellcheck="true">// I'm parent.</span></code></pre></li><li><p>WCONTINUED</p><p>挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或者等待集合中一个被停止的进程收到SIGCONT信号重新开始执行。</p></li><li><p>组合使用：WNOHANG | WUNTRACED</p><p>立即返回，如果等待集合中的子进程都没有停止或者终止则返回0，如果有一个停止或者终止则返回该子进程的pid。</p></li></ul></li><li><p>检查已回收子进程的退出状态</p><p><img src="http://img.3amupupup.online/childProcessStatus.png" alt="waitpid() status参数"></p><p>如果statusp参数是非空的，那么操作系统就会读取进程的PCB，保存在status指向的变量中。</p><p>status中保存的就是进程退出的信息，int是32bit，是否正常运行，退出码是多少，退出信号是多少。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    pid_t id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork error!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// child</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i am child process\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sleep 1\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//        int ret = 1/0;</span><span class="token comment" spellcheck="true">//        exit(99);</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// parent</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"father wait before.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pid_t ret <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span><span class="token operator">&amp;</span>status<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"status = %d\n"</span><span class="token punctuation">,</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保存子进程的返回状态</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"子进程终止信号: %d\n"</span><span class="token punctuation">,</span> status <span class="token operator">&amp;</span> <span class="token number">0x7f</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 利用位运算&amp;来获取status低7位的值，0 表示是正常退出</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"子进程退出码: %d\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span>status <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 也是利用的位运算，将status右移八位，再获取其低8位上的值</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wait success!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>status <span class="token operator">&amp;</span> <span class="token number">0x7f</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 非0则说明子进程不是正常退出的</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child run error!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>status<span class="token operator">>></span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 运行成功但是结果不正确</span>            <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child run success, but result is not right, exit code: %d\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span>status<span class="token operator">>></span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child run success and result is right,exit code: %d\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span>status<span class="token operator">>></span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wait failed!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"father wait after.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="http://img.3amupupup.online/WaitpidStatus.png" alt="image-20210202163458393"></p><p>图中在子进程sleep的时候给其发送了一个SIGSTOP信号导致子进程退出，status中保存的是子进程终止的状态信息。</p><p>标准库中也提供一些宏函数来检测进程的退出状态：</p><ol><li><p>WIFEXITED(status): 如果为正常子进程终止子进程的返回状态，则为真。(查看子进程是否正常退出：! (status &amp; 0x7f))</p></li><li><p>WEXITSTATUS(status): 如果WIFEXITED(status)为非零，提取子进程退出码。(查看子进程退出码: (status&gt;&gt;8)&amp;0xff))</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    pid_t id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork error!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// child</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i am child process\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sleep 1\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// parent</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"father wait before.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pid_t ret <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span><span class="token operator">&amp;</span>status<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"status = %d\n"</span><span class="token punctuation">,</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保存子进程的返回状态</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 为真说明是正常退出的</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child exit code: %d\n"</span><span class="token punctuation">,</span><span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child exit error!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"father wait after.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre></li></ol></li></ol><h4 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h4><h5 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h5><p>如果写端不关闭文件描述符且不写入，读端可能需要长时间阻塞。（读取完管道中的历史数据后阻塞）</p><p>如果读端写端条件不成熟，会阻塞。</p><p>如果写端关闭文件描述符，读端读完管道的数据之后会读到文件结尾(‘\0’)。</p><p>如果读端关闭，写端会被进程kill掉。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> fd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">pipe</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open pipe failed.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    size_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// child,write</span>        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello duwei1996\n"</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child say: hello duwei1996\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">++</span> <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// parent,read</span>        <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            ssize_t len <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"parent get %lu bytes.\n"</span><span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>len <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                buf<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"parent get: %s"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>管道大小</p><ul><li><pre class=" language-shell"><code class="language-shell">[root@iZbp11u8qxiwepq15dm1liZ ComputerSystem]# ulimit -acore file size          (blocks, -c) 0data seg size           (kbytes, -d) unlimitedscheduling priority             (-e) 0file size               (blocks, -f) unlimitedpending signals                 (-i) 6946max locked memory       (kbytes, -l) 64max memory size         (kbytes, -m) unlimitedopen files                      (-n) 65535pipe size            (512 bytes, -p) 8POSIX message queues     (bytes, -q) 819200real-time priority              (-r) 0stack size              (kbytes, -s) 8192cpu time               (seconds, -t) unlimitedmax user processes              (-u) 6946virtual memory          (kbytes, -v) unlimitedfile locks                      (-x) unlimited</code></pre><p>可以看到在linux系统上pipe size 为512bytes * 8 = 4096bytes。</p></li></ul><p>特点：</p><ul><li>只能用于有血缘关系的进程之间进行通信</li><li>管道提供流式服务</li><li>数据只能向一个方向流动，只能单向通信(半双工通信)，如果需要双向通信需要创建两个管道</li><li>一般而言，进程退出，管道释放，管道的声明周期随进程</li><li>一般而言，内核会对管道操作进行同步与互斥</li></ul><h5 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h5><p>命名管道，实现无血缘关系进程通信。</p><ul><li><p>创建一个管道的伪文件</p><ul><li>int mkfifo(const char *pathname, mode_t mode);</li><li>mkfifo fifoName 命令创建</li></ul></li><li><p>内核会给fifo文件开辟一个缓冲区，操作fifo文件，可以操作缓冲区，实现进程通信–实际上就是文件读写</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> FIFO "/root/ComputerSystem/myfifo" </span><span class="token comment" spellcheck="true">// shell: mkfifo myfifo</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>FIFO<span class="token punctuation">,</span>O_WRONLY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果没有程序 read，open会阻塞</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>       <span class="token punctuation">{</span>        <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token string">"hello%d"</span><span class="token punctuation">,</span>num<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//  若无读端写端open阻塞</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"myfifo"</span><span class="token punctuation">,</span>O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>       <span class="token punctuation">{</span>        <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read:%s\n"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//  若无写端读端阻塞，有点类似golang里的无缓冲channel</span></code></pre><p>linux系统上通过命令：man 7 signal 查看信号的手册</p><p><img src="http://img.3amupupup.online/SignalAction.png" alt="signal"></p><p><img src="http://img.3amupupup.online/fifo.png" alt="fifo"></p><p>若读端关闭，写端也会终止。至于为什么会关闭，如下解释：</p><p>执行写端程序时，open函数打开管道文件 myfifo，由于没有读端，所以写端会阻塞住。当执行读端程序之后 open停止阻塞 继续向下执行开始往管道里写数据。当关闭读端时，操作系统发送 sigpipe 信号给写端。由图可知 sigpipe 是一个Term(terminate)信号，所以写端程序终止退出。</p></li></ul><h5 id="shm"><a href="#shm" class="headerlink" title="shm"></a>shm</h5><ol><li><p>server</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/ipc.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"comm.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    key_t key <span class="token operator">=</span> <span class="token function">ftok</span><span class="token punctuation">(</span>PATHNAME<span class="token punctuation">,</span> PROJ_ID<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将PATHNAME和PROJ_ID作为信息源，生成一个唯一的key值(在系统中保证唯一)</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"key = %X\n"</span><span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> shmid <span class="token operator">=</span> <span class="token function">shmget</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> SIZE<span class="token punctuation">,</span> IPC_CREAT <span class="token operator">|</span> IPC_EXCL <span class="token operator">|</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 生命周期跟随操作系统，申请之后要释放</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>shmid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"shmget failed.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shmid = %d\n"</span><span class="token punctuation">,</span>shmid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token function">shmat</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 关联共享内存</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"msg: %s\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">shmdt</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I will rm ipc source right now, shmid = %d\n"</span><span class="token punctuation">,</span>shmid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">shmctl</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span> IPC_RMID<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>client</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/ipc.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"comm.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    key_t key <span class="token operator">=</span> <span class="token function">ftok</span><span class="token punctuation">(</span>PATHNAME<span class="token punctuation">,</span> PROJ_ID<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"key = %X\n"</span><span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> shmid <span class="token operator">=</span> <span class="token function">shmget</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> SIZE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>shmid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"shmget failed.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shmid = %d\n"</span><span class="token punctuation">,</span>shmid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token function">shmat</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 关联共享内存</span>    <span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 操作系统不提供同步与互斥</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> c <span class="token operator">&lt;=</span> <span class="token string">'z'</span><span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        str<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">shmdt</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>ipcs -m; ipcrm -m id</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx数组</title>
      <link href="2021/03/17/ngx_array/"/>
      <url>2021/03/17/ngx_array/</url>
      
        <content type="html"><![CDATA[<h4 id="nginx数据类型：数组"><a href="#nginx数据类型：数组" class="headerlink" title="nginx数据类型：数组"></a>nginx数据类型：数组</h4><p><img src="https://img.3amupupup.online/ngx_array_2.png" alt="ngx_array"></p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span>        <span class="token operator">*</span>elts<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 指向第一个元素的指针</span>    ngx_uint_t   nelts<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 未使用的元素的索引</span>    size_t       size<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 每个元素大小</span>    ngx_uint_t   nalloc<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  元素个数</span>    ngx_pool_t  <span class="token operator">*</span>pool<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//  指向内存池的指针</span><span class="token punctuation">}</span> ngx_array_t<span class="token punctuation">;</span></code></pre><h5 id="数组提供的接口"><a href="#数组提供的接口" class="headerlink" title="数组提供的接口"></a>数组提供的接口</h5><pre class=" language-c"><code class="language-c">ngx_array_t <span class="token operator">*</span><span class="token function">ngx_array_create</span><span class="token punctuation">(</span>ngx_pool_t <span class="token operator">*</span>p<span class="token punctuation">,</span> ngx_uint_t n<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建数组的数据结构</span><span class="token keyword">void</span> <span class="token function">ngx_array_destroy</span><span class="token punctuation">(</span>ngx_array_t <span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 销毁数组</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">ngx_array_push</span><span class="token punctuation">(</span>ngx_array_t <span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// push单个元素</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">ngx_array_push_n</span><span class="token punctuation">(</span>ngx_array_t <span class="token operator">*</span>a<span class="token punctuation">,</span> ngx_uint_t n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// push n个元素</span><span class="token keyword">static</span> ngx_inline ngx_int_t <span class="token function">ngx_array_init</span><span class="token punctuation">(</span>ngx_array_t <span class="token operator">*</span>array<span class="token punctuation">,</span> ngx_pool_t <span class="token operator">*</span>pool<span class="token punctuation">,</span> ngx_uint_t n<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//  // ngx_array_create会调用此函数，申请之后调用这个函数进行初始化操作</span></code></pre><h5 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h5><ol><li><p>ngx_array_t *ngx_array_create(ngx_pool_t *p, ngx_uint_t n, size_t size): 创建数组</p><pre class=" language-c"><code class="language-c">ngx_array_t <span class="token operator">*</span><span class="token function">ngx_array_create</span><span class="token punctuation">(</span>ngx_pool_t <span class="token operator">*</span>p<span class="token punctuation">,</span> ngx_uint_t n<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_array_t <span class="token operator">*</span>a<span class="token punctuation">;</span>    a <span class="token operator">=</span> <span class="token function">ngx_palloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ngx_array_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          调用ngx_palloc在内存池上为ngx_array_t结构体(控制中心)申请内存(分配在内存池结点上的数据区---小数据块区)      */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_array_init</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> p<span class="token punctuation">,</span> n<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token operator">!=</span> NGX_OK<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">/*              上一步只是给数组的控制中心ngx_array_t在内存池上分配了内存，              ngx_array_init为数组分配数据区域并初始化ngx_array_t的成员，              分配ngx_array_t的内存和分配数据区内存的操作时分开的，              所以          */</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>ngx_inline ngx_int_t: 初始化数组，为数组类型分配数据区的内存</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> ngx_inline ngx_int_t<span class="token function">ngx_array_init</span><span class="token punctuation">(</span>ngx_array_t <span class="token operator">*</span>array<span class="token punctuation">,</span> ngx_pool_t <span class="token operator">*</span>pool<span class="token punctuation">,</span> ngx_uint_t n<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*     * set "array->nelts" before "array->elts", otherwise MSVC thinks     * that "array->nelts" may be used without having been initialized     */</span>    array<span class="token operator">-></span>nelts <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    array<span class="token operator">-></span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>    array<span class="token operator">-></span>nalloc <span class="token operator">=</span> n<span class="token punctuation">;</span>    array<span class="token operator">-></span>pool <span class="token operator">=</span> pool<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          初始化      */</span>    array<span class="token operator">-></span>elts <span class="token operator">=</span> <span class="token function">ngx_palloc</span><span class="token punctuation">(</span>pool<span class="token punctuation">,</span> n <span class="token operator">*</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          在内存吃上给数组的数据区分配内存，至于分配在large链表还是small链表需要根据数组大小决定      */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token operator">-></span>elts <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> NGX_OK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>void ngx_array_destroy(ngx_array_t *a): 销毁数组</p><p><img src="https://img.3amupupup.online/ngx_array_destroy_2.png" alt="ngx_array"></p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span><span class="token function">ngx_array_destroy</span><span class="token punctuation">(</span>ngx_array_t <span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*         在 ngx_array_create() 函数中 ngx_array_t结构的内存和数组的内存是分开申请的，不一定连续，         所以在将内存归还给内存池的时候也得分开归还     */</span>    ngx_pool_t  <span class="token operator">*</span>p<span class="token punctuation">;</span>    p <span class="token operator">=</span> a<span class="token operator">-></span>pool<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 内存池的地址是被保存在ngx数组数据结构中的</span>    <span class="token comment" spellcheck="true">/*         如果 数组首元素地址 + 元素大小*元素个数 == last的指向位置，         则说明这个数组的内存段是在used区域的尾部的，last直接减去 元素大小*元素个数 就代表销毁了这个数组的内存     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>u_char <span class="token operator">*</span><span class="token punctuation">)</span> a<span class="token operator">-></span>elts <span class="token operator">+</span> a<span class="token operator">-></span>size <span class="token operator">*</span> a<span class="token operator">-></span>nalloc <span class="token operator">==</span> p<span class="token operator">-></span>d<span class="token punctuation">.</span>last<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p<span class="token operator">-></span>d<span class="token punctuation">.</span>last <span class="token operator">-</span><span class="token operator">=</span> a<span class="token operator">-></span>size <span class="token operator">*</span> a<span class="token operator">-></span>nalloc<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*         销毁控制中心所在的内存，道理和上面类似     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>u_char <span class="token operator">*</span><span class="token punctuation">)</span> a <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ngx_array_t<span class="token punctuation">)</span> <span class="token operator">==</span> p<span class="token operator">-></span>d<span class="token punctuation">.</span>last<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p<span class="token operator">-></span>d<span class="token punctuation">.</span>last <span class="token operator">=</span> <span class="token punctuation">(</span>u_char <span class="token operator">*</span><span class="token punctuation">)</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*        走到这里就说明数组的控制中心的内存的末尾与数据区内存的末尾不等于last的指向，        它们末尾的位置到last位置之间的内存分配了给其它调用者，因此无法释放，请看图。        ①③是可以移动last将其归还给内存池的，②④不可以。    */</span><span class="token punctuation">}</span></code></pre></li><li><p>void *ngx_array_push(ngx_array_t *a): 向数组中添加单个元素</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">ngx_array_push</span><span class="token punctuation">(</span>ngx_array_t <span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">void</span>        <span class="token operator">*</span>elt<span class="token punctuation">,</span> <span class="token operator">*</span>new<span class="token punctuation">;</span>    size_t       size<span class="token punctuation">;</span>    ngx_pool_t  <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">-></span>nelts <span class="token operator">==</span> a<span class="token operator">-></span>nalloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* the array is full */</span>        size <span class="token operator">=</span> a<span class="token operator">-></span>size <span class="token operator">*</span> a<span class="token operator">-></span>nalloc<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/*              计算当前数组的大小          */</span>        p <span class="token operator">=</span> a<span class="token operator">-></span>pool<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>u_char <span class="token operator">*</span><span class="token punctuation">)</span> a<span class="token operator">-></span>elts <span class="token operator">+</span> size <span class="token operator">==</span> p<span class="token operator">-></span>d<span class="token punctuation">.</span>last            <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>d<span class="token punctuation">.</span>last <span class="token operator">+</span> a<span class="token operator">-></span>size <span class="token operator">&lt;=</span> p<span class="token operator">-></span>d<span class="token punctuation">.</span>end<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">/*            第一个条件：保证数组数据区所在的内存在内存池used区域的末尾，因为添加元素时要保证数组所有的元素            在内存上是连续的。            第二个条件：在数组数据区所在的内存池的小块数据区域有足够的内存容纳一个元素。        */</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/*             * the array allocation is the last in the pool             * and there is space for new allocation             */</span>            p<span class="token operator">-></span>d<span class="token punctuation">.</span>last <span class="token operator">+</span><span class="token operator">=</span> a<span class="token operator">-></span>size<span class="token punctuation">;</span>            a<span class="token operator">-></span>nalloc<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/*                否则就是不能保证内存连续或者空间不足，进行扩容            */</span>            <span class="token comment" spellcheck="true">/* allocate a new array */</span>            new <span class="token operator">=</span> <span class="token function">ngx_palloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">/*                  扩容的逻辑是二倍增长              */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>new <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// </span>            <span class="token function">ngx_memcpy</span><span class="token punctuation">(</span>new<span class="token punctuation">,</span> a<span class="token operator">-></span>elts<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// </span>            a<span class="token operator">-></span>elts <span class="token operator">=</span> new<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 指向新内存的位置</span>            a<span class="token operator">-></span>nalloc <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">/*                      #define ngx_memcpy(dst, src, n)   (void) memcpy(dst, src, n)                      将原来的内存地址上的数组部分的内容拷贝到新内存池上，                      elts指向新内存的位置，                      元素个数翻倍。              */</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 未使用的元素的下标</span>    elt <span class="token operator">=</span> <span class="token punctuation">(</span>u_char <span class="token operator">*</span><span class="token punctuation">)</span> a<span class="token operator">-></span>elts <span class="token operator">+</span> a<span class="token operator">-></span>size <span class="token operator">*</span> a<span class="token operator">-></span>nelts<span class="token punctuation">;</span>    a<span class="token operator">-></span>nelts<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*          走到这里你可能会有疑问：为什么之前数组的内存没有释放呢？          我来给你解答：能直接添加元素需要满足的条件：数组所在内存区域在used区域的末尾且last之后有足够的空间容纳             新元素，反过来说就是数组所在的内存区域不在used区域的末尾(数组的结束位置与last位置之间的内存被分配给了            其它调用者)，如果修改last的指向会导致被分配给其它调用者的内存归还给了内存池，再下一次分配时这一片内存                很可能再被分配出去，如果发生修改的操作会发生意外的结果。          所以之前数组数据区域的内存是不能归还给内存池的。      */</span>    <span class="token keyword">return</span> elt<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>void *ngx_array_push_n(ngx_array_t *a, ngx_uint_t n): 逻辑和ngx_array_push相似</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">ngx_array_push_n</span><span class="token punctuation">(</span>ngx_array_t <span class="token operator">*</span>a<span class="token punctuation">,</span> ngx_uint_t n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">void</span>        <span class="token operator">*</span>elt<span class="token punctuation">,</span> <span class="token operator">*</span>new<span class="token punctuation">;</span>    size_t       size<span class="token punctuation">;</span>    ngx_uint_t   nalloc<span class="token punctuation">;</span>    ngx_pool_t  <span class="token operator">*</span>p<span class="token punctuation">;</span>    size <span class="token operator">=</span> n <span class="token operator">*</span> a<span class="token operator">-></span>size<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">-></span>nelts <span class="token operator">+</span> n <span class="token operator">></span> a<span class="token operator">-></span>nalloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* the array is full */</span>        p <span class="token operator">=</span> a<span class="token operator">-></span>pool<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*         如果elts指向的位置加上当前数组的大小等于last 且 last到end之间有足够的空间去容纳n个元素，         则直接在这个内存池上添加元素，这个判定是要保证添加的元素所在的内存与之前数组的内存是连续的。         */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>u_char <span class="token operator">*</span><span class="token punctuation">)</span> a<span class="token operator">-></span>elts <span class="token operator">+</span> a<span class="token operator">-></span>size <span class="token operator">*</span> a<span class="token operator">-></span>nalloc <span class="token operator">==</span> p<span class="token operator">-></span>d<span class="token punctuation">.</span>last            <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>d<span class="token punctuation">.</span>last <span class="token operator">+</span> size <span class="token operator">&lt;=</span> p<span class="token operator">-></span>d<span class="token punctuation">.</span>end<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/*             * the array allocation is the last in the pool             * and there is space for new allocation             */</span>            p<span class="token operator">-></span>d<span class="token punctuation">.</span>last <span class="token operator">+</span><span class="token operator">=</span> size<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// size = n * a->size; 调整last的指向</span>            a<span class="token operator">-></span>nalloc <span class="token operator">+</span><span class="token operator">=</span> n<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 更新元素个数</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 否则扩容</span>            <span class="token comment" spellcheck="true">/* allocate a new array */</span>            nalloc <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">>=</span> a<span class="token operator">-></span>nalloc<span class="token punctuation">)</span> <span class="token operator">?</span> n <span class="token punctuation">:</span> a<span class="token operator">-></span>nalloc<span class="token punctuation">)</span><span class="token punctuation">;</span>            new <span class="token operator">=</span> <span class="token function">ngx_palloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> nalloc <span class="token operator">*</span> a<span class="token operator">-></span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>new <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">ngx_memcpy</span><span class="token punctuation">(</span>new<span class="token punctuation">,</span> a<span class="token operator">-></span>elts<span class="token punctuation">,</span> a<span class="token operator">-></span>nelts <span class="token operator">*</span> a<span class="token operator">-></span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>            a<span class="token operator">-></span>elts <span class="token operator">=</span> new<span class="token punctuation">;</span>            a<span class="token operator">-></span>nalloc <span class="token operator">=</span> nalloc<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    elt <span class="token operator">=</span> <span class="token punctuation">(</span>u_char <span class="token operator">*</span><span class="token punctuation">)</span> a<span class="token operator">-></span>elts <span class="token operator">+</span> a<span class="token operator">-></span>size <span class="token operator">*</span> a<span class="token operator">-></span>nelts<span class="token punctuation">;</span>    a<span class="token operator">-></span>nelts <span class="token operator">+</span><span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token keyword">return</span> elt<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li><p>数组的控制中心ngx_array_t和数据区data是分开申请内存的，它们在内存池上很大概率是不连续的内存，释放数组时要对它们分开进行释放。</p></li><li><p>数组能不能被释放取决于其所在的内存区域，如果是在used区域的末尾则可以通过调整last将其归还给内存池。</p><p>如果不在used的末尾，则意味着数组内存的尾端和last之间存在分配给了其它调用者的内存，如果修改last会导致这块内存在下一次调用申请内存的函数时再次被分配出去并修改上面的数据导致意外的结果。</p></li><li><p>数组数据区域必须连续，以保证能随机访问以及访问的效率。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubenetes技巧&amp;总结</title>
      <link href="2021/01/16/kubectl/"/>
      <url>2021/01/16/kubectl/</url>
      
        <content type="html"><![CDATA[<h5 id="kubectl命令小技巧"><a href="#kubectl命令小技巧" class="headerlink" title="kubectl命令小技巧"></a>kubectl命令小技巧</h5><h6 id="平滑更新部署（滚动更新）。相当于阿里云的容器服务里的触发器，触发更新。"><a href="#平滑更新部署（滚动更新）。相当于阿里云的容器服务里的触发器，触发更新。" class="headerlink" title="平滑更新部署（滚动更新）。相当于阿里云的容器服务里的触发器，触发更新。"></a>平滑更新部署（滚动更新）。相当于阿里云的容器服务里的触发器，触发更新。</h6><pre class=" language-shell"><code class="language-shell">kubectl -n vk rollout restart deployment workerman</code></pre><h6 id="kubectl-创建https-secret"><a href="#kubectl-创建https-secret" class="headerlink" title="kubectl 创建https secret"></a>kubectl 创建https secret</h6><pre><code>kubectl create secret tls buygoodread.com --cert=5676553_buygoodread.com.pem --key=5676553_buygoodread.com.key -n test</code></pre><h5 id="基于header头的ingress流量转发"><a href="#基于header头的ingress流量转发" class="headerlink" title="基于header头的ingress流量转发"></a>基于header头的ingress流量转发</h5><p>通过设置ingress配置的注解：匹配请求的header（service-match），version: 3.6.* 则转发值service: abroadapitestservice，否则转发到leshuapiservice。在此基础上还可以设置权重（service-weight），在包含匹配header头的请求中，一定比例的请求转发至两个版本的service。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> leshuingress  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> test  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">kubernetes.io/ingress.class</span><span class="token punctuation">:</span> <span class="token string">"nginx"</span>    <span class="token key atrule">nginx.ingress.kubernetes.io/service-match</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">        abroadapitestservice: header("version", /^3.6.*$/)</span>    <span class="token key atrule">nginx.ingress.kubernetes.io/service-weight</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">        abroadapitestservice: 50, leshuapiservice: 50</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> hk.ad6755.com    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span>        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> leshuapiservice          <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">80</span>      <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span>        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> abroadapitestservice          <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">80</span>  <span class="token key atrule">tls</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> hk.ad6755.com    <span class="token key atrule">secretName</span><span class="token punctuation">:</span> leshuingress<span class="token punctuation">-</span>secret0</code></pre><h5 id="外部服务service"><a href="#外部服务service" class="headerlink" title="外部服务service"></a>外部服务service</h5><p>在某些环境里，需要将一个外部数据库作为后端服务进行连接，或者将另一个集群或者namespace中的服务作为后端。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>service<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">3306</span></code></pre><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Endpoints<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>service<span class="token key atrule">subsets</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">addresses</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">ip</span><span class="token punctuation">:</span> 172.16.45.68  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">3306</span></code></pre><pre class=" language-shell"><code class="language-shell">[root@iZbp1e0rt8tskkutxmaijbZ testService]# kubectl get svcNAME           TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGEkubernetes     ClusterIP   10.0.0.1      <none>        443/TCP   257dtest-service   ClusterIP   10.0.154.24   <none>        80/TCP    14m[root@iZbp1e0rt8tskkutxmaijbZ testService]# cd[root@iZbp1e0rt8tskkutxmaijbZ ~]# kubectl get svcNAME           TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGEkubernetes     ClusterIP   10.0.0.1      <none>        443/TCP   257dtest-service   ClusterIP   10.0.154.24   <none>        80/TCP    14m[root@iZbp1e0rt8tskkutxmaijbZ ~]# curl 10.0.154.245.6.16-log�;A*N,.A;F��!�/WIGiYa^4&^-mysql_native_password!��#08S01Got packets out of order[root@iZbp1e0rt8tskkutxmaijbZ ~]#    </code></pre><p>这种方式也有弊端，只能写ip不能写域名，例如阿里云上的数据库连接地址都是域名。此时需要用到另一种service：ExternalName</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>service<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> ExternalName  <span class="token key atrule">externalName</span><span class="token punctuation">:</span> rm<span class="token punctuation">-</span>bp1768cgx1e2an6w0.mysql.rds.aliyuncs.com</code></pre><pre class=" language-shell"><code class="language-shell">[root@yanxiangbookapi-test-d8f8c8cfb-s58zm data]# ping test-service.defaultPING rm-bp1768cgx1e2an6w0.mysql.rds.aliyuncs.com (172.16.45.68) 56(84) bytes of data.64 bytes from 172.16.45.68 (172.16.45.68): icmp_seq=1 ttl=101 time=0.769 ms64 bytes from 172.16.45.68 (172.16.45.68): icmp_seq=2 ttl=101 time=0.783 ms64 bytes from 172.16.45.68 (172.16.45.68): icmp_seq=3 ttl=101 time=0.736 ms64 bytes from 172.16.45.68 (172.16.45.68): icmp_seq=4 ttl=101 time=0.768 ms^C--- rm-bp1768cgx1e2an6w0.mysql.rds.aliyuncs.com ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 3001msrtt min/avg/max/mdev = 0.736/0.764/0.783/0.017 ms[root@yanxiangbookapi-test-d8f8c8cfb-s58zm data]# curl test-service.default:33065.6.16-log�<\55GEeN4��!�XA{gt/.9qOv&mysql_native_password!��#08S01Got packets out of order[root@yanxiangbookapi-test-d8f8c8cfb-s58zm data]#</code></pre><p>原理：创建ExternalName类型的service时会向coredns组件注册一条cname类型的记录：test-service.default — rm-bp1768cgx1e2an6w0.mysql.rds.aliyuncs.com</p><p>关于coredns：之前公司有爬虫业务，爬取数据时经常会报域名解析失败之类的错误，后来得知，在容器里解析域名时首先会向coredns服务查询，如果没查到，则会向宿主机设置的dns服务器查询。爬虫业务频繁使用coredns服务，导致cordns不断重启，因此有了业务上的报错。所以一般情况下，如果容器不需要使用service调用服务时，建议将容器的dnsPolicy设置为default。</p><h5 id="优雅终止pod"><a href="#优雅终止pod" class="headerlink" title="优雅终止pod"></a>优雅终止pod</h5><h6 id="生产中遇见的问题："><a href="#生产中遇见的问题：" class="headerlink" title="生产中遇见的问题："></a>生产中遇见的问题：</h6><p>web服务，由ingress代理到pod。ingress日志报了502，对比时间节点，502的时刻刚好是一次滚动更新，据此得知：ingress将流量代理到了已经被删除的pod（对比pod ip地址）。</p><h6 id="pod更新过程："><a href="#pod更新过程：" class="headerlink" title="pod更新过程："></a>pod更新过程：</h6><p>启动新pod =&gt; 等待新pod进入RUNNING状态 =&gt; 创建endpoint，将新服务纳入负载均衡 =&gt;  设置旧pod为Terminating状态 =&gt; preStop Hook执行 &amp; 从负载均衡器移除旧pod的endpoint =&gt; 等待preStop Hook执行结束 =&gt; 给旧pod中的容器一号进程发送一个sigterm信号 =&gt; 等待旧pod终止，如果超过了terminationGracePeriodSeconds所设置的时间则发送sigkill信号，并删除pod。<a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/#termination-of-pods" target="_blank" rel="noopener">参考</a></p><h6 id="实验："><a href="#实验：" class="headerlink" title="实验："></a>实验：</h6><p>给pod增加以下配置</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">lifecycle</span><span class="token punctuation">:</span>  <span class="token key atrule">preStop</span><span class="token punctuation">:</span>    <span class="token key atrule">exec</span><span class="token punctuation">:</span>      <span class="token key atrule">command</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> sleep      <span class="token punctuation">-</span> <span class="token string">"30"</span></code></pre><p>在增加prestop hook之后，手动触发pod滚动更新deployment，新pod进入running之后，旧pod进入Terminating状态的同时容器内部开始执行sleep（进入容器执行了一个监控脚本，监控是否有sleep进程），同时修改负载均衡器的endpoint（移除旧pod的endpoint）。</p><h6 id="分析出现502的原因："><a href="#分析出现502的原因：" class="headerlink" title="分析出现502的原因："></a>分析出现502的原因：</h6><p>旧pod首先被设置成Terminating状态，由于没有设置pre stop hook，这一步直接跳过，同时容器收到sigterm信号，容器内部的服务停止了。但是旧pod的endpoint并没有及时的从负载均衡后端移除（发送sigterm信号和修改负载均衡器的endpoint是同步执行的），流量依然被转发至旧pod，而旧pod中的服务已经终止，so 导致了502。</p><h6 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h6><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">lifecycle</span><span class="token punctuation">:</span>  <span class="token key atrule">preStop</span><span class="token punctuation">:</span>    <span class="token key atrule">exec</span><span class="token punctuation">:</span>      <span class="token key atrule">command</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> sleep      <span class="token punctuation">-</span> <span class="token string">"30"</span>terminationGracePeriodSeconds： 60</code></pre><p>增加preStop Hook —- 回调，在pod被设置为terminating状态之后，不要立马发送sigterm信号，而是执行preStop Hook，我这里执行sleep 30，也就是在pod被设置为Terminating状态之后什么也不做，等待30秒，里面的服务依旧运行，给负载均衡更新endpoint留时间，30s之后负载均衡器的endpoint必然更新完了，此时再给pod发送终止信号，服务优雅停止，更新。</p><h5 id="pod调度"><a href="#pod调度" class="headerlink" title="pod调度"></a>pod调度</h5><h6 id="deployment-或者-Rc-全自动调度"><a href="#deployment-或者-Rc-全自动调度" class="headerlink" title="deployment 或者 Rc 全自动调度"></a>deployment 或者 Rc 全自动调度</h6><p>根据k8s自己的算法，遍历节点，挑选合适的节点去调度</p><h6 id="NodeSelector：定向调度"><a href="#NodeSelector：定向调度" class="headerlink" title="NodeSelector：定向调度"></a>NodeSelector：定向调度</h6><p>给Node打标签，定义pod时使用NodeSelector字段进行定向调度</p><h6 id="NodeAffinity：Node亲和性调度"><a href="#NodeAffinity：Node亲和性调度" class="headerlink" title="NodeAffinity：Node亲和性调度"></a>NodeAffinity：Node亲和性调度</h6><ol><li>RequiredDuringSchedulingIgnoreDuringExection —- 硬限制，等同于NodeSelector</li><li>PreferedDuringSchedulingIgnoreDuringExection —– 软限制，会尝试但不强求</li></ol><blockquote><p>IgnoreDuringExection：如果一个pod所在的节点在pod运行期间标签发生了变更，不在符合该pod的节点亲和性需求，则系统忽略Node上的Label变化，该pod继续在该Node上运行</p></blockquote><h6 id="PodAffinity：Pod亲和与互斥调度"><a href="#PodAffinity：Pod亲和与互斥调度" class="headerlink" title="PodAffinity：Pod亲和与互斥调度"></a>PodAffinity：Pod亲和与互斥调度</h6><h6 id="Taints和Toletations"><a href="#Taints和Toletations" class="headerlink" title="Taints和Toletations"></a>Taints和Toletations</h6><p>与NodeAffinity相似，不过作用相反：Traint要求Node拒绝pod的运行，是定义在pod上的属性。</p><h6 id="Pod优先级调度"><a href="#Pod优先级调度" class="headerlink" title="Pod优先级调度"></a>Pod优先级调度</h6><p>给pod设置优先级，数字越大优先级越高。</p>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubenetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcp-ip</title>
      <link href="2020/09/10/tcp:ip/"/>
      <url>2020/09/10/tcp:ip/</url>
      
        <content type="html"><![CDATA[<h4 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h4><h5 id="1-2-分层"><a href="#1-2-分层" class="headerlink" title="1.2 分层"></a>1.2 分层</h5><p>tcp/ip通常被认为是一个四层协议系统：</p><ol><li><p>链路层</p><p>也称作数据链路层或网络接口层。通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或者任何传输介质）的物理接口细节。</p></li><li><p>网络层</p><p>也称为互联网层，处理分组在网络中的活动。网络层IP提供一种不可靠的服务，它只是尽可能的快地把数据包从源结点送到目的结点，但是并不提供任何可靠性保证。TCP在不可靠的IP层上提供了一个可靠的运输层（TCP采用超时重传、发送和接收端的确认分组等机制）。ICMP是IP协议的附属协议，IP层用它来与其它主机或路由器交换错误报文和其它重要信息。</p></li><li><p>运输层</p><p>为两台主机上的应用提供端到端的通信。TCP/IP协议族中有两个互不相同的传输协议：tcp（传输控制协议）和udp（用户数据报协议）。虽然TCP使用不可靠的IP服务，但是它缺提供一种可靠的运输层服务。UDP是不可靠的，它不能保证数据安全无误的到达最终目的地。</p></li><li><p>应用层</p><p>负责处理特定的应用程序细节。</p></li></ol><h5 id="1-4-互联网的地址"><a href="#1-4-互联网的地址" class="headerlink" title="1.4 互联网的地址"></a>1.4 互联网的地址</h5><p>A、B、C类为商用</p><p><img src="https://img.3amupupup.online/image-20210207235709211.png" alt="五类互联网地址"></p><h5 id="1-6-封装"><a href="#1-6-封装" class="headerlink" title="1.6 封装"></a>1.6 封装</h5><p><img src="https://img.3amupupup.online/image-20210208000359450.png" alt="数据在协议栈中的封装"></p><h5 id="1-7-分用"><a href="#1-7-分用" class="headerlink" title="1.7 分用"></a>1.7 分用</h5><p><img src="https://img.3amupupup.online/image-20210208000627638.png" alt="分用过程"></p><h5 id="1-9-端口号"><a href="#1-9-端口号" class="headerlink" title="1.9 端口号"></a>1.9 端口号</h5><p>TCP和UDP采用16bit位的端口号来识别应用程序。</p><p>客户端通常对它使用的端口号并不关心，只需要保证使用的端口号在本机是唯一就行了。客户端端口号又称临时端口号。</p><h4 id="第二章-链路层"><a href="#第二章-链路层" class="headerlink" title="第二章 链路层"></a>第二章 链路层</h4><p>链路层主要有三个目的：</p><ul><li>为IP模块接受和发送数据报</li><li>为ARP模块发送ARP请求和接受ARP应答</li><li>为RARP发送RARP请求和接受RARP应答</li></ul><h5 id="2-7-环回接口"><a href="#2-7-环回接口" class="headerlink" title="2.7 环回接口"></a>2.7 环回接口</h5><p>使运行在同一台主机上的客户端程序和服务端程序能投通过TCP/IP进行通信。一个传给环回接口的IP数据报不能在任何网络上出现。</p><h4 id="第三章-IP"><a href="#第三章-IP" class="headerlink" title="第三章 IP"></a>第三章 IP</h4><h5 id="3-2-IP首部"><a href="#3-2-IP首部" class="headerlink" title="3.2 IP首部"></a>3.2 IP首部</h5><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://img.3amupupup.online/image-20210207155438038.png" alt="IP报头"></h4><p>版本号字段：协议版本号，当前是ipv4。</p><p>首部长度字段：4个比特位，能表示范围是0~15，每个长度单位为4字节，所以首部的最大长度为60字节。</p><p>TOS:</p><p>总长度字段：整个ip数据报的长度（以字节为单位，该字段长为16个比特，由此可知该字段表示的数值范围是0~65535，也说明一个ip报文的最大长度是65535字节）。利用首部长度字段和总长度字段就可以知道ip数据报中数据内容的起始位置和长度（首部长度+1 ， 总长度-首部长度）。</p><p>16位标识：标识主机发送的每一个报文，每发送一个自增1。</p><p>3位标志字段：3个比特位，用一个比特表位表示有“更多的片”，除最后一片之外，每一片都要设置该比特位为1。</p><p>片偏移字段：指的是该片偏移原始数据报开始处的位置，也就是说一个原始ip报文，被分割成多个ip报文之后的每个报文中会存储一个值，这个值是当前片相对原始报文起始位置的偏移量。</p><p>TTL生存时间字段：表示数据报可以经过的最多路由器数。TTL通常由源主机设置（32或64），经过一个处理它的路由器，ttl的值就减去1，当该字段为0时，数据报被丢弃，并发送ICMP报文通知源主机。</p><p>协议字段：</p><p>首部校验和字段：根据ip首部计算的校验和码（不对首部后面的数据进行计算）</p><p>选项字段：以32bit作为界限，有必要的时候插入0作为填充字节，以保证IP首部始终是32bit的整数倍</p><h5 id="3-3-路由选择"><a href="#3-3-路由选择" class="headerlink" title="3.3 路由选择"></a>3.3 路由选择</h5><p>IP路由选择是简单的，特别对于主机来说，如果目的主机与源主机直接相连或者都在一个共享网络上（以太网或者令牌环网），那么IP数据就直接发送到目的主机上。否则，主机把数据报发往默认的路由器上，由路由器转发该数据报。</p><p>IP层在内存中存在路由表。当收到一份数据报并进行转发时，都要对该表进行搜索。当数据报来自某个网络接口时，IP首先检查目的IP地址是否为本机的IP地址之一或者IP广播地址。如果是，数据报就会被送到由IP首部协议字段所指定的协议模块进行处理。如果不是且IP层被设置为路由器的功能那么就对数据报进行转发，否则数据报被丢弃。</p><h6 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h6><ul><li><p>目的IP地址(Destination)</p><p>可以是一个完整的主机地址，也可以是一个网络地址。图中第一条是默认规则(0.0.0.0)，仅当只有一条可用路径时才匹配。</p></li><li><p>下一站（下一跳）路由器的IP地址，下一站路由器是指一个直接相连的网络上的路由器，通过它可以转发数据报。</p></li><li><p>标志</p></li><li><p>为数据报的传输指定一个网络接口。</p></li></ul><h6 id="IP路由选择功能"><a href="#IP路由选择功能" class="headerlink" title="IP路由选择功能"></a>IP路由选择功能</h6><ol><li>搜索路由表，寻找与目的IP地址完全匹配的表目（网络号和主机号都要匹配）。</li><li>搜索路由表，寻找能与目的网络号匹配的表目。如果找到则把报文发送给该表目指定的下一跳路由器或者直接连接的网络接口。</li><li>搜索路由表，寻找标志为“默认（default）”的表目，如果找到，则把报文发送给改表目指定的下一跳路由器。</li><li>完整的主机地址匹配在网络号匹配之前执行。只有当他们都失败后才会选择默认路由。</li><li>为网络指定一个路由器，而不必为每一个主机都指定一个路由器，可以极大缩小路由表的规模。</li></ol><h5 id="3-4-子网寻址"><a href="#3-4-子网寻址" class="headerlink" title="3.4 子网寻址"></a>3.4 子网寻址</h5><p><img src="https://img.3amupupup.online/image-20210208163443250.png" alt="子网寻址"></p><p>所有主机都要求支持子网编址。不再是把IP地址看成单纯的一个网络号和一个主机号组成，而是把主机号再分成一个子网号和一个主机号。原因：A类和B类地址为主机号分配了太多空间，A类：2<sup>24</sup>-2（24位主机号:2<sup>24</sup>，全0和全1是无效的，所以减去2），B类：2<sup>16</sup>-2，事实上一个网络安排不了这么多主机。</p><p>例如上图中的B类地址：可以将主机号划分为8bit的子网号，8bit的主机号。也就是说将网络号是140.252的IP地址划分为254个子网，每个子网可以有254台主机。</p><h5 id="3-5-子网掩码"><a href="#3-5-子网掩码" class="headerlink" title="3.5 子网掩码"></a>3.5 子网掩码</h5><p>子网掩码用于确定IP地址中多少比特位用于子网号多少比特位用于主机号。</p><p>掩码是一个32bit的值，其中值为1的留给网络号和子网号，为0的比特留给主机号。</p><pre class=" language-txt"><code class="language-txt">10101100 00010000 00000000 00000000 IP网段: 172.16.0.011111111 11111111 00000000 00000000 掩码: 1610101100 00010000 00000000 00000000 IP网段: 172.16.16.011111111 11111111 11110000 00000000 掩码: 20</code></pre><p>给定IP地址和子网掩码之后，主机就可以确定IP数据报的目的地是：</p><ol><li>本子网上的主机</li><li>本网络中其它子网上的主机</li><li>其它网络上的主机</li></ol><h4 id="第六章-ICMP"><a href="#第六章-ICMP" class="headerlink" title="第六章 ICMP"></a>第六章 ICMP</h4><p>ICMP报文是在IP数据报内部被传输的。</p><p><img src="https://img.3amupupup.online/image/image-20210208204348894.png" alt="image-20210208204348894"></p><p><img src="../../../Desktop/source/image/image-20210208204543776.png" alt="image-20210208204543776"></p><p>类型字段有15个不同的值，以描述特定类型的ICMP报文。某些ICMP报文还使用代码字段的值来进一步描述不同的条件。</p><p>检验和字段覆盖整个ICMP报文。ICMP的校验和时必须的。</p><h4 id="第八章-Traceroute"><a href="#第八章-Traceroute" class="headerlink" title="第八章 Traceroute"></a>第八章 Traceroute</h4><p>TTL字段的目的是防止数据报在选路时无休止的在网络中流动。</p><p>当路由器收到一份IP数据报时，如果其ttl字段时0或者1，则路由器不转发该数据报，路由器会将该数据报丢弃并给信源机发送一份ICMP超时信息，Traceroute程序的关键在于包含这份icmp信息的ip报文的信源地址是该路由器的地址。</p><p>Traceroute工作原理：发送一个ttl为1的ip数据报给目的主机，这样就得到了第一个路由器的ip地址；紧接着发送一个ttl为2的数据包给目的主机…….。继续该过程直到该数据报到达目的主机。Traceroute发送一份udp数据报给目的主机，但它选择一个不可能的值作为udp端口号(大于30000)，使目的主机的任何一个应用程序都不能使用该端口。因为，当该数据报到达时，使目的主机的udp模块产生一份“端口不可达”错误的icmp报文，此时Tracetoute程序需要做的就是区分接受到的icmp报文是超时还是端口不可达。</p><h4 id="第九章-IP选路"><a href="#第九章-IP选路" class="headerlink" title="第九章 IP选路"></a>第九章 IP选路</h4><p>需要进行选路的数据报可以由本机产生，也可以由其它主机产生(此种情况下：主机必须被配置成一个路由器，否则通过网络接口接受到的数据报，如果目的地址不是本级就会被丢弃)</p><p>IP搜索路由表的步骤：</p><ol><li>搜索匹配的主机地址(网络号、主机号完全一致)</li><li>搜索匹配的网络地址(网络号一致)</li><li>搜索默认表项</li></ol><p>匹配主机地址始终发生在匹配网络地址步骤之前。</p><h5 id="9-2-1-路由表"><a href="#9-2-1-路由表" class="headerlink" title="9.2.1 路由表"></a>9.2.1 路由表</h5><p><img src="https://img.3amupupup.online/image-20210301163425431.png" alt="image-20210301163425431"></p><p>flags:</p><ul><li>U：该路由可以使用</li><li>H：该路由是到一个主机，也就是说目的地址是一个完整的主机地址。如果没有设置该标志则说明该路由是到一个网络，而目的地址是一个网络地址。</li><li>G：该路由是到一个网关，如果没有设置该标志则说明目的地是直接相连的。这个标志很重要，区分直接路由和间接路由，存在则说明是间接路由：ip地址指明的是最终目的地，链路层地址指明的是网关。不存在则是直接路由：发往直接路由的分组中不但具有指明目的端的ip地址，还具有其链路层地址。</li></ul><p><img src="https://img.3amupupup.online/image-20210301163453659.png" alt="image-20210301163453659"></p><p>最后两条记录的Gateway 0.0.0.0是无意义的，只有Flags标志为G才会使用网关。标志G区分是直接路由还是间接路由(直接路由不设置G标志)：发往直接路由的分组中不但具有指明目的端的ip地址，还具有其链路层地址。当分组被发往一个间接路由时，IP地址指明的是最终的目的地，但是链路层指明的是网关(下一站路由器)。</p><h4 id="第11章-用户数据报协议"><a href="#第11章-用户数据报协议" class="headerlink" title="第11章 用户数据报协议"></a>第11章 用户数据报协议</h4><p>udp首部</p><p><img src="https://img.3amupupup.online/image-20210301171045570.png" alt="image-20210301171045570"></p><h5 id="11-5-IP分片"><a href="#11-5-IP分片" class="headerlink" title="11.5 IP分片"></a>11.5 IP分片</h5><p>物理网络层一般要限制每次发送数据帧的最大长度。任何时候IP层接收到一份要发送的IP数据报时，它要判断向本地哪个接口发送数据(选路)，并查询该接口获得MTU(最大传输单元,netstat -i)。IP把MTU与数据报长度进行比较，如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发生在中间路由器上。</p><blockquote><p>引自 《计算机网络》</p><p>标识（identification）：<strong>占16位</strong>。IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。</p><p>但这个“标识”不是序号，因为IP是无连接服务，<strong>数据报不存在按序接收的问题</strong>。当数据报由于长度超过网络的MTU而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原</p><p>来的数据报。</p><p><strong>标志（flag）：</strong>占3位，但目前只有两位有意义。</p><p>​    – 标志字段中的最低位为MF（More Fragment）。MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个。</p><p>​    – 标志字段中间的一位记为DF（Don’t Fragment），意思是“不能分片”。只有当DF=0时才允许分片。</p><p><strong>片偏移 ：</strong>占13位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以8个字节为偏移单位。也就是说，每个分片的长度一定是8字节（64位）的整数倍。</p></blockquote><h6 id="避免分片发生"><a href="#避免分片发生" class="headerlink" title="避免分片发生"></a>避免分片发生</h6><p>当tcp报文发生丢失，超时之后发生重传，该tcp报文段对应一份ip数据报，此时是没有办法只重传丢失的这一份ip报文的，因为ip分片如果发生在传输途中的路由器上，发送端无法知道是怎么分片的，丢失的是那一段，因此必须重传整个原始ip报文。</p><h4 id="第十七章-TCP-传输控制协议"><a href="#第十七章-TCP-传输控制协议" class="headerlink" title="第十七章 TCP:传输控制协议"></a>第十七章 TCP:传输控制协议</h4><h5 id="17-2-TCP的服务"><a href="#17-2-TCP的服务" class="headerlink" title="17.2 TCP的服务"></a>17.2 TCP的服务</h5><p>尽管tcp和udp都使用相同的网络层(IP)，tcp向应用层提供与udp完全不同的服务。tcp提供一种面向连接的、可靠的字节流服务。</p><p>tcp通过下列方式提供可靠性：</p><ul><li>应用数据被分割成tcp认为最适合发送的数据块。（udp：应用产生的报文长度保持不变）</li><li>当tcp发出一个段之后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li><li>当tcp收到发自tcp连接另一端的数据，它将发送一个确认。</li><li>tcp将保持它首部和数据的校验和。（如果收到段的检验和有差错，tcp将丢弃这个报文段并不确认收到此报文段）</li><li>tcp报文段作为IP数据报传输，而ip数据报的到达可能会失序，因此tcp报文段的到达也有可能失序。tcp将会对收到的数据进行排序然后交给应用层。</li><li>ip数据报会发生重复，因此接收端必须丢弃重复的数据。</li><li>tcp能提供流量控制。tcp连接的每一方都有固定大小的缓冲空间。tcp的接收端只允许另一端发送接收端缓冲区所能接纳的大小。（防止发送较快的主机使接收的较慢的主机缓冲区溢出）</li></ul><h5 id="17-3-TCP的首部"><a href="#17-3-TCP的首部" class="headerlink" title="17.3 TCP的首部"></a>17.3 TCP的首部</h5><p>tcp数据被封装在一个ip数据报中。</p><p><img src="https://img.3amupupup.online/image-20210217022249843.png" alt="image-20210217022249843"></p><p>tcp首部：</p><ul><li>16位的源端口号和目的端口号（用于寻找发端和接收端的应用程序），客户端ip、客户端端口、服务端ip、服务端端口可唯一确定一个tcp连接。</li><li>序号：标识从tcp发端向tcp收端发送的数据字节流，它表示在这个报文段中的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则tcp用序号对每个字节进行计数。（序号是32bit，序号达到2<sup>32</sup>-1后又从0开始。）当建立一个新的连接时，SYN标志位变成1。序号字段包含由这个主机选择的该连接的初始序号ISN(Initial Sequece Number)。该主机要发送的第一个字节序列号为ISN+1(SYN标志消耗了一个序号)。</li><li>确认序号：是发送端序号的下一个序号。只有ACK标志为1时确认序号才有效。发送ACK不需要任何代价，因为是包含在首部中的字段，一个tcp连接一旦建立起来，ACK标识总是被置为1。tcp提供全双工服务</li><li>首部长度：4bit，能表示的范围是0-15，单位是4字节，所以tcp首部最大为60字节。</li><li>标志位：6个标志位<ul><li>URG：紧急指针有效</li><li>ACK：确认序号有效</li><li>PSH：接收方应尽快将这个报文交给应用层</li><li>RST：重建连接</li><li>SYN：同步序号，用来发起一个连接</li><li>FIN：发端完成发送任务</li></ul></li><li>窗口：tcp的流量控制由连接的每一端通过声明的窗口大小提供。窗口大小为字节数，16bit因而窗口大小最大为65535字节。</li><li>检验和：覆盖整个tcp报文段—-首部和数据</li><li>紧急指针：只有URG标志置为1时才有效。</li><li>常见可选字段：最长报文大小，又称为MSS(Maximum Segment Size)，每个连接方通常都在通信的第一个报文段中声明这个选项，它指明本端能接收最大长度的报文段。</li></ul><p><img src="https://img.3amupupup.online/image-20210217022444857.png" alt="image-20210217022444857"></p><h4 id="第十八章-TCP连接的建立与终止"><a href="#第十八章-TCP连接的建立与终止" class="headerlink" title="第十八章 TCP连接的建立与终止"></a>第十八章 TCP连接的建立与终止</h4><h5 id="18-2-连接的建立与终止"><a href="#18-2-连接的建立与终止" class="headerlink" title="18.2 连接的建立与终止"></a>18.2 连接的建立与终止</h5><p>注：Flags [S.]，S表示SYN，“.”表示ACK</p><p><img src="https://img.3amupupup.online/tcpdump.jpg" alt="tcpdump抓包"></p><p>这是用telnet实现的一次通信，利用tcpdump进行抓包，如下是分析（iZbp11u8qxiwepq15dm1liZ表示本机）：</p><p><img src="https://img.3amupupup.online/tcp.jpg" alt="tcpdump输出字段解释说明"></p><p>第一行：方向：iZbp11u8qxiwepq15dm1liZ &gt; 47.96.67.121。iZbp11u8qxiwepq15dm1liZ 通过54008端口发送一个SYN标志位为1(通过Flags字段得知)的报文给远端主机47.96.67.121的ssh端口–也就是22端口，此报文的序号即seq是：826162287（ISN），后面的字段暂时可以忽略。</p><p>第二行：方向：47.96.67.121 &gt; iZbp11u8qxiwepq15dm1liZ。远程主机47.96.67.121 回复一个SYN标志位为1的报文给 iZbp11u8qxiwepq15dm1liZ，此报文序号即seq是：1641364849，此报文中出现了ack字段（表示确认），只有在首部中ACK标志被置为1时才显示，说明此报文中SYN、ACK两个标志位为1，当ACK为1时确认序号生效—826162288</p><p>第三行：方向：iZbp11u8qxiwepq15dm1liZ &gt; 47.96.67.121。由于47.96.67.121发来的报文首部中序号是1641364849(第二行)，所以在给47.96.67.121 回包时会将确认序号置为 序号（1641364849）的下一个序号。</p><p>第四行：方向：47.96.67.121 &gt; iZbp11u8qxiwepq15dm1liZ。到这里连接建立成功，开始数据传输，据图第四行可知传输了21字节。</p><p>第五行：方向：iZbp11u8qxiwepq15dm1liZ &gt; 47.96.67.121。收到确认数据报文后通知发送端。</p><p>第六行：方向：iZbp11u8qxiwepq15dm1liZ &gt; 47.96.67.121。发送一个报文，标志位FIN为1，意思是给47.96.67.121说数据发送完毕，我要关闭了。</p><p>第七行：方向：47.96.67.121 &gt; iZbp11u8qxiwepq15dm1liZ。服务端回复一个ack给iZbp11u8qxiwepq15dm1liZ说 我已经收到你要关闭的消息了。</p><p>第八行：方向：47.96.67.121 &gt; iZbp11u8qxiwepq15dm1liZ。47.96.67.121发送FIN给iZbp11u8qxiwepq15dm1liZ说我关闭了。</p><p>第九行：方向：iZbp11u8qxiwepq15dm1liZ &gt; 47.96.67.121。告诉47.96.67.121我收到你的关闭消息了，然后发送一个ack向47.96.67.121确认。</p><h5 id="18-4-最大报文段长度"><a href="#18-4-最大报文段长度" class="headerlink" title="18.4 最大报文段长度"></a>18.4 最大报文段长度</h5><p><img src="https://img.3amupupup.online/tcpdump.jpg" alt="tcpdump抓包"></p><p>最大报文长度(MSS)表示tcp传往另一端的最大块数据长度。当一个连接建立时，连接双方都要通告各自的MMS(MSS只能出现在SYN报文段中)。上图中第一行：mss为1406。</p><h5 id="18-5-TCP的半关闭"><a href="#18-5-TCP的半关闭" class="headerlink" title="18.5 TCP的半关闭"></a>18.5 TCP的半关闭</h5><p>TCP提供了连接的一段在结束了它的发送之后还能接收另一端的数据的能力。</p><h5 id="18-6-1-2MSL等待状态"><a href="#18-6-1-2MSL等待状态" class="headerlink" title="18.6.1 2MSL等待状态"></a>18.6.1 2MSL等待状态</h5><p>当tcp执行一端主动关闭，并发回最后一个ack，该连接必须在TIME_WAIT状态停留的时间为2MSL(Max Segment LifeTime)，这样可以让tcp能够再次发送最后的ACK以防止这个ACK丢失。在2MSL等待期间，插口中使用的本地端口在默认情况下不能再被使用。</p><h5 id="18-6-3-FIN-WAIT-2状态"><a href="#18-6-3-FIN-WAIT-2状态" class="headerlink" title="18.6.3 FIN_WAIT_2状态"></a>18.6.3 FIN_WAIT_2状态</h5><p><img src="https://img.3amupupup.online/image-20210217195649249.png" alt="image-20210217195649249"></p><h5 id="18-7-复位报文段"><a href="#18-7-复位报文段" class="headerlink" title="18.7 复位报文段"></a>18.7 复位报文段</h5><p><img src="https://img.3amupupup.online/image-20210217200503883.png" alt="tcpdump"></p><p><img src="https://img.3amupupup.online/image-20210217200816830.png" alt="试图在不存在的端口上打开连接而产生的复位"></p><p>向一个没有监听的端口发起连接，服务端返回了一个RST标志为1的报文。</p><h4 id="第十九章-TCP的交互数据流"><a href="#第十九章-TCP的交互数据流" class="headerlink" title="第十九章 TCP的交互数据流"></a>第十九章 TCP的交互数据流</h4><h5 id="19-4-Nagle算法"><a href="#19-4-Nagle算法" class="headerlink" title="19.4 Nagle算法"></a>19.4 Nagle算法</h5><p>在局域网中，小分组一般不会引起网络拥塞。但在广域网上，可能会出现拥塞。</p><p>Nagle算法要求一个tcp连接上最多只能有一个未被确认的小分组（数据报发出去，必须得到远端的ack回复，最多只能有一个报文未被回复），在该分组的确认到达之前不能发送其它小分组。在等待确认到达的这段时间内，tcp会收集小分组并在ack确认到达的时候将收集的小分组一次性发出去。Nagle算法的优越之处在于：确认到达的越快，数据发送的越快。在希望减少分组的广域网中，则会发送更少的分组。</p><h4 id="第二十章-TCP的成块数据流"><a href="#第二十章-TCP的成块数据流" class="headerlink" title="第二十章 TCP的成块数据流"></a>第二十章 TCP的成块数据流</h4><h5 id="20-6-慢启动"><a href="#20-6-慢启动" class="headerlink" title="20.6 慢启动"></a>20.6 慢启动</h5><p>在局域网络中，发送方一开始便向网络中发送多个报文段，直到达到接收方通告的窗口大小为止，这种方式是没有问题的。但是当发送端和接收端之间存在多个路由器和速率较慢的链路时，就有可能出现一些问题：一些中间路由器必须缓存分组(报文)，并有可能耗尽存储器的空间(存储器耗尽之后路由器会丢弃新收到的分组)。</p><p>tcp支持慢启动算法，该算法通过观察到新分组进入网络的速率应该和另一端返回确认的速率相同而进行工作。</p><p>慢启动为发送方tcp增加了另一个新窗口：拥塞窗口(cwnd)。当与另一个网络的主机建立tcp连接时，拥塞窗口被初始化为一个报文段大小(另一端通告的窗口大小)。每收到一个ack，拥塞窗口就增加一个报文段(cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加)。发送方取拥塞窗口与通告窗口中的最小值作为发送上限(报文长度)。拥塞窗口是发送发使用的流量控制，通告窗口是接收方使用的流量控制。</p><p>拥塞窗口也不可能无限增大，在网络传输中，当某些点上的路由器网络容量达到了上限，于是中间路由器开始丢弃分组并通知发送方。</p><h4 id="第二十一章-TCP的超时与重传"><a href="#第二十一章-TCP的超时与重传" class="headerlink" title="第二十一章 TCP的超时与重传"></a>第二十一章 TCP的超时与重传</h4><p>tcp提供可靠的运输层：确认从另一端收到的数据(ack)，但数据和确认都可能会发生丢失。tcp通过在发送时设置一个定时器解决数据和确认丢失的问题，当定时器发生溢出时还没有收到该数据的确认就重传该数据。</p><p>对于每个连接，tcp管理四个定时器：</p><ol><li>重传定时器：期望收到对端确认的最大等待时间。</li><li>坚持定时器：使<strong>窗口</strong>大小信息保持不断流动，当发送端的发送速度过快，接收方的缓冲区被打满时，接收方会通告窗口大小为0，此时发送方会暂停数据发送，坚持定时器的作用就是<strong>不断发送报文询问窗口大小防止出现死锁</strong>(接收端不通告新的窗口大小，发送方一直等待。)</li><li>保活定时器：可以检测到一个空闲连接的另一端何时崩溃或者重启。</li><li>2MSL定时器：测量一个连接处于TIME_WAIT状态的时间。</li></ol><h4 id="21-2-超时重传例子"><a href="#21-2-超时重传例子" class="headerlink" title="21.2 超时重传例子"></a>21.2 超时重传例子</h4><p><img src="https://img.3amupupup.online/image-20210305165017197.png" alt="image-20210305165017197"></p><h4 id="21-3-往返时间测量"><a href="#21-3-往返时间测量" class="headerlink" title="21.3 往返时间测量"></a>21.3 往返时间测量</h4><p>tcp超时与重传中最重要的部分就是对一个给定的连接的往返时间(RTT)测量</p><h4 id="21-6-拥塞避免算法"><a href="#21-6-拥塞避免算法" class="headerlink" title="21.6 拥塞避免算法"></a>21.6 拥塞避免算法</h4><p>慢启动算法是在一个连接上发起数据流的方法，但有时可能会达到中间路由器的极限，此时分组将被丢弃。当拥塞发生时，希望降低分组进入网络的传输速率，于是可以调用慢启动来实现这一点。</p><p>拥塞避免算法和慢启动算法需要对每个连接维持两个变量：一个拥塞窗口cwnd和一个慢启动门限ssthresh。算法工作过程如下：</p><ol><li>对一个给定的连接，初始化cwnd为一个报文段，ssthresh为65535个字节。</li><li>tcp输出程序的输出不能超过cwnd和接收方通告窗口的大小。拥塞避免是发送方使用的流量控制，而通告窗口则是接收方进行的流量控制。</li><li>当拥塞发生时（超时或收到重复确认），ssthresh被设置为当前窗口大小的一半（cwnd和接收方通告窗口大小的最小值，但最少为2个报文段。min(cwnd, win)/2）。此外，如果是超时引起了拥塞，则cwnd被设置为1个报文段。</li><li>当新的数据被对方确认时，就增加cwnd，但增加的方法依赖于是否正在进行慢启动或拥塞避免。如果小于cwnd小于或者等于ssthresh，则正在进行慢启动，否则正在进行拥塞避免。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
