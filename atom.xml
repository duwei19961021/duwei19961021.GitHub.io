<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BLOG</title>
  
  
  <link href="http://blog.3amupupup.online/atom.xml" rel="self"/>
  
  <link href="http://blog.3amupupup.online/"/>
  <updated>2021-03-18T08:17:15.264Z</updated>
  <id>http://blog.3amupupup.online/</id>
  
  <author>
    <name>拦云</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ngx缓冲区结构.md</title>
    <link href="http://blog.3amupupup.online/2021/03/18/ngx%E7%BC%93%E5%86%B2%E5%8C%BA%E7%BB%93%E6%9E%84-md/"/>
    <id>http://blog.3amupupup.online/2021/03/18/ngx%E7%BC%93%E5%86%B2%E5%8C%BA%E7%BB%93%E6%9E%84-md/</id>
    <published>2021-03-18T07:14:01.000Z</published>
    <updated>2021-03-18T08:17:15.264Z</updated>
    
    
    
    
    <category term="C语言" scheme="http://blog.3amupupup.online/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="nginx" scheme="http://blog.3amupupup.online/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx数组</title>
    <link href="http://blog.3amupupup.online/2021/03/18/ngx_array/"/>
    <id>http://blog.3amupupup.online/2021/03/18/ngx_array/</id>
    <published>2021-03-18T05:25:40.825Z</published>
    <updated>2021-03-19T08:38:49.265Z</updated>
    
    <content type="html"><![CDATA[<h5 id="nginx数据类型：数组"><a href="#nginx数据类型：数组" class="headerlink" title="nginx数据类型：数组"></a>nginx数据类型：数组</h5><p><img src="https://img.3amupupup.online/ngx_array-.png" alt="ngx_array"></p><pre><code class="c">typedef struct {    void        *elts;      // 指向第一个元素的指针    ngx_uint_t   nelts;     // 未使用的元素的索引    size_t       size;      // 每个元素大小    ngx_uint_t   nalloc;    //  元素个数    ngx_pool_t  *pool;      //  内存池} ngx_array_t;</code></pre><h5 id="数组提供的接口"><a href="#数组提供的接口" class="headerlink" title="数组提供的接口"></a>数组提供的接口</h5><pre><code class="c">ngx_array_t *ngx_array_create(ngx_pool_t *p, ngx_uint_t n, size_t size);    // 创建数组的数据结构void ngx_array_destroy(ngx_array_t *a); // 销毁数组void *ngx_array_push(ngx_array_t *a);   // push单个元素void *ngx_array_push_n(ngx_array_t *a, ngx_uint_t n);    // push n个元素static ngx_inline ngx_int_t ngx_array_init(ngx_array_t *array, ngx_pool_t *pool, ngx_uint_t n, size_t size)    //  // ngx_array_create会调用此函数，申请之后调用这个函数进行初始化操作</code></pre><h6 id="ngx-array-t-ngx-array-create-ngx-pool-t-p-ngx-uint-t-n-size-t-size"><a href="#ngx-array-t-ngx-array-create-ngx-pool-t-p-ngx-uint-t-n-size-t-size" class="headerlink" title="ngx_array_t *ngx_array_create(ngx_pool_t *p, ngx_uint_t n, size_t size);"></a>ngx_array_t *ngx_array_create(ngx_pool_t *p, ngx_uint_t n, size_t size);</h6><pre><code class="c">ngx_array_t *ngx_array_create(ngx_pool_t *p, ngx_uint_t n, size_t size){    ngx_array_t *a;      // 在内存池上为ngx_array_t结构体申请内存,具体分配到小数据块链表还是大数据块链表取决于size,不再作解释    a = ngx_palloc(p, sizeof(ngx_array_t));    if (a == NULL) {        return NULL;    }    if (ngx_array_init(a, p, n, size) != NGX_OK) {  // 再次申请内存(给数组分配的)        return NULL;    }    return a;}</code></pre><h6 id="static-ngx-inline-ngx-int-t-ngx-array-init-ngx-array-t-array-ngx-pool-t-pool-ngx-uint-t-n-size-t-size"><a href="#static-ngx-inline-ngx-int-t-ngx-array-init-ngx-array-t-array-ngx-pool-t-pool-ngx-uint-t-n-size-t-size" class="headerlink" title="static ngx_inline ngx_int_t ngx_array_init(ngx_array_t *array, ngx_pool_t *pool, ngx_uint_t n, size_t size)"></a>static ngx_inline ngx_int_t ngx_array_init(ngx_array_t *array, ngx_pool_t *pool, ngx_uint_t n, size_t size)</h6><pre><code class="c">// ngx_array_create会调用此函数，申请之后进行初始化操作static ngx_inline ngx_int_tngx_array_init(ngx_array_t *array, ngx_pool_t *pool, ngx_uint_t n, size_t size){    /*     * set &quot;array-&gt;nelts&quot; before &quot;array-&gt;elts&quot;, otherwise MSVC thinks     * that &quot;array-&gt;nelts&quot; may be used without having been initialized     */    array-&gt;nelts = 0;    array-&gt;size = size;    array-&gt;nalloc = n;    array-&gt;pool = pool;    array-&gt;elts = ngx_palloc(pool, n * size);   // 去内存池上分配内存    if (array-&gt;elts == NULL) {        return NGX_ERROR;    }    return NGX_OK;}</code></pre><h6 id="void-ngx-array-destroy-ngx-array-t-a"><a href="#void-ngx-array-destroy-ngx-array-t-a" class="headerlink" title="void ngx_array_destroy(ngx_array_t *a)"></a>void ngx_array_destroy(ngx_array_t *a)</h6><ul><li><pre><code class="c">/* * 在 ngx_array_create() 函数中 ngx_array_t结构的内存和数组的内存是分开申请的，不一定连续， * 所以在将内存归还给内存池的时候也得分开归还 */voidngx_array_destroy(ngx_array_t *a){    ngx_pool_t  *p;    p = a-&gt;pool;    // 内存池的地址是被保存在ngx数组数据结构中的    /*     * 如果 数组首元素地址 + 元素大小*元素个数 == last的指向位置，     * 则说明这个数组的内存段是在used区域的尾部的，last直接减去 元素大小*元素个数 就代表销毁了这个数组的内存     */    if ((u_char *) a-&gt;elts + a-&gt;size * a-&gt;nalloc == p-&gt;d.last) {        p-&gt;d.last -= a-&gt;size * a-&gt;nalloc;    }    /*     *  道理和上面类似     */    if ((u_char *) a + sizeof(ngx_array_t) == p-&gt;d.last) {        p-&gt;d.last = (u_char *) a;    }    // 否则就不能移动last}</code></pre></li><li><p><img src="http://img.3amupupup.online/ngx_array_destroy-.png" alt="ngx_array"></p><p>1、3是可以修改last指向的，2、4不行。</p><p>这里有疑问：2、4这两种情况内存岂不是无法释放(归还给内存池)，内存池会越来越大。</p></li></ul><h6 id="void-ngx-array-push-ngx-array-t-a"><a href="#void-ngx-array-push-ngx-array-t-a" class="headerlink" title="void *ngx_array_push(ngx_array_t *a)"></a>void *ngx_array_push(ngx_array_t *a)</h6><pre><code class="c">void *ngx_array_push(ngx_array_t *a)  // 添加1个元素{    void        *elt, *new;    size_t       size;    ngx_pool_t  *p;    if (a-&gt;nelts == a-&gt;nalloc) {        /* the array is full */        size = a-&gt;size * a-&gt;nalloc; // 计算当前数组的大小        p = a-&gt;pool;        if ((u_char *) a-&gt;elts + size == p-&gt;d.last            &amp;&amp; p-&gt;d.last + a-&gt;size &lt;= p-&gt;d.end)        /*         * 如果elts指向的位置加上当前数组的大小等于last且last到end之间有足够的空间去容纳一个元素则直接在这个内存池上添加元素         * 这个判定是要保证添加的元素所在的内存与之前数组的内存是连续的         */        {            /*             * the array allocation is the last in the pool             * and there is space for new allocation             */            p-&gt;d.last += a-&gt;size;            a-&gt;nalloc++;        } else {            // 否则就是不能保证内存连续或者空间不足            /* allocate a new array */            // 申请一个两倍的空间，new是首地址            new = ngx_palloc(p, 2 * size);            if (new == NULL) {                return NULL;            }            // #define ngx_memcpy(dst, src, n)   (void) memcpy(dst, src, n) 看到这个👴🏻想笑            ngx_memcpy(new, a-&gt;elts, size); // 将原来的内存地址上的数组部分的内容拷贝到新内存池上            a-&gt;elts = new;  // 指向新内存的位置            a-&gt;nalloc *= 2; // 元素个数翻倍        }    }    // 未使用的索引    elt = (u_char *) a-&gt;elts + a-&gt;size * a-&gt;nelts;    a-&gt;nelts++;    return elt;}</code></pre><h6 id="void-ngx-array-push-n-ngx-array-t-a-ngx-uint-t-n"><a href="#void-ngx-array-push-n-ngx-array-t-a-ngx-uint-t-n" class="headerlink" title="void *ngx_array_push_n(ngx_array_t *a, ngx_uint_t n)"></a>void *ngx_array_push_n(ngx_array_t *a, ngx_uint_t n)</h6><pre><code class="c">void *ngx_array_push_n(ngx_array_t *a, ngx_uint_t n){    void        *elt, *new;    size_t       size;    ngx_uint_t   nalloc;    ngx_pool_t  *p;    size = n * a-&gt;size;    if (a-&gt;nelts + n &gt; a-&gt;nalloc) {        /* the array is full */        p = a-&gt;pool;        /*         * 如果elts指向的位置加上当前数组的大小等于last 且 last到end之间 有足够的空间去容纳n个元素则直接在这个内存池上添加元素         * 这个判定是要保证添加的元素所在的内存与之前数组的内存是连续的         */        if ((u_char *) a-&gt;elts + a-&gt;size * a-&gt;nalloc == p-&gt;d.last            &amp;&amp; p-&gt;d.last + size &lt;= p-&gt;d.end)        {            /*             * the array allocation is the last in the pool             * and there is space for new allocation             */            p-&gt;d.last += size;  // size = n * a-&gt;size; 调整last的指向            a-&gt;nalloc += n;     // 更新元素个数        } else {    // 否则扩容            /* allocate a new array */            nalloc = 2 * ((n &gt;= a-&gt;nalloc) ? n : a-&gt;nalloc);            new = ngx_palloc(p, nalloc * a-&gt;size);            if (new == NULL) {                return NULL;            }            ngx_memcpy(new, a-&gt;elts, a-&gt;nelts * a-&gt;size);    // 宏函数，实际上调用的memcpy函数            a-&gt;elts = new;            a-&gt;nalloc = nalloc;        }    }    elt = (u_char *) a-&gt;elts + a-&gt;size * a-&gt;nelts;    a-&gt;nelts += n;    return elt;}</code></pre><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ol><li>首先谈下nginx数组的管理结构–</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;nginx数据类型：数组&quot;&gt;&lt;a href=&quot;#nginx数据类型：数组&quot; class=&quot;headerlink&quot; title=&quot;nginx数据类型：数组&quot;&gt;&lt;/a&gt;nginx数据类型：数组&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;https://img.3amupupu</summary>
      
    
    
    
    <category term="C语言" scheme="http://blog.3amupupup.online/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="nginx" scheme="http://blog.3amupupup.online/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://blog.3amupupup.online/2021/03/18/%E6%8E%92%E5%BA%8F/"/>
    <id>http://blog.3amupupup.online/2021/03/18/%E6%8E%92%E5%BA%8F/</id>
    <published>2021-03-18T03:09:52.078Z</published>
    <updated>2021-03-18T03:09:52.078Z</updated>
    
    <content type="html"><![CDATA[<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ol><li><p>排序思想</p><p>一个无序数列，从第一个数开始，循环比较相邻两个数的大小，如果前一个数大于后一个数则交换它们的位置(升序)。</p></li><li><p>示意图</p><p>一个数列：10 9 8 7 6 5 4 3 2 1</p><p><img src="http://img.3amupupup.online/BoubleSort.png" alt="冒泡排序"></p><p><img src="http://img.3amupupup.online/BubbleSort.gif" alt="冒泡排序"></p></li></ol><ol start="3"><li><p>实现</p><pre><code class="c">void BubbleSort(int* arr, int arrSize){    for (int i = 0; i &lt; arrSize-1; ++i)    {        int flag = 0;        for (int j = 0; j &lt; arrSize-i-1; ++j) // 每循环一次意味着一个最大的数被移动到了数组末尾，在下一次循环时最后一个数没必要参与比较        {            if(arr[j] &gt; arr[j+1])            {                flag = 1; // 判断循环时是否发生交换，没有发生交换则说明已经有序，直接退出。                int temp = arr[j];                arr[j] = arr[j+1];                arr[j+1] = temp;            }        }        if (!flag)            return;    }}</code></pre></li><li><p>理解</p><p>冒泡排序每迭代一次数组，最大数会被冒到最后，在下一次迭代时排除掉之前迭代冒的大数。</p><p>时间复杂度：N-1 + N-2 + …… + 1 即 O(N^2)。</p><p>空间复杂度：在排序过程中无需借助其它空间保存数据，即O(1)。</p></li></ol><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><ol><li><p>排序思想</p><p>一个无序数列，假设前n个数是有序的，依次取出n之后的数字与 n=&gt;0 进行比较，如果小于n则插入到n之前(升序)。</p></li><li><p>示意图</p><p><img src="http://img.3amupupup.online/InsertSort.png" alt="插入排序"></p><p><img src="http://img.3amupupup.online/InsertSort.gif" alt="插入排序"></p></li><li><p>实现</p><pre><code class="c">void InsertSort(int* arr, int arrSize){    for (int i = 0; i &lt; arrSize-1; ++i)    {        int end = i; // 假设 0-end是有序数列，第一次end就是0,拿arr[1]和arr[0]比较        int temp = arr[end+1]; // 选出end之后的第一个数        while (end &gt;= 0)        {            if(temp &lt; arr[end]) // 升序            {                arr[end+1] = arr[end]; // 如果temp小于arr[end]，则说明要将end往后挪一次                end--; // 然后end继续往前走,继续判断temp是否小于arr[end]            }            else            {                break; // 不小于arr[end]时直接跳出循环            }        }        arr[end+1] = temp;    }}</code></pre></li></ol><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><ol><li><p>排序思想</p><p>希尔排序是在插入排序的基础上做的优化。插入排序中，如果值大小分布越不均匀，在选择一个数与有序序列比较时需要移动end的次数会越多，序列越接近有序，需要移动end的次数就会越少。希尔排序在此基础上，将序列分成不连续多个组，然后进行插入排序，这会使得序列能更快的接近有序。直至间隔为1时就是插入排序，此时数组接近有序，效率会更高。</p></li><li><p>示意图</p><p><img src="http://img.3amupupup.online/ShellSort.png" alt="希尔排序"></p><p><img src="http://img.3amupupup.online/ShellSort.gif" alt="希尔排序"></p><p>图中，2、5、13为一组，5、3、3为一组，升序情况下：间隔越大，那么排在靠后位置的数就更加容易的被插入在数组靠前的位置，比如arr[1]=5、arr[5]=3、arr[9]=3，如果是插入排序，arr[9]=3 end需要移动6次才能使arr[9]到达靠前的位置，使用希尔排序，end移动两次就靠前了。会使数组更容易的接近有序。</p></li><li><p>实现</p><pre><code class="c">void ShellSort(int* arr, int arrSize){    int gap = arrSize;    while(gap &gt; 1)    {        gap = gap/3+1; // 2/3=0,会导致排序提前结束(gap还没等于1就结束了),所以每次给gap加上个1。        for(int i = 0;i &lt; arrSize-gap;i++)        // arrSize为什么要减去gap: 假如数组长度是10,gap第一次循环为4。        // 循环开始之后，temp的下标(也就是end+gap)不能超出数组范围即:i+gap &lt; arrsize,也就是i&lt;arrSize-gap        {            int end = i;            int temp = arr[end+gap];            while(end &gt;= 0)            {                if(temp &lt; arr[end])                {                    arr[end+gap] = arr[end];                    end-=gap;                }                else                {                    break;                }            }            arr[end+gap] = temp;        }    }}</code></pre></li></ol><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><ol><li><p>排序思想</p><p>有序数列(数组)的在内存上存储形式是线性的(一段连续的内存)，其逻辑结构是二叉树(完全二叉树)。利用这个特性可以将数组看成一个二叉树，然后进行建堆操作。（大堆的父结点大于左右孩子结点，小堆的父结点小于左右孩子结点），然后每次取出堆顶的数再重新建堆。(升序建大堆，降序建小堆)。leftChild = parent*2+1，rightChile = parent*2+2。</p></li><li><p>示意图</p><p><img src="http://img.3amupupup.online/BuildBigHeap.png" alt="建大堆"></p><p><img src="http://img.3amupupup.online/BuildArrayToHeap.png" alt="建堆完成后的效果"></p><p><img src="http://img.3amupupup.online/SortByHeap.png" alt="利用堆特性排序"></p><p><img src="http://img.3amupupup.online/HeapSort.gif" alt="堆排序"></p></li><li><p>实现</p><pre><code class="c">void Swap(int* a, int* b){    int temp = *a;    *a = *b;    *b= temp;}void AdJustDown(int* arr, int root, int arrSize) // 建堆{    int parent = root;    int child = parent*2 + 1;    while (child &lt; arrSize)    {        if (child+1 &lt; arrSize &amp;&amp; arr[child+1] &gt; arr[child])        {            child++;        }        if(arr[parent] &lt; arr[child])        {            Swap(&amp;arr[parent],&amp;arr[child]);            parent = child;            child = parent*2+1;        }        else        {            break;        }    }}void HeapSort(int* arr, int arrSize){    for (int i = (arrSize-1-1)/2; i &gt;=0 ; --i)    {        AdJustDown(arr,i,arrSize);    }    int end = arrSize-1;    while (end &gt; 0)    {        Swap(&amp;arr[end],&amp;arr[0]);        AdJustDown(arr,0,end);        end--;    }}</code></pre></li></ol><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ol><li><p>排序思想(升序)</p><p>左右两个指针left、right，取一个key值。左右开始向右向左遍历，左指针遇见比key大的数停止移动，右指针遇见比key小的数停止移动，此时交换左右指针对应的值，直到左右指针重合。此时key左边的值全比key小，右边的值全比key大。再通过分治思想对key左右两边的区间进行递归操作。</p></li><li><p>示意图</p><p><img src="http://img.3amupupup.online/QuickSortt.png" alt="快速排序"></p><p><img src="http://img.3amupupup.online/RecursionForQuickSort.png" alt="分治思想"></p><p><img src="http://img.3amupupup.online/QuickSortTime1.png" alt="时间复杂度"></p><p><img src="http://img.3amupupup.online/QuickSOrt.gif" alt="快速排序"></p></li><li><p>代码实现</p><pre><code class="c">/* * 三数取中 * 在数组有序时(假设是降序),keyIndex每次都是最小的数的下标 * 会导致快排变成一个N^2的算法,三数取中能有效避免这个缺陷。 */int GetMidIdx(int* arr ,int left, int right){    int mid = (left+right)/2;    if (arr[left] &lt; arr[mid])    {        if (arr[mid] &lt; arr[right])            return mid;        else if (arr[left] &gt; arr[right])            return left;        else            return right;    }    else    {        if (arr[mid] &gt; arr[right])            return mid;        else if (arr[left] &lt; arr[right])            return left;        else            return right;    }}int Part(int* arr, int left, int right){    int midIndex = GetMidIdx(arr,left,right); // 找出中位数    Swap(&amp;arr[midIndex],&amp;arr[right]);    int keyIndex = right;    while(left &lt; right)    {        while(left &lt; right &amp;&amp; arr[left] &lt;= arr[keyIndex]) // 因为是left先移动,所以left的最终停留位置的数一定比keyIndex大            left++;        while(left &lt; right &amp;&amp; arr[right] &gt;= arr[keyIndex])            right--;        Swap(&amp;arr[left], &amp;arr[right]); // 循环走到这里时,left位置的数比keyIndex大,right位置的数比keyIndex小,对它们进行交换    }    Swap(&amp;arr[keyIndex], &amp;arr[left]); // left最终停止的位置和keyIndex进行交换,此时left的左边全是比选出的keyIndex小的数,右边全是比keyIndex大的数。    return left; // 必须返回left,下一次排序时就可以排除掉left，对left左右的两边的数进行排序}void QuickSort(int* arr, int left, int right){    if(left &lt; right)    {        int div = Part(arr,left,right);        QuickSort(arr,left,div-1);        QuickSort(arr,div+1,right);    }}void QuickSortNoR(int* arr, int left, int right){    Stack st;    StackInit(&amp;st);    StackPush(&amp;st,left); // 注意进栈顺序,先进的后被取出来    StackPush(&amp;st,right);    while(!StackEmpty(&amp;st)) // 栈不为空说明还存在没被排序的区间则要继续循环    {        int _right = StackTop(&amp;st);        StackPop(&amp;st);        int _left = StackTop(&amp;st);        StackPop(&amp;st);        int div = Part(arr,_left,_right);        if(div+1 &lt; _right)        {            StackPush(&amp;st,div+1); // 保证入栈顺序和第一次一致            StackPush(&amp;st,_right);        }        if(_left &lt; div-1)        {            StackPush(&amp;st,_left);            StackPush(&amp;st,div-1);        }    }    StackDestory(&amp;st);}</code></pre></li></ol><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><ol><li><p>排序思想</p><p>合并有序数组</p></li><li><p>示意图</p><p><img src="http://img.3amupupup.online/MergeSort.png" alt="归并排序"></p><p><img src="http://img.3amupupup.online/MergeSortNoR.png" alt="非递归"></p><p><img src="http://img.3amupupup.online/MergeSort.gif" alt="归并排序"></p></li><li><p>实现</p><pre><code class="c">// 将数组分割成N个有序小区间(1个数的区间，一个数也算有序)，再合并有序的数组void _MergeSort(int* arr,int left, int right, int* tmp){    if(left&gt;=right) // 分割退出的条件        return;    int mid = (left+right)/2; // 拿到中间位置的索引，下一步递归分割，直到不可分为止(分割到只有一个数)    _MergeSort(arr,left,mid,tmp); // 递归分割左半边    _MergeSort(arr,mid+1,right,tmp); // 递归分割右半边    int begin1 = left, end1 = mid; // 走到这里说明已经分割完了，分成了right+1个一个元素的数组    int begin2 = mid+1, end2 = right;    int index = begin1; // tmp区间起始位置    while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) // 归并有序数组    {        if (arr[begin1] &lt; arr[begin2])        {            tmp[index++] = arr[begin1++];        }        else        {           tmp[index++] = arr[begin2++];        }    }    while (begin1&lt;=end1)        tmp[index++] = arr[begin1++];    while (begin2&lt;=end2)        tmp[index++] = arr[begin2++];    for (int i = left; i &lt;= right; ++i) // 拷贝回原数组，拷贝一定是 &lt;= 闭区间，因为right传入的是闭区间    {        arr[i] = tmp[i];    }}// 归并，递归实现void MergeSort(int* arr, int arrSize){    int* tmp = malloc(sizeof(int)*arrSize);    _MergeSort(arr,0,arrSize-1,tmp);    free(tmp);}// 归并，非递归实现void _MergeSortNoR(int* arr, int begin1, int end1, int begin2, int end2, int* tmp){    PrintArr(arr,10);    int left = begin1,right = end2; // 这里必须使用新变量记录数组的起始结束位置，因为经过迭代后begin1会自增    int index = begin1; // tmp区间起始位置    while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) // 归并有序数组    {        if (arr[begin1] &lt; arr[begin2])        {            tmp[index++] = arr[begin1++];        }        else        {            tmp[index++] = arr[begin2++];        }    }    while (begin1&lt;=end1)        tmp[index++] = arr[begin1++];    while (begin2&lt;=end2)        tmp[index++] = arr[begin2++];    for (int i = left; i &lt;= right; ++i)    {        arr[i] = tmp[i];    }}void MergeSortNoR(int* arr, int arrSize){    int* tmp = (int*)malloc(sizeof(int)*arrSize);    int gap = 1;    while (gap&lt;arrSize)    {        for (int i = 0; i &lt; arrSize; i+=2*gap)        {            // [i,i+gap-1] [i+gap, i+2*gap-1]            int begin1 = i, end1 = i+gap-1, begin2 = i+gap, end2 =i+gap*2-1;            if (begin2 &gt;= arrSize) // begin2大于等于数组长度时说明只存在一组数据(无法分割成两组)                break;            if (end2&gt;=arrSize) // end2大于等于数组长度则说明无法分割成均等的两组，end2超出了数组的范围                end2 = arrSize-1; // 所以需要调整end2的位置，使其不能超出数组范围            _MergeSortNoR(arr,begin1,end1,begin2,end2,tmp);        }        gap*=2;    }    free(tmp);}</code></pre></li></ol><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><ol><li><p>思想</p><p>记录一个序列中数字出现的次数。</p><p>找出序列中的最大值 max 然后创建一个size为max+1的tmp数组，遍历数据序列，拿序列中的值做tmp数组的下标，tmp对应下标的值进行++ 计数。遍历结束后，依次从tmp中取值拷贝到原序列中，tmp的下标作为序列的值，tmp下标对应的值作为拷贝的次数。</p></li><li><p>示意图</p><p><img src="http://img.3amupupup.online/CountSort.png" alt="计数排序"></p><p><img src="http://img.3amupupup.online/849589-20171015231740840-6968181.gif" alt="计数排序"></p></li><li><p>实现</p><pre><code class="c">void CountSort(int* arr, int arrSize){    int min = arr[0];     int max = arr[0]; // 找出最大最小的值    for (int i = 0; i &lt; arrSize; ++i)    {        if (arr[i] &gt; max)        {            max = arr[i];        }        if (arr[i] &lt; min)        {            min = arr[i];        }    }    int range = max-min+1; // 创建一个range+1大小的数组，利用相对位置存储计数，还原时tmp数组下标加上min就是原数组的值    int* countArray = (int*)malloc(sizeof(int)*range);    if (!countArray)    {        printf(&quot;malloc failed.\n&quot;);        exit(-1);    }    memset(countArray,0,sizeof(int)*range);    for (int i = 0; i &lt; arrSize; ++i)    {        countArray[arr[i]-min]++;    }    int index = 0;    for (int i = 0; i &lt; range; ++i)    {        while (countArray[i]--)        {            arr[index++] = i+min;        }    }    free(countArray);}</code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;排序思想&lt;/p&gt;
&lt;p&gt;一个无序数列，从第一个数开始，循环比较相邻两个数的大小，如果前一个数大于后一个数则</summary>
      
    
    
    
    <category term="C语言" scheme="http://blog.3amupupup.online/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="排序" scheme="http://blog.3amupupup.online/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins结合sonar代码检测流水线</title>
    <link href="http://blog.3amupupup.online/2021/03/18/Jenkins%E7%BB%93%E5%90%88sonar%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    <id>http://blog.3amupupup.online/2021/03/18/Jenkins%E7%BB%93%E5%90%88sonar%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E6%B5%81%E6%B0%B4%E7%BA%BF/</id>
    <published>2021-03-18T03:09:52.078Z</published>
    <updated>2021-03-18T03:09:52.078Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1、jenkins所需插件"><a href="#1、jenkins所需插件" class="headerlink" title="1、jenkins所需插件"></a>1、jenkins所需插件</h5><p><a href="https://plugins.jenkins.io/workflow-aggregator" target="_blank" rel="noopener">Pipeline</a>、<a href="https://plugins.jenkins.io/sonar-quality-gates" target="_blank" rel="noopener">Sonar Quality Gates Plugin</a>、<a href="https://plugins.jenkins.io/sonar" target="_blank" rel="noopener">SonarQube Scanner</a>、<a href="https://plugins.jenkins.io/generic-webhook-trigger" target="_blank" rel="noopener">Generic Webhook Trigger Plugin</a></p><h5 id="2、jenkins配置"><a href="#2、jenkins配置" class="headerlink" title="2、jenkins配置"></a>2、jenkins配置</h5><ul><li><p>Dashboard =&gt; 系统管理 =&gt; 全局工具配置</p><p><img src="/image/image-20201227165338711.png" alt="sonar scanner安装"></p></li><li><p>Dashboard =&gt; 系统管理 =&gt; 系统配置</p><p><img src="/image/image-20201227165501679.png" alt="sonarqube servers配置"></p></li></ul><p>  <img src="/image/image-20201227165627390.png" alt="token配置"></p><p>  这个token是在sonar web上生成的，然后在jenkins上创建一个secret text类型凭据。</p><p>  <img src="/image/image-20201227165828644.png" alt="gitlab"></p><p>  配置连接gitlab，要生成gitlab api token</p><p>  <img src="/image/image-20201227165956042.png" alt="获取gitlab Private token"></p><p>  生成private token。在sonar检测代码所有条件都通过时，要通过这个private token去操作gitlab的api来自动接受合并请求。</p><p>  <img src="/image/image-20201227170513752.png" alt="private token 凭据"></p><p>  生成凭据，记住这里的id 为12，一会pipeline脚本要用</p><ul><li><p>在gitlab项目下配置触发器，只勾选Merge Request Events (这个token随机生成一个就好了)</p><p><img src="/image/image-20201227170841973.png" alt="gitlab webhook"></p></li></ul><h5 id="3、pipiline脚本"><a href="#3、pipiline脚本" class="headerlink" title="3、pipiline脚本"></a>3、pipiline脚本</h5><pre><code class="pipeline">pipeline {   agent any   environment {        PrivateToken= credentials(&#39;12&#39;) // 获取private token，之前在凭据里配置过，这样比较安全，不需要在脚本里明文使用token    }   options {      gitLabConnection(&#39;gitlab&#39;)    }       triggers {        GenericTrigger(            genericVariables: [            [key: &#39;source_branch&#39;, value: &#39;$.object_attributes.source_branch&#39;], // 获取merge的源分支,只检测源分支，源分支的代码检测成功才能合并到目标分支            [key: &#39;url&#39;, value: &#39;$.object_attributes.url&#39;], // 获取gitlab merge请求的url            [key: &#39;action&#39;, value: &#39;$.object_attributes.action&#39;], // 获取merge动作 [reopen,close,open],只在reopen和open时才出发流水线检测            [key: &#39;source_project_id&#39;, value: &#39;$.object_attributes.source_project_id&#39;],            [key: &#39;iid&#39;, value: &#39;$.object_attributes.iid&#39;],            [key: &#39;name&#39;, value: &#39;$.user.name&#39;], // 获取合并请求的发起人            [key: &#39;project_name&#39;, value: &#39;$.project.name&#39;], // 或者项目名            [key: &#39;target_branch&#39;, value: &#39;$.object_attributes.target_branch&#39;], // 获取目标分支，我这里的需求是：合并到release.test分支的请求才进行质检、自动合并，所以我需要拿到这个变量            [key: &#39;object_kind&#39;, value: &#39;$.object_kind&#39;]            ],            token: &#39;fc161920aa6f1886e7417416edc85500&#39; , // 这是webhook上填写的token            causeString: &#39; Triggered on $ref&#39; ,            printContributedVariables: true,            printPostContent: true        )    }   stages {    stage(&quot;select branch&quot;){        steps{                script{                    if((env.source_branch =~ &#39;release.*&#39;).matches() || (env.action!=&quot;open&quot;  &amp;&amp; env.action!=&quot;update&quot;) || env.target_branch != &quot;release.test&quot;){ // 触发流水线检测代码的条件                        stage(&quot;exit with 0&quot;){                            ansiColor(&#39;gnome-terminal&#39;) {                                echo &quot;\033[32m Jump Sonar\n user:$name\nproject_name:$project_name\nobject_kind:$object_kind\naction:$action\nsource_branch:$source_branch\n target_branch:$target_branch \033[0m&quot;                            }                                   }                    }else{                        stage(&#39;pull branch&#39;) {                            checkout([$class: &#39;GitSCM&#39;, branches: [[name: &quot;*/$source_branch&quot;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: &#39;11&#39;, url: &#39;http://gitlab.xxxxxx.com:8888/xubin/xxxxxxxx.git&#39;]]])                        }                        stage(&#39;SonarQubeanalysis&#39;) {                                script {                                    scannerHome = tool &#39;sonar-scanner&#39;                                }                            withSonarQubeEnv(&#39;sonar&#39;) {                            sh &quot;echo ${scannerHome}&quot;                            sh &quot;${scannerHome}/bin/sonar-scanner -Dsonar.projectKey=$JOB_BASE_NAME -Dsonar.sources=./app&quot;                            }                    }                       stage(&quot;SonarQube Quality Gate&quot;) {                                    timeout(time: 1, unit: &#39;HOURS&#39;) {                                    def qg = waitForQualityGate(&#39;sonar&#39;)                                    if (qg.status != &#39;OK&#39;) {                                    echo &quot;Status: ${qg.status}&quot;                                    error &quot;Pipeline aborted due to quality gate failure: ${qg.status}&quot; // 质检没通过直接让流水线失败退出                                    }                                }                                ansiColor(&#39;gnome-terminal&#39;) {                                echo &quot;\033[32m Jump Sonar\n user:$name\nproject_name:$project_name\nobject_kind:$object_kind\naction:$action\nsource_branch:$source_branch\n target_branch:$target_branch \033[0m&quot;                            }                    }                         stage(&quot;Merge&quot;){ // 如果检测通过自动合并请求                                script{                                    httpRequest authentication: &#39;11&#39;, customHeaders: [[maskValue: false, name: &#39;PRIVATE-TOKEN&#39;, value: &quot;$PrivateToken&quot;]], httpMode: &#39;PUT&#39;, responseHandle: &#39;NONE&#39;, url: &quot;http://gitlab.xxxxxx.com:8888/api/v4/projects/$source_project_id/merge_requests/$iid/merge&quot;                                }                        }                    }                }            }        }    }}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;1、jenkins所需插件&quot;&gt;&lt;a href=&quot;#1、jenkins所需插件&quot; class=&quot;headerlink&quot; title=&quot;1、jenkins所需插件&quot;&gt;&lt;/a&gt;1、jenkins所需插件&lt;/h5&gt;&lt;p&gt;&lt;a href=&quot;https://plugins.j</summary>
      
    
    
    
    <category term="运维" scheme="http://blog.3amupupup.online/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="sonar" scheme="http://blog.3amupupup.online/tags/sonar/"/>
    
  </entry>
  
  <entry>
    <title>带环链表</title>
    <link href="http://blog.3amupupup.online/2021/03/18/%E5%B8%A6%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    <id>http://blog.3amupupup.online/2021/03/18/%E5%B8%A6%E7%8E%AF%E9%93%BE%E8%A1%A8/</id>
    <published>2021-03-18T03:09:52.077Z</published>
    <updated>2021-03-18T03:09:52.077Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、判断链表是否带环"><a href="#1、判断链表是否带环" class="headerlink" title="1、判断链表是否带环"></a>1、<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">判断链表是否带环</a></h4><h5 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h5><ol><li><p>给链表设置两个指针，slow移动一步，fast移动两步。</p><p><img src="/image/image-20201227013251253.png" alt="初始状态"></p></li><li><p>fast和slow指针都进入环之后</p><p><img src="/image/image-20201227013617501.png" alt="fast、slow进环"></p></li><li><p>fast和slow指针重合</p><p>在slow和fast都进环之后，fast开始追slow。slow移动一步，fast移动两步。</p><p><img src="/image/image-20201227014743194.png" alt="指针追赶"></p><p>每一次移动fast和slow之间的距离缩短一步，最终重合，则证明有环。如果fast指针在经过若干次移动之后为NULL(循环结束)，则说明不带环。</p><p><img src="/image/image-20201227013919844.png" alt="指针重合"></p></li><li><p>代码：</p><pre><code class="c">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     struct ListNode *next; * }; */bool hasCycle(struct ListNode *head) {    struct ListNode *slow = head;    struct ListNode *fast = head;    while(fast &amp;&amp; fast-&gt;next)    {        slow = slow-&gt;next;        fast = fast-&gt;next-&gt;next;        if (slow == fast)        {            return true;        }    }    return false;}</code></pre></li></ol><h4 id="2、带环链表的入环结点"><a href="#2、带环链表的入环结点" class="headerlink" title="2、带环链表的入环结点"></a>2、<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">带环链表的入环结点</a></h4><h5 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h5><ol><li><p>给链表设置两个指针，slow移动一步，fast移动两步。</p><p><img src="/image/image-20201227132753055.png" alt="初始状态"></p></li><li><p>slow在进入环之后，在一个C之内就会被fast追上(fast的速度是slow的两倍)。</p><p>slow走的距离是：L+X</p><p>fast走的距离是 ：L+N*C+X (如果L足够长环足够小，fast进环且绕环N次之后slow才会进入)</p><p>2*(L+X) = L+N*C+X =&gt; L = N*C -X</p><p>然后同时从head和fast位置开始遍历，找到相同的节点。</p><p><img src="/image/image-20201227154937844.png" alt="slow、fast重合"></p></li><li><p>代码：</p><pre><code class="c">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     struct ListNode *next; * }; */struct ListNode *detectCycle(struct ListNode *head) {    struct ListNode *slow = head;    struct ListNode *fast = head;    while(fast &amp;&amp; fast-&gt;next) // 遍历链表，找到slow与fast重合的点    {        slow = slow-&gt;next;        fast = fast-&gt;next-&gt;next;        if(fast == slow)        {            break;        }    }    if(!fast || !fast-&gt;next) // 判断上一步循环时因为遍历到NULL结束的还是因为 fast==slow 结束的    {        return NULL; // 如果fast或者fast-&gt;next为NULL说明链表不带环，直接返回NULL    }    while(fast &amp;&amp; head) // 遍历寻找相交结点    {        if(fast == head)        {            return fast;        }        fast = fast-&gt;next;        head = head-&gt;next;    }    return NULL;}</code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1、判断链表是否带环&quot;&gt;&lt;a href=&quot;#1、判断链表是否带环&quot; class=&quot;headerlink&quot; title=&quot;1、判断链表是否带环&quot;&gt;&lt;/a&gt;1、&lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-</summary>
      
    
    
    
    <category term="C语言" scheme="http://blog.3amupupup.online/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="数据结构" scheme="http://blog.3amupupup.online/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ECS磁盘扩容</title>
    <link href="http://blog.3amupupup.online/2021/03/18/ECS%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/"/>
    <id>http://blog.3amupupup.online/2021/03/18/ECS%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/</id>
    <published>2021-03-18T03:09:52.075Z</published>
    <updated>2021-03-18T03:09:52.076Z</updated>
    
    <content type="html"><![CDATA[<h6 id="1、通过-df-h-知根分区大小为40G。"><a href="#1、通过-df-h-知根分区大小为40G。" class="headerlink" title="1、通过 df -h 知根分区大小为40G。"></a>1、通过 df -h 知根分区大小为40G。</h6><p><img src="/image/image-20200512133700547.png" alt="image-20200512133700547"></p><h6 id="2、在阿里云后台对当前ECS实例的磁盘进行在线扩容。"><a href="#2、在阿里云后台对当前ECS实例的磁盘进行在线扩容。" class="headerlink" title="2、在阿里云后台对当前ECS实例的磁盘进行在线扩容。"></a>2、在阿里云后台对当前ECS实例的磁盘进行在线扩容。</h6><p><img src="/image/image-20200512134218782.png" alt="image-20200512134218782"></p><h6 id="3、扩容后登陆ECS使用fdisk-l查看磁盘大小，磁盘已经扩容到100G。"><a href="#3、扩容后登陆ECS使用fdisk-l查看磁盘大小，磁盘已经扩容到100G。" class="headerlink" title="3、扩容后登陆ECS使用fdisk -l查看磁盘大小，磁盘已经扩容到100G。"></a>3、扩容后登陆ECS使用fdisk -l查看磁盘大小，磁盘已经扩容到100G。</h6><p><img src="/image/image-20200512134102595.png" alt="image-20200512134102595"></p><h6 id="4、安装growpart"><a href="#4、安装growpart" class="headerlink" title="4、安装growpart"></a>4、安装growpart</h6><pre><code class="shell">[root@iZbp1e8z3uz7pmqbsis8bkZ ~]# yum -y install cloud-utils-growpartLoaded plugins: fastestmirrorbase                                                     | 3.6 kB     00:00epel                                                     | 4.7 kB     00:00extras                                                   | 2.9 kB     00:00updates                                                  | 2.9 kB     00:00(1/7): base/7/x86_64/group_gz                              | 153 kB   00:00(2/7): extras/7/x86_64/primary_db                          | 190 kB   00:00(3/7): epel/x86_64/group_gz                                |  95 kB   00:00(4/7): updates/7/x86_64/primary_db                         | 176 kB   00:00(5/7): epel/x86_64/updateinfo                              | 1.0 MB   00:00(6/7): base/7/x86_64/primary_db                            | 6.1 MB   00:00(7/7): epel/x86_64/primary_db                              | 6.8 MB   00:00Determining fastest mirrors * base: mirrors.cloud.aliyuncs.com * epel: mirrors.cloud.aliyuncs.com * extras: mirrors.cloud.aliyuncs.com * updates: mirrors.cloud.aliyuncs.comResolving Dependencies--&gt; Running transaction check---&gt; Package cloud-utils-growpart.noarch 0:0.29-5.el7 will be installed--&gt; Finished Dependency ResolutionDependencies Resolved================================================================================ Package                     Arch          Version            Repository   Size================================================================================Installing: cloud-utils-growpart        noarch        0.29-5.el7         base         27 kTransaction Summary================================================================================Install  1 PackageTotal download size: 27 kInstalled size: 61 kDownloading packages:cloud-utils-growpart-0.29-5.el7.noarch.rpm                 |  27 kB   00:00Running transaction checkRunning transaction testTransaction test succeededRunning transaction  Installing : cloud-utils-growpart-0.29-5.el7.noarch                       1/1  Verifying  : cloud-utils-growpart-0.29-5.el7.noarch                       1/1Installed:  cloud-utils-growpart.noarch 0:0.29-5.el7Complete!</code></pre><h6 id="5、扩展-dev-vda1分区（命名含义为扩展-dev-vda磁盘的第一个分区）。"><a href="#5、扩展-dev-vda1分区（命名含义为扩展-dev-vda磁盘的第一个分区）。" class="headerlink" title="5、扩展/dev/vda1分区（命名含义为扩展/dev/vda磁盘的第一个分区）。"></a>5、扩展/dev/vda1分区（命名含义为扩展/dev/vda磁盘的第一个分区）。</h6><pre><code class="shell">[root@iZbp1e8z3uz7pmqbsis8bkZ ~]# growpart /dev/vda 1CHANGED: partition=1 start=2048 old: size=83881984 end=83884032 new: size=209713119 end=209715167</code></pre><p>​     若报错unexpected output in sfdisk –version……..则运行LANG=en_US.UTF-8切换ECS实例的字符编码类型。</p><p>6、运行resize2fs <PartitionName> 命令调用resize2fs扩容文件系统。</p><pre><code class="shell">[root@iZbp1e8z3uz7pmqbsis8bkZ ~]# resize2fs /dev/vda1resize2fs 1.42.9 (28-Dec-2013)Filesystem at /dev/vda1 is mounted on /; on-line resizing requiredold_desc_blocks = 3, new_desc_blocks = 7The filesystem on /dev/vda1 is now 26214139 blocks long.[root@iZbp1e8z3uz7pmqbsis8bkZ ~]# df -hFilesystem      Size  Used Avail Use% Mounted on/dev/vda1        99G  1.5G   93G   2% /devtmpfs        487M     0  487M   0% /devtmpfs           497M     0  497M   0% /dev/shmtmpfs           497M  308K  496M   1% /runtmpfs           497M     0  497M   0% /sys/fs/cgrouptmpfs           100M     0  100M   0% /run/user/0</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;1、通过-df-h-知根分区大小为40G。&quot;&gt;&lt;a href=&quot;#1、通过-df-h-知根分区大小为40G。&quot; class=&quot;headerlink&quot; title=&quot;1、通过 df -h 知根分区大小为40G。&quot;&gt;&lt;/a&gt;1、通过 df -h 知根分区大小为40G。</summary>
      
    
    
    
    <category term="运维" scheme="http://blog.3amupupup.online/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="ecs" scheme="http://blog.3amupupup.online/tags/ecs/"/>
    
  </entry>
  
  <entry>
    <title>linux性能优化实战笔记</title>
    <link href="http://blog.3amupupup.online/2021/03/18/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.3amupupup.online/2021/03/18/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-18T03:09:52.075Z</published>
    <updated>2021-03-18T03:09:52.075Z</updated>
    
    <content type="html"><![CDATA[<h4 id="01、平均负载"><a href="#01、平均负载" class="headerlink" title="01、平均负载"></a>01、平均负载</h4><p>平均负载：系统出于可运行状态<font size=2 color=red>（正在使用cpu或者正在等待cpu的进程，也就是ps命令看到的Running 或 Runnable状态的进程）</font>和不可中断状态<font size=2 color=red>（进程正在处于内核态关键流程中的进程，这些流程是不可打断的，例如等待硬件设备的I/O响应，也就是ps命令看到的D状态。比如，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程就处于不可中断状态。如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。所以，不可中断状态实际上是系统对进程和硬件设备的一种保护机制。）</font>的平均进程数，也就是平均活跃进程数。</p><pre><code class="shell">#观察进程的cpu使用情况，间隔一秒输出一次pidstat  -u 1#观察cpu使用情况，观察各状态占比mpstat -P ALL  1</code></pre><h4 id="02、CPU-上下文切换"><a href="#02、CPU-上下文切换" class="headerlink" title="02、CPU 上下文切换"></a>02、CPU 上下文切换</h4><p>CPU 寄存器：是 CPU 内置的容量小、但速度极快的内存。</p><p>程序计数器：则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。</p><p>它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做 CPU 上下文。</p><p>CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p><p>上下文切换情景：</p><p>① 系统调用，cpu寄存器里原来用户态的指令位置，需要先保存起来，接着为了执行内核态的代码，cpu寄存器需要更新为内核态指令的最新位置，最后才是跳转到内核态运行内核任务，系统调用结束后cpu需要恢复到原来保存的用户态，继续运行进程。so，一次系统调用发生了两次cpu上下文切换。（<font size=2 color=red>系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的</font>）</p><p>进程上下文切换，是指从一个进程切换到另一个进程运行。而系统调用过程中一直是同一个进程在运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;01、平均负载&quot;&gt;&lt;a href=&quot;#01、平均负载&quot; class=&quot;headerlink&quot; title=&quot;01、平均负载&quot;&gt;&lt;/a&gt;01、平均负载&lt;/h4&gt;&lt;p&gt;平均负载：系统出于可运行状态&lt;font size=2 color=red&gt;（正在使用cpu或者正在等</summary>
      
    
    
    
    <category term="运维" scheme="http://blog.3amupupup.online/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="linux性能优化实战笔记" scheme="http://blog.3amupupup.online/tags/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>一次海外k8s集群代码发布实践</title>
    <link href="http://blog.3amupupup.online/2021/03/18/%E4%B8%80%E6%AC%A1%E6%B5%B7%E5%A4%96k8s%E9%9B%86%E7%BE%A4%E4%BB%A3%E7%A0%81%E5%8F%91%E5%B8%83%E5%AE%9E%E8%B7%B5/"/>
    <id>http://blog.3amupupup.online/2021/03/18/%E4%B8%80%E6%AC%A1%E6%B5%B7%E5%A4%96k8s%E9%9B%86%E7%BE%A4%E4%BB%A3%E7%A0%81%E5%8F%91%E5%B8%83%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-03-18T03:09:52.074Z</published>
    <updated>2021-03-18T03:09:52.074Z</updated>
    
    <content type="html"><![CDATA[<p>项目背景：要上一个海外版的小说平台，gitlab在国内，当前是要求在海外搭建一个测试环境(php代码)</p><h3 id="第一阶段："><a href="#第一阶段：" class="headerlink" title="第一阶段："></a>第一阶段：</h3><p>话不多说，在香港买了台机器，down了个oneinstack脚本装环境，环境具体为mysql+redis+php-fpm7.1.3+nginx。</p><p>jenkins+gitlab都是在国内，也没多想直接在jenkins创建了一个工程，使用ssh-server插件将构建好的代码push到香港机器。问题来了，因为机器是在香港，在jenkins push代码的时候巨慢无比，每一次发布起码花费十分钟以上的时间，严重影响开发效率。</p><h3 id="第二阶段："><a href="#第二阶段：" class="headerlink" title="第二阶段："></a>第二阶段：</h3><p>想到了用容器的方式发布，思路是这样：在杭州机器上将镜像构建好，然后push到香港仓库去，因为镜像push的时候会进行压缩，另外push到香港仓库之后那边机器拉取代码的速度会大大提升，缩短了发布时间（这是为以后生产发布做考虑，代码同步慢，有些文件更新有些文件没更新可能会造成线上报错的）。于是开始构建基础镜像，编写<a href="http://127.0.0.1:4000/2020/07/28/Dockerfile/" target="_blank" rel="noopener">Dockerfile</a>。</p><p>编写dockerfile：①保证镜像精简 ②尽量减少镜像的层数，将底层环境固定。</p><p>nginx和php-fpm基础镜像构建完成后使用jenkins进行打包代码到镜像里，使用的pipeline脚本。</p><p>第二阶段使用的是docker compose，因此每一次更新都需要登录香港机器手动拉取并更新镜像，比较麻烦，所以很快就放弃了这种方式</p><h3 id="第三阶段："><a href="#第三阶段：" class="headerlink" title="第三阶段："></a>第三阶段：</h3><p>考虑使用k8s，于是在香港买了个k8s集群，两个2c4g的节点，外加一台2c4g的机器作为数据库机器（redis+mysql），后续正式上线之后再考虑扩容。</p><p>问题：</p><p>​    1、nginx容器和php-fpm容器需要共享代码才能正常提供服务。</p><p>​    解决：首先想到的是每次发布构建两个镜像，即将代码分别拷贝进nginx和php容器，然后通过deployment去运行，但是这种方法太麻烦，因为没次都需要重新更新php和nginx容器，这两个镜像的体积加起来差不多有800M了，所以不考虑这种方式。</p><p>​                于是使用了deployment控制器中的volume —- emptydir共享卷，代码使用一个initcontainer拷贝进去。这样的话我每次只需要更新initcontainer(initcontainer不需要什么环境，使用的busybox，基础镜像才几M，加上代码也就30M左右，这样的话大大提高了镜像构建、推送、拉取的速度)。</p><p>使用pipeline构建代码容器：</p><pre><code class="yaml">pipeline {   agent any   stages {      stage(&#39;pull code&#39;) {         steps {            checkout([$class: &#39;GitSCM&#39;, branches: [[name: &#39;*/test&#39;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: &#39;11&#39;, url: &#39;http://xxxxx.xxxxxxx.com/xxxxx/xxxxxxx_api.git&#39;]]])         }      }      stage(&#39;build image&#39;){          steps {              sh &#39;wget http://172.16.72.173/leshuapi/.dockerignore -O .dockerignore&#39;              sh &#39;wget http://172.16.72.173/leshuapi/Dockerfile -O Dockerfile&#39;              sh &#39;sudo docker build -t registry.cn-hongkong.aliyuncs.com/ysg_codebox/$JOB_BASE_NAME:latest .&#39;          }      }      stage(&#39;push image&#39;){          steps {              timeout(time: 3, unit: &#39;MINUTES&#39;){                  retry(5) {                      sh &#39;docker push registry.cn-hongkong.aliyuncs.com/ysg_codebox/$JOB_BASE_NAME:latest&#39;                  }              }          }      }   }}</code></pre><p>deployment.yaml内容如下：</p><pre><code class="yaml">---apiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: leshuapispec:  replicas: 2  template:    metadata:      labels:        app: leshuapp    spec:      dnsPolicy: Default      shareProcessNamespace: true      imagePullSecrets:        - name: regsecret      initContainers:      - name: copycode        #代码容器        image: registry.cn-hongkong.aliyuncs.com/ysg_codebox/xxxxxxxxx:latest        imagePullPolicy: Always        command: [&quot;mv&quot;,&quot;/data/wwwroot/&quot;,&quot;/data/www/&quot;]        volumeMounts:        - name: www          mountPath: /data/www      - name: chown        image: registry.cn-hongkong.aliyuncs.com/ysg_baseimage/xxxxbox:v2        imagePullPolicy: IfNotPresent        command: [&quot;chown&quot;,&quot;-R&quot;,&quot;www.www&quot;,&quot;/data/www/&quot;]        volumeMounts:        - name: www          mountPath: /data/www      containers:        - name: nginx          image: registry.cn-hongkong.aliyuncs.com/ysg_baseimage/nginx:v3          imagePullPolicy: IfNotPresent          securityContext:            capabilities:              add:              - SYS_PTRACE          stdin: true          tty: true          resources:            requests:              memory: 200Mi              cpu: 100m            limits:              memory: 300Mi              cpu: 200m          ports:            - containerPort: 80          livenessProbe:            tcpSocket:              port: 80          command: [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]          volumeMounts:            - name: www              mountPath: /data/www            - name: logs              mountPath: /data/logs/            - name: nginx-conf              mountPath: /etc/nginx/conf.d/            - name: env              mountPath: /data/www/wwwroot/env/        - name: php-fpm          image: registry.cn-hongkong.aliyuncs.com/ysg_baseimage/php-fpm:v2          imagePullPolicy: IfNotPresent          securityContext:            capabilities:              add:              - SYS_PTRACE          stdin: true          tty: true          resources:            requests:              memory: 200Mi              cpu: 100m            limits:            memory: 300Mi              cpu: 200m          ports:            - containerPort: 9000          livenessProbe:            tcpSocket:              port: 9000          command: [&quot;/usr/local/php/sbin/php-fpm&quot;,&quot;-F&quot;]          volumeMounts:            - name: www              mountPath: /data/www            - name: logs              mountPath: /data/logs/            - name: phpfpm-conf              mountPath: /usr/local/php/etc/php-fpm.d/            - name: env              mountPath: /data/www/wwwroot/env/      volumes:      - name: www        emptyDir: {}      - name: logs        emptyDir: {}      - name: nginx-conf        configMap:          name: leshuapi-nginx-conf          items:           - key: server.conf             path: server.conf      - name: phpfpm-conf        configMap:          name: leshuapi-phpfpm-conf          items:           - key: www.conf             path: www.conf      - name: env        configMap:          name: leshuapi-env          items:           - key: .env             path: .env---apiVersion: v1kind: Servicemetadata:  name: leshuapiservicespec:  ports:  - protocol: TCP    port: 80    targetPort: 80  selector:    app: leshuapp</code></pre><p>镜像里的项目配置文件、nginx配置文件、php-fpm的配置文件全部通过configmap挂载出来方便修改，具体yaml省略。</p><p>配置文件结构：</p><p><img src="/image/image-20201016181209870.png" alt="image-20201016181209870"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;项目背景：要上一个海外版的小说平台，gitlab在国内，当前是要求在海外搭建一个测试环境(php代码)&lt;/p&gt;
&lt;h3 id=&quot;第一阶段：&quot;&gt;&lt;a href=&quot;#第一阶段：&quot; class=&quot;headerlink&quot; title=&quot;第一阶段：&quot;&gt;&lt;/a&gt;第一阶段：&lt;/h3&gt;&lt;p</summary>
      
    
    
    
    <category term="k8s" scheme="http://blog.3amupupup.online/categories/k8s/"/>
    
    
    <category term="cicd" scheme="http://blog.3amupupup.online/tags/cicd/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://blog.3amupupup.online/2021/03/18/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://blog.3amupupup.online/2021/03/18/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-03-18T03:09:52.073Z</published>
    <updated>2021-03-18T03:09:52.073Z</updated>
    
    <content type="html"><![CDATA[<h6 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h6><ol><li><p>示意图</p><p><img src="http://img.3amupupup.online/FullBinaryTree.png" alt="满二叉树"></p><p><img src="http://img.3amupupup.online/wanquanBinaryTree.png" alt="完全二叉树"></p></li><li><p>性质</p><ol><li>一个二叉树，如果每一层的结点个数都达到最大值则就是满二叉树。也就是说一个深度为k的二叉树，如果结点总数是(2^k)-1则是满二叉树。</li><li>前k-1层结点个数都是满的(达到最大个数)，最后一层可以不满，但是必须从左到右连续，称为完全二叉树。(满二叉树是特殊的完全二叉树)</li><li>若规定根结点的层数为1，则一棵非空二叉树的第i层至多有2^(i-1)个结点。</li><li>任何一颗二叉树，度为0的结点个数比度为2的结点个数多1。</li><li>对于有N个结点的满二叉树，二叉树的高度 h=log<sub>2</sub><sup>N+1</sup>。</li><li>对于有N个结点的完全二叉树，二叉树的高度 h=log<sub>2</sub><sup>N</sup>+1。</li></ol></li></ol><h6 id="二叉树的顺序存储。"><a href="#二叉树的顺序存储。" class="headerlink" title="二叉树的顺序存储。"></a>二叉树的顺序存储。</h6><ol><li><p>示意图</p><p><img src="http://img.3amupupup.online/BinaryTreeStorageInArray1.png" alt="image-20210125135822359"></p></li><li><p>父亲结点下标是i，则左孩子结点下标为2*i+1、右孩子结点下标</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h6&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;示意图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.3amupupup.online/FullBina</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>sonar</title>
    <link href="http://blog.3amupupup.online/2021/03/18/sonar/"/>
    <id>http://blog.3amupupup.online/2021/03/18/sonar/</id>
    <published>2021-03-18T03:09:52.072Z</published>
    <updated>2021-03-18T03:09:52.073Z</updated>
    
    <content type="html"><![CDATA[<pre><code>gitlabBranchgitlabSourceBranchgitlabActionTypegitlabUserNamegitlabUserUsernamegitlabUserEmailgitlabSourceRepoHomepagegitlabSourceRepoNamegitlabSourceNamespacegitlabSourceRepoURLgitlabSourceRepoSshUrlgitlabSourceRepoHttpUrlgitlabMergeRequestTitlegitlabMergeRequestDescriptiongitlabMergeRequestIdgitlabMergeRequestIidgitlabMergeRequestStategitlabMergedByUsergitlabMergeRequestAssigneegitlabMergeRequestLastCommitgitlabMergeRequestTargetProjectIdgitlabTargetBranchgitlabTargetRepoNamegitlabTargetNamespacegitlabTargetRepoSshUrlgitlabTargetRepoHttpUrlgitlabBeforegitlabAftergitlabTriggerPhrase</code></pre><pre><code class="java">pipeline {   agent any   stages {      stage(&#39;pull code&#39;) {         steps {            checkout([$class: &#39;GitSCM&#39;, branches: [[name: &#39;*/release.test&#39;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: &#39;11&#39;, url: &#39;http://xxxx.xxxxxx.com:8888/xxxx/xxxxxx.git&#39;]]])         }      }      stage(&#39;SonarQube&#39;) {            steps{                sh &quot;sonar-scanner -X -Dsonar.host.url=http://172.16.72.182:8888/ -Dsonar.language=php -Dsonar.projectVersion=$BUILD_NUMBER -Dsonar.sources=./app -Dsonar.sourceEncoding=UTF-8  -Dsonar.projectName=$JOB_BASE_NAME -Dsonar.projectKey=$JOB_BASE_NAME -Dsonar.login=a65d0c254cfxx2ax013bcxe93xb8xg13f25b2407&quot;         }      }  }}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code&gt;gitlabBranch
gitlabSourceBranch
gitlabActionType
gitlabUserName
gitlabUserUsername
gitlabUserEmail
gitlabSourceRepoHomepage
gitla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://blog.3amupupup.online/2021/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://blog.3amupupup.online/2021/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2021-03-18T03:09:52.072Z</published>
    <updated>2021-03-18T03:09:52.072Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络</p><h5 id="三种交换方式："><a href="#三种交换方式：" class="headerlink" title="三种交换方式："></a>三种交换方式：</h5><table><thead><tr><th>交换方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>电路交换</td><td>通信时延小(比特流直达终点)<br />有序传输<br />没有冲突<br />使用范围广(模拟信号、数字信号)<br />实时性强<br />控制简单</td><td>建立连接时间长<br />线路独占，使用效率低<br />灵活性差<br />难以规格化</td></tr><tr><td>报文交换</td><td>无需建立连接(不需要为通信双方事先建立一条专用的通信线路，不存在建立连接的时延。)<br />动态分配线路<br />提高线路可靠性<br />提高线路利用率<br />提供多目标服务</td><td>引起了转发时延<br />需要较大的存储缓存空间<br />需要传输额外的信息量(报头要携带目标地址、源地址等信息)<br /></td></tr><tr><td>分组交换</td><td>无需建立连接<br />线路利用率高<br />简化了存储管理<br />加速传输<br />减少出错概率和重传数据量</td><td>引起了转发时延<br />需要传输额外的信息量<br />对于数据报服务，存在失序、丢失或重复分组的问题；对于虚电路服务，存在呼叫建立、数据传输和虚电路释放三个过程</td></tr></tbody></table><h5 id="计算机网络的定义和分类"><a href="#计算机网络的定义和分类" class="headerlink" title="计算机网络的定义和分类"></a>计算机网络的定义和分类</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;计算机网络&lt;/p&gt;
&lt;h5 id=&quot;三种交换方式：&quot;&gt;&lt;a href=&quot;#三种交换方式：&quot; class=&quot;headerlink&quot; title=&quot;三种交换方式：&quot;&gt;&lt;/a&gt;三种交换方式：&lt;/h5&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;交换方式&lt;/th&gt;
&lt;th&gt;优</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统</title>
    <link href="http://blog.3amupupup.online/2021/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>http://blog.3amupupup.online/2021/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-03-18T03:09:52.071Z</published>
    <updated>2021-03-18T03:09:52.072Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第九章：虚拟内存"><a href="#第九章：虚拟内存" class="headerlink" title="第九章：虚拟内存"></a>第九章：虚拟内存</h3><h6 id="1、什么是虚拟内存？"><a href="#1、什么是虚拟内存？" class="headerlink" title="1、什么是虚拟内存？"></a>1、什么是虚拟内存？</h6><p>虚拟内存是磁盘上(较低层)连续N个字节组成的数组，每个字节都有唯一的虚拟地址作为数组的索引，磁盘上数组的内容被缓存在主存中。(虚拟页存在于磁盘上)</p><p>物理内存被分隔成物理页(Physical Page,PP)。</p><p>VM系统将虚拟内存分隔成虚拟页(Virtual Page,VP)，虚拟页面的集合分为三个不相交的子集：</p><ol><li>未分配的(VM系统还未分配或者未创建的页，未分配的块没有任何数据和他们相关联，因为不占用任何磁盘空间)。</li><li>缓存的(已缓存在物理内存中的已分配页)。</li><li>未缓存的(未缓存在物理内存中的已分配页)。</li></ol><h6 id="2、DRAM缓存组织结构"><a href="#2、DRAM缓存组织结构" class="headerlink" title="2、DRAM缓存组织结构"></a>2、DRAM缓存组织结构</h6><ul><li>SRAM：表示位于cpu和主存之间的L1、L2、L3高速缓存。</li><li>DRAM：表示虚拟内存系统的缓存，它在主存中缓存虚拟页。</li><li>直   写：当 CPU 要将数据写入内存时 除了更新缓冲内存(高速缓存L1、L2、L3)上的数据外也将数据写在 DRAM 中 以维持主存与缓冲内存的一致性 当要写入内存的数据一多 速度自然就慢了下来 </li><li>回   写：每当 CPU 要将数据写入内存时 只会先更新缓冲内存(高速缓存L1、L2、L3)上的数据 随后再让缓冲内存在总线不塞车的时候 才把数据写回 DRAM 所以速度自然快得多</li></ul><h6 id="3、页表"><a href="#3、页表" class="headerlink" title="3、页表"></a>3、页表</h6><p>虚拟内存必须有某种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页(主存)。如果不命中还必须判断这个虚拟页存放在磁盘的哪个位置上，在物理页中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页。(操作系统为每个进程都维护一个独立的页表)</p><p>页表：将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表，操作系统负责维护页表的内容，以及在磁盘与DRAM之间来回传送页。</p><p><img src="/image/image-20201020134441586.png" alt="image-20201020134441586"></p><p>我们将假设每个PTE是由一个有效位(valid bit)和一个n位地址字段组成，有效位表明了该虚拟页当前是否被缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。 如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。否则，这个地址就指向该虚拟页在磁盘上的起始位置。</p><h6 id="4、缺页"><a href="#4、缺页" class="headerlink" title="4、缺页"></a>4、缺页</h6><p>DRAM缓存不命中称为缺页。</p><p>自己的理解：在cpu获取虚拟页中的数据时，地址翻译硬件去读页表的页表记录的有效位，如果有效位为0则推断出该虚拟页未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会在主存的PP(物理页)中选择一个被缓存的VP作为牺牲页，接下来将要缓存的vp从磁盘中加载出来缓存到主存上去(替换牺牲页)。</p><p><img src="/image/image-20201020140133328.png" alt="image-20201020140133328"></p><h6 id="5、地址翻译"><a href="#5、地址翻译" class="headerlink" title="5、地址翻译"></a>5、地址翻译</h6><p>当页面命中时，CPU硬件执行的步骤：</p><ol><li>处理器生成一个虚拟地址，并把它传送给MMU。</li><li>MMU生成PTE地址，并从高速缓存/主存请求得到它。</li><li>高速缓存/主存向MMU返回PTE。</li><li>MMU构造物理地址，并把它传给告诉缓存/主存。</li><li>高速缓存/主存返回所请求的数据字给处理器。</li></ol><p><img src="/image/image-20201020145055727.png" alt="image-20201020145055727"></p><p>缺页，CPU硬件执行步骤：</p><ol><li>处理器生成一个虚拟地址，并把它传送给MMU。</li><li>MMU生成PTE地址，并从高速缓存/主存请求得到它。</li><li>高速缓存/主存向MMU返回PTE。</li><li>PTE中的有效为是0，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。</li><li>缺页处理程序确定出物理内存中的牺牲页，如果这个页面修改了则把它换出到磁盘。</li><li>缺页处理程序页面调入新的页面，并更新内存中的PTE。</li><li>缺页处理程序返回到原来的进程，再次执行导致缺页的指令，CPU将引起缺页的虚拟地址重新发送给MMU。</li></ol><p><img src="/image/image-20201020145822292.png" alt="image-20201020145822292"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;第九章：虚拟内存&quot;&gt;&lt;a href=&quot;#第九章：虚拟内存&quot; class=&quot;headerlink&quot; title=&quot;第九章：虚拟内存&quot;&gt;&lt;/a&gt;第九章：虚拟内存&lt;/h3&gt;&lt;h6 id=&quot;1、什么是虚拟内存？&quot;&gt;&lt;a href=&quot;#1、什么是虚拟内存？&quot; class=&quot;</summary>
      
    
    
    
    <category term="C语言" scheme="http://blog.3amupupup.online/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="虚拟内存" scheme="http://blog.3amupupup.online/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记</title>
    <link href="http://blog.3amupupup.online/2021/03/18/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.3amupupup.online/2021/03/18/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-18T03:09:52.070Z</published>
    <updated>2021-03-18T03:09:52.071Z</updated>
    
    <content type="html"><![CDATA[<p>AX = AH + AL</p><p>BX = BH + BL</p><p>CX = CH + CL</p><p>DX = DH + DL</p><p>数据寄存器</p><p>段地址寄存器：偏移地址寄存器</p><p>DS    SP</p><p>ES    BP</p><p>SS    SI</p><p>CS    DI</p><p>​         IP(和指令有关)</p><p>​         BX</p><p>u指令：将内存某个地址开始的字节全部当做指令</p><p>d指令：将某个内存地址开始的字节全部当做数据</p><p>指令和数据在内存中是没有区别的</p><p>cpu中的cs段地址寄存器和ip这个偏移地址寄存器组合的时候，从中读取的内容当作指令来执行</p><p>指令是有长度的，一条指令可以由多个字节构成</p><p>执行过程：</p><p>1、cpu从cs:ip所指向的内存单元读取指令，存放到指令缓存器中</p><p>2、ip = ip+所读指令的长度，从而指向下一条指令</p><p>3、执行指令缓存器中的内容，毁到步骤1</p><p>汇编指令 jmp</p><p>转移指令，可以修改cs和ip这两个寄存器 决定了cpu从哪里读取指令</p><p>debug调试工具：</p><ul><li><p>r：可以查看和改变寄存器中的内容</p><p><img src="/Users/duwei/Desktop/source/image/image-20201102234009082.png" alt="image-20201102234009082"></p><p><img src="/Users/duwei/Desktop/source/image/image-20201102234134627.png" alt="image-20201102234134627"></p></li><li><p>d：可以查看内存中的内容</p><p><img src="/Users/duwei/Desktop/source/image/image-20201102234450730.png" alt="image-20201102234450730"></p></li></ul><ul><li><p>u：可以将内存中的机器指令翻译成汇编指令 u:地址</p><p><img src="/Users/duwei/Desktop/source/image/image-20201102234935752.png" alt="image-20201102234935752"></p></li><li><p>a：向内存写入一条汇编指令</p><p><img src="/Users/duwei/Desktop/source/image/image-20201102235151996.png" alt="image-20201102235151996"></p></li><li><p>t：执行当前cs:ip所指向的机器指令</p></li><li><p>e：可以改写内存中的内容</p><p><img src="/Users/duwei/Desktop/source/image/image-20201102235637216.png" alt="image-20201102235637216"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;AX = AH + AL&lt;/p&gt;
&lt;p&gt;BX = BH + BL&lt;/p&gt;
&lt;p&gt;CX = CH + CL&lt;/p&gt;
&lt;p&gt;DX = DH + DL&lt;/p&gt;
&lt;p&gt;数据寄存器&lt;/p&gt;
&lt;p&gt;段地址寄存器：偏移地址寄存器&lt;/p&gt;
&lt;p&gt;DS    SP&lt;/p&gt;
&lt;p&gt;ES    </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>进程</title>
    <link href="http://blog.3amupupup.online/2021/03/18/%E8%BF%9B%E7%A8%8B/"/>
    <id>http://blog.3amupupup.online/2021/03/18/%E8%BF%9B%E7%A8%8B/</id>
    <published>2021-03-18T03:09:52.070Z</published>
    <updated>2021-03-18T03:09:52.070Z</updated>
    
    <content type="html"><![CDATA[<h4 id="fork"><a href="#fork" class="headerlink" title="fork:"></a>fork:</h4><p>fork()函数man手册：</p><ul><li>fork函数通过调用它的进程复制出一个新的进程(谁调用它复制谁，准确说是共享（比如代码段），对于私有数据采用写时复制机制)。</li><li>子进程的父进程id与父进程相同</li><li>子进程不继承父进程的内存锁</li><li>子进程的资源利用率和cpu使用时间计数会被置0。</li><li>子进程信号集为空(进程运行过程中收到的信号都会保存在一个集合中)。</li><li>子进程不继承父进程的信号量(引自百度百科：<a href="https://baike.baidu.com/item/信号量/9807501" target="_blank" rel="noopener">信号量</a>的值与相应资源的使用情况有关，当它的值大于 0 时，表示当前可用的资源数的数量；当它的值小于 0 时，其绝对值表示等待使用该资源的进程个数。信号量的值仅能由 PV 操作来改变。)</li><li>子进程不继承父进程的记录锁(The child does not inherit record locks from its parent (fcntl(2)))</li><li>子进程不继承父进程的计时器。</li></ul><p>fork调用的一个奇妙之处就是它仅仅被调用一次但是返回两次：</p><p><img src="http://img.3amupupup.online/do_fork.png" alt="do_fork"></p><p>为什么能返回两次：父进程创建子进程时，子进程共享父进程上下文，其中上下文包含程序计数器，它里面存储的是程序要执行的下一条cpu指令。程序执行到return之前，子进程已完成创建，并且通过wake_up_new_task函数将子进程添加到可调度队列中去了，此时子进程共享父进程的程序计数器，它们的程序计数器里的指令都指向tracehook_report_clone_complete函数，因此当子进程拿到cpu时，会从tracehook_report_clone_complete开始执行直至return。因此调用fork函数会有两次返回，一次是父进程中另一次是在子进程中。</p><p>函数，当子进程拿到cpu时，会执行程序计数器中的指令即return，所以fork函数会返回两次，一次是在父进程中，一次是在子进程中)。</p><p>它可能有三种不同的返回值：</p><ol><li>在父进程中，fork()返回新创建的子进程的pid。</li><li>在子进程中，fork()返回0。</li><li>如果fork()出现错误，返回一个负值。</li></ol><p>在fork函数执行完毕之后，如果创建进程成功，则出现两个进程，一个是子进程一个是父进程。在父进程中返回新创建子进程的pid，在子进程中返回0，可以通过fork返回值判断当前进程是父进程还是子进程。</p><p>另外根据程序的输出信息：父进程中的age结果为-1，子进程中的age为1，但是age的地址在父子进程中相同。父进程和子进程共享内存，但是不共享私有数据，使用了写时复制的机制。但是pid不同(现阶段认知)。内存地址相同但是值却不相同，这里需要学习一下操作系统-虚拟内存。这里解释下：虽然父子进程中的age的内存地址相同，但是他们彼此独立不可见，虚拟内存地址相同但是它们各自对应的物理地址不相同。</p><pre><code class="c">#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    int age = 0;    int pid;    pid = fork();    if(pid &lt; 0)    {        printf(&quot;fork() error.\n)&quot;);        exit(-1);    }    else if (pid == 0)    {        age++;        printf(&quot;I am child and my pid = %d, age = %d, addr = %p\n&quot;,getpid(),age,&amp;age);    }    else if (pid &gt; 0)    {        age--;        printf(&quot;I am parent and my Pid=%d, age = %d, addr = %p\n&quot;,getpid(),age,&amp;age);    }    return 0;}// 编译执行结果：// I am parent and my Pid=13086, age = -1, addr = 0x7fffc4e4dc98// I am child and my pid = 13087, age = 1, addr = 0x7fffc4e4dc98</code></pre><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><h4 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h4><p>pid_t waitpid(pid_t pid, int *statusp, int options);</p><p>当options=0时，waitpid挂起调用进程的执行，直到它的等待集合中的一个进程终止；如果这个集合中的一个进程在刚调用的时刻就已经终止，那么waitpid立即返回。</p><ol><li><p>判定等待集合的成员</p><p>等待集合的成员是由 pid 参数决定的：</p><ol><li>pid &gt; 0 ，等待的集合就是一个单独的子进程，它的进程id等于pid。</li><li>pid = -1，那么等待就是父进程的所有子进程组成的集合中的任意子进程。</li><li>pid &lt; -1，回收进程组id为abs(pid)的一组进程，也就是所有子进程。</li><li>pid = 0，回收 与调用进程组id相同组内的子进程。</li></ol></li><li><p>修改默认行为</p><ul><li><p>0</p><p>与wait基本没有区别。</p></li><li><p>WNOHANG</p><p>如果等待集合中的任何子进程都没有终止，那么立即返回(返回值为0)，如果有子进程退出返回退出子进程的pid，失败返回-1(没有子进程或者子进程死光了)。在等待子进程终止的同时如果想做其它事情，这个选项很有用。</p><pre><code class="c">#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(){    int status;    int pid;    pid = fork();    if(pid == 0)    {        printf(&quot;I&#39;m child.\n&quot;);        sleep(3);        exit(0);    }    while((pid = waitpid(-1,&amp;status,WNOHANG)) &gt; 0)    {        printf(&quot;child exit.\n&quot;);    }    printf(&quot;I&#39;m parent.\n&quot;);    return 0;}// 使用 WNOHANG 父进程不会等待自己成退出，所以执行效果是: 父进程、子进程执行各自的代码，父进程执行完毕之后退出，因为子进程sleep(3)，所以子进程在输出打印之后三秒钟退出。</code></pre></li><li><p>WUNTRACED</p><p>挂起调动进程的执行，直到等待集合中的一个进程变成已终止或者停止。返回的pid为导致返回的已终止或被停止子进程的pid。默认的行为是只返回已终止子进程。在想要检查已终止或已停止的子进程时，这个选项比较有用。</p><pre><code class="c">#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(){    int status;    int pid;    pid = fork();    if(pid == 0)    {        printf(&quot;child run and pid = %d\n&quot;,getpid());        printf(&quot;I&#39;m child.\n&quot;);        sleep(3);        exit(0);    }    while((pid = waitpid(-1,&amp;status,WUNTRACED)) &gt; 0)    {        printf(&quot;child exit who pid = %d.\n&quot;,pid);    }    printf(&quot;I&#39;m parent.\n&quot;);    return 0;}// root$ ./a.out// child run and pid = 26334// I&#39;m child.// child exit who pid = 26334.// I&#39;m parent.</code></pre></li><li><p>WCONTINUED</p><p>挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或者等待集合中一个被停止的进程收到SIGCONT信号重新开始执行。</p></li><li><p>组合使用：WNOHANG | WUNTRACED</p><p>立即返回，如果等待集合中的子进程都没有停止或者终止则返回0，如果有一个停止或者终止则返回该子进程的pid。</p></li></ul></li><li><p>检查已回收子进程的退出状态</p><p><img src="http://img.3amupupup.online/childProcessStatus.png" alt="waitpid() status参数"></p><p>如果statusp参数是非空的，那么操作系统就会读取进程的PCB，保存在status指向的变量中。</p><p>status中保存的就是进程退出的信息，int是32bit，是否正常运行，退出码是多少，退出信号是多少。</p><pre><code class="c">#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    int status = 0;    pid_t id = fork();    if(id &lt; 0)    {        perror(&quot;fork error!\n&quot;);    }    else if(id == 0) // child    {        printf(&quot;i am child process\n&quot;);        int count = 0;        while (count &lt; 5)        {            sleep(1);            count++;            printf(&quot;sleep 1\n&quot;);        }//        int ret = 1/0;//        exit(99);        exit(0);    }    // parent    printf(&quot;father wait before.\n&quot;);    pid_t ret = waitpid(id,&amp;status,0);    printf(&quot;status = %d\n&quot;,status); // 保存子进程的返回状态    if(ret &gt; 0)    {        printf(&quot;子进程终止信号: %d\n&quot;, status &amp; 0x7f); // 0 表示是正常退出        printf(&quot;子进程退出码: %d\n&quot;,(status &gt;&gt; 8) &amp; 0xff);        printf(&quot;wait success!\n&quot;);        if(status &amp; 0x7f) // 非0则说明子进程不是正常退出的        {            printf(&quot;child run error!\n&quot;);        }        else        {            if((status&gt;&gt;8) &amp; 0xff) // 运行成功但是结果不正确            {                printf(&quot;child run success, but result is not right, exit code: %d\n&quot;,(status&gt;&gt;8)&amp;0xff);            }            else            {                printf(&quot;child run success and result is right,exit code: %d\n&quot;,(status&gt;&gt;8)&amp;0xff);            }        }    }    else    {        printf(&quot;wait failed!\n&quot;);    }    printf(&quot;father wait after.\n&quot;);    return 0;}</code></pre><p><img src="http://img.3amupupup.online/WaitpidStatus.png" alt="image-20210202163458393"></p><p>图中在子进程sleep的时候给其发送了一个SIGSTOP信号导致子进程退出，status中保存的是子进程终止的状态信息。</p><p>标准库中也提供一些宏函数来检测进程的退出状态：</p><ol><li><p>WIFEXITED(status): 如果为正常子进程终止子进程的返回状态，则为真。(查看子进程是否正常退出：! (status &amp; 0x7f))</p></li><li><p>WEXITSTATUS(status): 如果WIFEXITED(status)为非零，提取子进程退出码。(查看子进程退出码: (status&gt;&gt;8)&amp;0xff))</p><pre><code class="c">#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    int status = 0;    pid_t id = fork();    if(id &lt; 0)    {        perror(&quot;fork error!\n&quot;);    }    else if(id == 0) // child    {        printf(&quot;i am child process\n&quot;);        int count = 0;        while (count &lt; 3)        {            sleep(1);            count++;            printf(&quot;sleep 1\n&quot;);        }        int ret = 1/0;        exit(10);    }    // parent    printf(&quot;father wait before.\n&quot;);    pid_t ret = waitpid(id,&amp;status,0);    printf(&quot;status = %d\n&quot;,status); // 保存子进程的返回状态    if(WIFEXITED(status)) // 为真说明是正常退出的    {        printf(&quot;child exit code: %d\n&quot;,WEXITSTATUS(status));    }    else    {        printf(&quot;child exit error!\n&quot;);    }    printf(&quot;father wait after.\n&quot;);    return 0; }</code></pre></li></ol></li></ol><h4 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h4><h5 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h5><pre><code class="c">#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/wait.h&gt;int main(){    int fd[2];     pipe(fd); // fd[1]是写端，fd[0]是读端    int pid = fork();    if(pid == 0)    {        sleep(3);        write(fd[1],&quot;hello world\n&quot;,13);    }    else if(pid &gt; 0)    {        waitpid(-1,NULL,0);        char buf[20]={0};        int ret = read(fd[0],buf,sizeof(buf)); // read会阻塞等待        if(ret&gt;0)            write(STDOUT_FILENO,buf,ret);    }    return 0;}</code></pre><p>管道大小</p><ul><li><pre><code class="shell">[root@iZbp11u8qxiwepq15dm1liZ ComputerSystem]# ulimit -acore file size          (blocks, -c) 0data seg size           (kbytes, -d) unlimitedscheduling priority             (-e) 0file size               (blocks, -f) unlimitedpending signals                 (-i) 6946max locked memory       (kbytes, -l) 64max memory size         (kbytes, -m) unlimitedopen files                      (-n) 65535pipe size            (512 bytes, -p) 8POSIX message queues     (bytes, -q) 819200real-time priority              (-r) 0stack size              (kbytes, -s) 8192cpu time               (seconds, -t) unlimitedmax user processes              (-u) 6946virtual memory          (kbytes, -v) unlimitedfile locks                      (-x) unlimited</code></pre><p>可以看到在linux系统上pipe size 为512bytes * 8 = 4096bytes。</p></li></ul><p>优点：简单</p><p>缺点：</p><ul><li>只能有血缘关系的进程之间才能使用</li><li>只能单向通信(半双工通信)，如果需要双向通信需要创建两个管道</li></ul><h5 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h5><p>有名管道，实现无血缘关系进程通信。</p><ul><li><p>创建一个管道的伪文件</p><ul><li>int mkfifo(const char *pathname, mode_t mode);</li><li>mkfifo fifoName 命令创建</li></ul></li><li><p>内核会给fifo文件开辟一个缓冲区，操作fifo文件，可以操作缓冲区，实现进程通信–实际上就是文件读写</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#define FIFO &quot;/root/ComputerSystem/myfifo&quot; // shell: mkfifo myfifoint main(){    int fd = open(FIFO,O_WRONLY); // 如果没有程序 read，open会阻塞    char buf[256];    int num = 1;    while(1)       {        memset(buf,0x00,sizeof(buf));        sprintf(buf,&quot;hello%d&quot;,num++);        write(fd,buf,strlen(buf));        sleep(1);    }    close(fd);    return 0;}//  若无读端写端open阻塞</code></pre><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int main(){    int fd = open(&quot;myfifo&quot;,O_RDONLY);    char buf[256];    int num = 1;    while(1)       {        int ret = read(fd,buf,sizeof(buf));        if(ret &gt; 0)        {            printf(&quot;read:%s\n&quot;,buf);        }    }    close(fd);    return 0;}//  若无写端读端阻塞，有点类似golang里的无缓冲channel</code></pre><p>linux系统上通过命令：man 7 signal 查看信号的手册</p><p><img src="http://img.3amupupup.online/SignalAction.png" alt="signal"></p><p><img src="http://img.3amupupup.online/fifo.png" alt="fifo"></p><p>若读端关闭，写端也会终止。至于为什么会关闭，如下解释：</p><p>执行写端程序时，open函数打开管道文件 myfifo，由于没有读端，所以写端会阻塞住。当执行读端程序之后 open停止阻塞 继续向下执行开始往管道里写数据。当关闭读端时，操作系统发送 sigpipe 信号给写端。由图可知 sigpipe 是一个Term(terminate)信号，所以写端程序终止退出。</p></li></ul><h5 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;fork&quot;&gt;&lt;a href=&quot;#fork&quot; class=&quot;headerlink&quot; title=&quot;fork:&quot;&gt;&lt;/a&gt;fork:&lt;/h4&gt;&lt;p&gt;fork()函数man手册：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fork函数通过调用它的进程复制出一个新的进程(谁调用它复制谁，</summary>
      
    
    
    
    <category term="C语言" scheme="http://blog.3amupupup.online/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="进程" scheme="http://blog.3amupupup.online/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C深入剖析</title>
    <link href="http://blog.3amupupup.online/2021/03/18/C%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/"/>
    <id>http://blog.3amupupup.online/2021/03/18/C%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/</id>
    <published>2021-03-18T03:09:52.069Z</published>
    <updated>2021-03-18T03:09:52.070Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>定义和声明</p><ul><li><p>定义：编译器创建一个对象，为这个对象分配一块内存并给它取一个名字，名字就是我们常说的变量或对象名。</p><pre><code class="c">int a;</code></pre></li><li><p>声明：告诉编译器，这个名字已经匹配到一块内存上了；告诉编译器，这个名字预定了，其它地方不能再使用，这种声明的最典型例子就是声明一个函数；声明不会分配内存。</p><pre><code class="c">extern inn a;void func(int a);    //声明一个函数</code></pre></li></ul></li><li><p>struct</p><pre><code class="c">#include &lt;stdio.h&gt;struct stu{} s1;int main(){    printf(&quot;%lu\n&quot;,sizeof(s1)); // 0    return 0;}// 编译器gcc</code></pre></li><li><p>柔性数组</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct{    int a;    int b[];} soft_arr;int main(){    printf(&quot;%lu\n&quot;,sizeof(soft_arr)); // 4    soft_arr *p = malloc(sizeof(soft_arr)+sizeof(int));    free(p);    return 0;}</code></pre><p>结构中最后一个成员允许是一个未知大小的数组，这个成员叫做柔性数组。sizefo 返回这种类型的大小不包括柔性数组的内存。包含柔性数组成员的结构用malloc进行内存动态分配。(应用：比如网络通信，收发数据包)</p></li><li><p>union</p><pre><code class="c">union Person{    char *name;    int age;    char *addr;    double balance;};int main(){    printf(&quot;%lu\n&quot;,sizeof(union Person));    return 0;}</code></pre><p>union维护足够的空间来置放多个成员的某一个成员，而不是为每个数据成员配置空间。在union中所有成员公用一个空间，同一时间只能存储其中一个数据成员，所有数据成员拥有相同的起始地址。</p><p>一个union需要配置足够的空间来容纳所有成员。上述例子中：double占用内存空间最大，所以Person的内存大小是8字节。</p><p>大小端对union的影响：</p><pre><code class="c">union T{    char a;    int b;};int main(){    union T t1;    t1.b = 1;    printf(&quot;%d\n&quot;,t1.a);    return 0;}</code></pre><img src="https://upload-images.jianshu.io/upload_images/15150075-33c893aeed324c98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" style="zoom:67%;" /></li><li><p>enum</p><pre><code class="c">enum Color{    RED,    BLACK,    WHITE,    YELLOW,};int main(){    RED = 3; // expression is not assignable    return 0;}</code></pre></li><li><p>auto</p><p>编译器在默认缺省的情况下，所有变量都是auto。</p></li><li><p>register</p><p>请求编译器尽可能的将这个变量存在cpu内部的寄存器中而不是通过内存寻址访问。register变量可能不存放在内存中，所以不能用&amp;符取地址。</p></li><li><p>static</p><ul><li>修饰变量。<ul><li>变量分局部变量和全局变量，被static修饰它们都存在于内存的静态区。</li><li>静态全局变量：作用域仅限于变量被定义的文件中。</li><li>局部静态变量：只能在定义这个局部静态变量的函数使用，即使函数调用结束，这个变量也不会消失。</li></ul></li><li>修饰函数。<ul><li>函数前加static称为静态函数，静态不是指存储方式，而是此函数的作用域仅限于本文件内。</li></ul></li></ul></li><li><p>switch</p><pre><code class="c">int main(){    int a = 4;    int c=6;    switch (a) {        case 1:            printf(&quot;1\n&quot;);            break;        default:            printf(&quot;default\n&quot;);        case 2:            printf(&quot;2\n&quot;);        case 3:            printf(&quot;3\n&quot;);//        case c:   // error//            printf(&quot;%d&quot;,c);//            break;//        case 3.14:    // error//            printf(&quot;3.14\n&quot;);    }}// output:// default// 2// 3</code></pre><ul><li>case后只能是整形或字符型常量或常量表达式</li></ul></li><li><p>End0</p></li><li><p>0x01&lt;&lt;2+3</p><p>结果为32，+的优先级比&lt;&lt;高。</p><p>左移右移的位数不能大于数据的长度，不能小于0。</p></li><li><p>++i、i++</p><pre><code class="c">int main(){    int i = 0;    int j = (++i,++i,++i);      // ++i 先自增再进它其他运算。i在遇见逗号之后认为本计算单位已经结束，然后进行自增。    printf(&quot;j = %d\n&quot;,j);       // 3    int k = 0;    int z = (k++,k++,k++);      // i++ 先进行其它运算再自增    printf(&quot;z = %d\n&quot;,z);       // 2    int x = 0;    int y = (x++) + (x++) + (x++);    printf(&quot;y = %d\n&quot;,y);       // 1+1+1=3 x遇到分号之后才认为本次计算单位已结束，x这时候才会进行自加}</code></pre></li><li><p>++i+++i+++i</p><pre><code class="c">int main(){    int a = 1;    int b = 2;    int ret = a+++b;            // 贪心算法：a++ + b    printf(&quot;ret = %d\n&quot;,ret);   // ret = 3}</code></pre></li><li><p>#define宏定义注释符号</p><pre><code class="c">#define BSC //#define BMC /*#define EMC */int main(){    int a = 10;BSC a is int    DMC input a number:EMC}</code></pre><p>注释先于预处理指令被处理。当发生宏替换时，注释已经处理完毕，再出现//、/*则会出现错误。</p></li><li><p>宏定义中的空格</p><pre><code class="c">#define SUM(x) (x)+(x)int main(){    int ret = SUM (3);    return 0;}</code></pre><p>这个空格仅在定义的时候有效，在使用这个宏函数的时候，空格会被忽略掉。因此：SUM(x) 和SUM (x)是一样的。</p><pre><code class="shell">duweideMacBook-Pro:test duwei$ cat test.c#define SUM(x) (x)+(x)int main(){    int ret = SUM (3);    return 0;}duweideMacBook-Pro:test duwei$ gcc -E test.c -o test.iduweideMacBook-Pro:test duwei$ cat test.i# 1 &quot;test.c&quot;# 1 &quot;&lt;built-in&gt;&quot; 1# 1 &quot;&lt;built-in&gt;&quot; 3# 361 &quot;&lt;built-in&gt;&quot; 3# 1 &quot;&lt;command line&gt;&quot; 1# 1 &quot;&lt;built-in&gt;&quot; 2# 1 &quot;test.c&quot; 2</code></pre></li></ul><p>  int main(){<br>   int ret = (3)+(3);<br>   return 0;<br>  }<br>  duweideMacBook-Pro:test duwei$</p><pre><code>- 预处理余下部分暂时省略，以后回来看- 略- 略- 略- int *p = NULL和 *p = NULL的区别  - ```c    int *p = NULL;    ```    定义一个指针变量p，其指向的内存里面保存的是int类型的数据，在定义变量p的同时把p的值设为0x00000000，这个过程叫初始化，是在编译的时候进行的。  - ```c    int *p;    *p = NULL;    ```    第一行代码，定义了一个指针变量p，其指向内存里保存的是int类型的数据，此时p变量本身是多少不可知，也就是说p变量此时指向的内存地址可能是个非法值。第二行代码给*p赋值为NULL，也就是给 *p指向的内存赋值NULL。由于p变量的内存地址可能是非法的，所以在调试时编译器可能会报错。- ```c  int main(){      char *p1 = &quot;abcdef&quot;;      printf(&quot;p1 = %p\n&quot;,p1);         // p1 = 0x109002f82      printf(&quot;p1 = %p\n&quot;,p1+1);       // p1 = 0x109002f82      printf(&quot;p1 = %p\n&quot;,p1+2);       // p1 = 0x109002f82      printf(&quot;&amp;p1 = %p\n&quot;,&amp;p1);       // &amp;p1 = 0x7ffee6bfda48      char p2[] = &quot;123456&quot;;      printf(&quot;p2 = %p\n&quot;,p2);         // p2 = 0x7ffee6bfda41      printf(&quot;&amp;p2 = %p\n&quot;,p2+1);      // &amp;p2 = 0x7ffee6bfda42      printf(&quot;&amp;p2 = %p\n&quot;,p2+2);      // &amp;p2 = 0x7ffee6bfda43  }</code></pre><p>  <img src="https://upload-images.jianshu.io/upload_images/15150075-95496cd76b42207b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="p1的访问方式"></p><p>  <img src="https://upload-images.jianshu.io/upload_images/15150075-586f59dc81a1ece9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="p2的访问方式"></p><p>  结论：</p><ul><li>数组名即为数据本身</li><li>数组作为参数传递给函数时，数组的地址赋值给形参，发生降维。</li></ul><ul><li><p>a和&amp;a的区别(数组名)</p><pre><code class="c">int main(){    int a[5] = {1,2,3,4,5};    int *ptr = (int *)(&amp;a+1);    printf(&quot;*(a+1)=%d\n*(ptr-1))=%d\n&quot;,*(a+1),*(ptr-1));    // *(a+1)=2，*(ptr-1))=5}</code></pre><p>结论：</p><ul><li>&amp;a代表的是数组地址，&amp;a+1，加上的是sizeof(a)，指向a[4]的下一个元素。</li><li>a代表的是首元素地址。</li></ul></li><li><p>定义为数组，声明为指针</p><pre><code class="c">int arr[3] = {1,2,3};int main(){    extern int *arr;}</code></pre><p>将arr声明为指针会造成访问方式的错误，得出意外的结果。本应该是直接读取到arr的内存地址然后进行偏移操作，但是这里声明为指针，导致了访问方式的改变，访问时会先读取arr所在内存空间存放的内存地址，然后再进行偏移操作。</p></li><li><p>定义为指针，声明为数组</p><pre><code class="c">char *p = &quot;abcd&quot;;int main(){    extern char p[];}</code></pre><p>也会因为定义和声明的方式不一样造成访问方式不一样从而得到意外的结果。</p></li><li><p>指针和数组对比</p><table><thead><tr><th>指针</th><th>数组</th></tr></thead><tbody><tr><td>保存数据的地址，任何被存入指针变量p的数据都会被当做地址处理。p本身的地址有编译器另外存储，存储在哪里我们并不知道。</td><td>保存数据，数组名a代表的是数组首元素的地址而不是数组的首地址，&amp;a才是整个数组的首地址。a本身的地址由编译器另外存储，存储在哪里，我们并不知道。</td></tr><tr><td>间接访问数据，首先取得指针变量p的内容，把它当做地址，然后从这个地址提取或者写入数据。指针可以以指针的形式访问*(p+i)；也可以以下标的方式访问p[i]。但是其本质都是先取p的内容然后加上 i * sizeof(类型)个byte作为数据的真正地址。</td><td>直接访问数据，数组名a是整个数组的名字，数组内每个元素并没有名字。只能通过”具名+匿名”的方式来访问其它某个元素，不能把数组当做一个整体来进行读写操作。数组可以以指针的形式访问*(pa+i)；也可以以下标的方式访问a[i]。但其本质都是a所代表的数组的首元素地址加上 i * sizeof(类型)个byte作为数据的真正地址。</td></tr><tr><td>通常用于动态数据结构</td><td>通常用于存储固定数目且数据类型相同的元素</td></tr><tr><td>相关函数malloc和free</td><td>隐式分配和删除</td></tr><tr><td>通常指向匿名数据（也可指向具名数据）</td><td>自身即为数组名</td></tr></tbody></table></li><li><p>地址强制转换</p><pre><code class="c">int main(){    int a[4] = {1,2,3,4};    int *ptr1 = (int *)(&amp;a+1);    int *ptr2 = (int *)((int)a+1);    printf(&quot;ptr1[-1] = %x\n&quot;,ptr1[-1]);    printf(&quot;*ptr2 = %x\n&quot;,*ptr2);    return 0;}</code></pre><p>32位系统下：</p><p><img src="https://upload-images.jianshu.io/upload_images/15150075-c638b8896fc9d3be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>64位系统下会报错：Segmentation fault</p><p>个人看法：a代表的是首元素地址，将其强转成int然后+1再强转成int<em>，即将a地址进行+1操作然后赋值给ptr2。在32位下指针的长度和 int\</em> 类型的长度相同，所以不会发生提升。但是在64位下，将4位的int* 提升为8位的地址会发生提升，提升后的地址远远大于当前数组所有元素的地址，所以在进行printf访问打印时会报错：Segmentation fault。</p></li><li><p>&amp;p[4][2] - &amp;a[4][2] 等于多少？</p><pre><code class="c">int main(){    int a[5][5];    int(*p)[4];    p = a;    printf(&quot;%p,%d\n&quot;,&amp;p[4][2] - &amp;a[4][2],&amp;p[4][2] - &amp;a[4][2]);}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/15150075-59a8fe82de0a6d11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" 是"></p></li><li><p>无法向一个函数传递数组</p><ul><li>C语言中，当一维数组作为函数参数时，编译器总把它解析成一个指向其首元素地址的指针。</li><li>函数本身没有类型，只有函数的返回值才有类型。</li></ul></li><li><p>能否把指针变量本身传递给一个函数</p><p>main函数中的变量不是全局变量，只不过是它的声明周期和全区变量一样长而已。全局变量定义在函数外部。</p></li><li><p>函数指针的定义</p><pre><code class="c">char* (*func1)(char* p1, char* p2);</code></pre><p>func1是一个指针变量，指向一个有两个char*类型参数且返回值是char*类型的函数</p></li><li><p>*(int*)&amp;p</p><pre><code class="c">// 32位void Function(){    printf(&quot;Call Function.\n&quot;);}int main(){    void (*p)();    *(int*)&amp;p = (int)Function;    (*p)();    return 0;}</code></pre><p>p是一个指针变量，指向一个无参数无返回值的函数；</p><p>(int*)&amp;p将p的地址强转成int数据类型的指针；</p><p>*(int*)&amp;p 就是一个整型，要将函数Function的地址赋值给p得先将其转为整型。</p></li><li><p>(*(void(*)())0)();</p><p>void(*)()：表示一个指针，指向一个返回值时void且没有参数的函数。</p><p>(void(*)())0：表示将0强制转换成void(*)()这个函数指针类型。</p><p>(*(void(*)())0)：获取地址0开始的内存中的一段内容(解引用)。</p><p>(*(void(*)())0)()：函数调用。</p></li><li><p>函数指针数组</p><pre><code class="c">char* (*pf1)(char *p);        // pf1是一个指向参数是char *类型，返回值时char*的函数的指针char* (*pf2[3])(char *p);    // pf2是函数指针数组</code></pre><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;char * func1(char *p){    printf(&quot;%s\n&quot;,p);    return p;}char * func2(char *p){    printf(&quot;%s\n&quot;,p);    return p;}char * func3(char *p){    printf(&quot;%s\n&quot;,p);    return p;}int main(){    char *(*pf[3])(char *);    pf[0]=func1;    pf[1]=func2;    pf[2]=func3;    pf[0](&quot;func1&quot;);    pf[1](&quot;func2&quot;);    pf[2](&quot;func3&quot;);    return 0;}</code></pre></li><li><p>函数指针数组的指针</p><pre><code class="c">char* (*pf2[3])(char *p);    // pf2是函数指针数组char* (*(*pf2)[3])(char *p);    // pf2是函数指针数组指针</code></pre></li><li><p>常见内存错误以及对策</p><ul><li><p>指针没有指向一块合法的内存</p><ul><li><p>结构体成员指针未初始化</p><pre><code class="c">struct student{    char *name;    int score;}stu,*pstu;int main(){    strcpy(stu.name,&quot;jim&quot;);    stu.score=99;    return 0;}</code></pre><p>在实例化stu时，给name分配了四字节的内存，但并没有指向合法的地址。调用strcpy往所指向的内存拷贝”jim”，这块内存name指针根本就无权访问，导致出错。</p><pre><code class="c">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;struct student{    char *name;    int score;}stu,*pstu;int main(){    stu.name = (char*)malloc(sizeof(char));    strcpy(stu.name,&quot;jim&quot;);    stu.score=99;    printf(&quot;%s\n&quot;,stu.name);    free(pstu);    return 0;}</code></pre></li><li><p>没有为结构体指针分配足够的内存</p></li><li><p>函数入口校验</p><pre><code class="c">assert(NULL!=p); // 是一个宏而非函数</code></pre></li></ul></li><li><p>为指针分配的内存太小</p></li><li><p>内存分配成功，但未初始化</p><pre><code class="c">int i = 10;char *p = (char *)malloc(sizeof(char));//在不确定变量初始值的时候可以初始化为0或者NULLint i = 0;char *p = NULL;//或者使用memset(起始地址,要被设置的值,要被设置的内存大小);int a[10];memset(a,0,sizeof(a));</code></pre></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义和声明&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义：编译器创建一个对象，为这个对象分配一块内存并给它取一个名字，名字就是我们常说的变量或对象名。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int a;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    <category term="C语言" scheme="http://blog.3amupupup.online/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="book" scheme="http://blog.3amupupup.online/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>CppPrimer</title>
    <link href="http://blog.3amupupup.online/2021/03/18/CppPrimer/"/>
    <id>http://blog.3amupupup.online/2021/03/18/CppPrimer/</id>
    <published>2021-03-18T03:09:52.068Z</published>
    <updated>2021-03-18T03:09:52.068Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第七章-类"><a href="#第七章-类" class="headerlink" title="第七章 类"></a>第七章 类</h4><p>类作用域和成员函数：</p><p>编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体(如果有的话)。因此，成员函数体可以随意使用类中的其它成员而无需在意这些成员出现的次序。</p><p>IO类属于不能被拷贝的类型，因此只能通过引用传递。</p><p>每个类都分别定义了它的对象被初始化的方式，类通过一个或者几个特殊的成员函数来控制其对象的初始化过程，被称为构造函数。构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。</p><p>构造函数不能被声明成const，当创建一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。</p><p>如果类没有显示的定义构造函数，那么编译器就会为我们隐式的定义一个默认构造函数。</p><p>某些类不能依赖于合成的默认构造函数：</p><ol><li>只有当类没有声明任何构造函数时，编译器才会自动的生成默认构造函数。</li><li>合成的默认构造函数有可能执行错误的操作。如果定义在块中的内置类型或符合类型(比如数组和指针)的对象被默认初始化，则他们的值将是未定义的。该准则同样适用于默认初始化的内置类型成员。因此，函数内置类型或者复合类型成员的类应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数。否则，用户在创建类对象时就可能得到未定义的值。</li><li>编译器不能为某些类合成默认的构造函数。例如：一个类中包含另一个类类型的成员且这个成员没有默认构造函数。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;第七章-类&quot;&gt;&lt;a href=&quot;#第七章-类&quot; class=&quot;headerlink&quot; title=&quot;第七章 类&quot;&gt;&lt;/a&gt;第七章 类&lt;/h4&gt;&lt;p&gt;类作用域和成员函数：&lt;/p&gt;
&lt;p&gt;编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体(如果有的话)。因此</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mongo</title>
    <link href="http://blog.3amupupup.online/2021/03/18/mongo/"/>
    <id>http://blog.3amupupup.online/2021/03/18/mongo/</id>
    <published>2021-03-18T03:09:52.068Z</published>
    <updated>2021-03-18T03:09:52.069Z</updated>
    
    <content type="html"><![CDATA[<h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><h6 id="mongo备份-mongoexport导出json文件"><a href="#mongo备份-mongoexport导出json文件" class="headerlink" title="mongo备份: mongoexport导出json文件"></a>mongo备份: mongoexport导出json文件</h6><pre><code class="shell">./mongoexport --host 0.0.0.0:65535 -u username -p password --authenticationDatabase admin -d database -c collection -o file.json</code></pre><h6 id="mongo恢复-mongoimport导入json文件"><a href="#mongo恢复-mongoimport导入json文件" class="headerlink" title="mongo恢复: mongoimport导入json文件"></a>mongo恢复: mongoimport导入json文件</h6><pre><code class="shell">./mongoimport --host 0.0.0.0:65535 -u username -p password  --authenticationDatabase admin  -d database -c collection --file file.json</code></pre><h6 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合:"></a>创建集合:</h6><pre><code class="sql">db.createCollection()</code></pre><h6 id="查看库信息"><a href="#查看库信息" class="headerlink" title="查看库信息:"></a>查看库信息:</h6><pre><code class="sql">db.stats();</code></pre><h6 id="查看集合信息"><a href="#查看集合信息" class="headerlink" title="查看集合信息:"></a>查看集合信息:</h6><pre><code class="sql">db.collection.stats()</code></pre><hr><h5 id="mongo遇见的一些问题"><a href="#mongo遇见的一些问题" class="headerlink" title="mongo遇见的一些问题"></a>mongo遇见的一些问题</h5><h6 id="删除数据，磁盘空间不释放"><a href="#删除数据，磁盘空间不释放" class="headerlink" title="删除数据，磁盘空间不释放:"></a>删除数据，磁盘空间不释放:</h6><p><code>db.collection.remove({}, {multi: true})</code>命令删除文档，删除之后不会将被删除数据的磁盘空间归还给操作系统，但是当有新数据插入时mongo能重新使用这块空间。(<a href="https://help.aliyun.com/document_detail/96530.html?spm=a2c4g.11186623.2.13.6cd05d5dLZVLZJ" target="_blank" rel="noopener">解决办法</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h5&gt;&lt;h6 id=&quot;mongo备份-mongoexport导出json文件&quot;&gt;&lt;a href=&quot;#mongo备份-mongoexpor</summary>
      
    
    
    
    <category term="运维" scheme="http://blog.3amupupup.online/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="mongodb" scheme="http://blog.3amupupup.online/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>tcp:ip</title>
    <link href="http://blog.3amupupup.online/2021/03/18/tcp:ip/"/>
    <id>http://blog.3amupupup.online/2021/03/18/tcp:ip/</id>
    <published>2021-03-18T03:09:52.067Z</published>
    <updated>2021-03-18T03:09:52.067Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h4><h5 id="1-2-分层"><a href="#1-2-分层" class="headerlink" title="1.2 分层"></a>1.2 分层</h5><p>tcp/ip通常被认为是一个四层协议系统：</p><ol><li><p>链路层</p><p>也称作数据链路层或网络接口层。通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或者任何传输介质）的物理接口细节。</p></li><li><p>网络层</p><p>也称为互联网层，处理分组在网络中的活动。网络层IP提供一种不可靠的服务，它只是尽可能的快地把数据包从源结点送到目的结点，但是并不提供任何可靠性保证。TCP在不可靠的IP层上提供了一个可靠的运输层（TCP采用超时重传、发送和接收端的确认分组等机制）。ICMP是IP协议的附属协议，IP层用它来与其它主机或路由器交换错误报文和其它重要信息。</p></li><li><p>运输层</p><p>为两台主机上的应用提供端到端的通信。TCP/IP协议族中有两个互不相同的传输协议：tcp（传输控制协议）和udp（用户数据报协议）。虽然TCP使用不可靠的IP服务，但是它缺提供一种可靠的运输层服务。UDP是不可靠的，它不能保证数据安全无误的到达最终目的地。</p></li><li><p>应用层</p><p>负责处理特定的应用程序细节。</p></li></ol><h5 id="1-4-互联网的地址"><a href="#1-4-互联网的地址" class="headerlink" title="1.4 互联网的地址"></a>1.4 互联网的地址</h5><p>A、B、C类为商用</p><p><img src="../../../Desktop/source/image/image-20210207235709211.png" alt="五类互联网地址"></p><h5 id="1-6-封装"><a href="#1-6-封装" class="headerlink" title="1.6 封装"></a>1.6 封装</h5><p><img src="../../../Desktop/source/image/image-20210208000359450.png" alt="数据在协议栈中的封装"></p><h5 id="1-7-分用"><a href="#1-7-分用" class="headerlink" title="1.7 分用"></a>1.7 分用</h5><p><img src="../../../Desktop/source/image/image-20210208000627638.png" alt="分用过程"></p><h5 id="1-9-端口号"><a href="#1-9-端口号" class="headerlink" title="1.9 端口号"></a>1.9 端口号</h5><p>TCP和UDP采用16bit位的端口号来识别应用程序。</p><p>客户端通常对它使用的端口号并不关心，只需要保证使用的端口号在本机是唯一就行了。客户端端口号又称临时端口号。</p><h4 id="第二章-链路层"><a href="#第二章-链路层" class="headerlink" title="第二章 链路层"></a>第二章 链路层</h4><p>链路层主要有三个目的：</p><ul><li>为IP模块接受和发送数据报</li><li>为ARP模块发送ARP请求和接受ARP应答</li><li>为RARP发送RARP请求和接受RARP应答</li></ul><h5 id="2-7-环回接口"><a href="#2-7-环回接口" class="headerlink" title="2.7 环回接口"></a>2.7 环回接口</h5><p>使运行在同一台主机上的客户端程序和服务端程序能投通过TCP/IP进行通信。一个传给环回接口的IP数据报不能在任何网络上出现。</p><h4 id="第三章-IP"><a href="#第三章-IP" class="headerlink" title="第三章 IP"></a>第三章 IP</h4><h5 id="3-2-IP首部"><a href="#3-2-IP首部" class="headerlink" title="3.2 IP首部"></a>3.2 IP首部</h5><h4 id=""><a href="#" class="headerlink" title=""></a><img src="../../../Desktop/source/image/image-20210207155438038.png" alt="IP报头"></h4><p>版本号字段：协议版本号，当前是ipv4。</p><p>首部长度字段：4个比特位，能表示范围是0~15，每个长度单位为4字节，所以首部的最大长度为60字节。</p><p>TOS:</p><p>总长度字段：整个ip数据报的长度（以字节为单位，该字段长为16个比特，由此可知该字段表示的数值范围是0~65535，也说明一个ip报文的最大长度是65535字节）。利用首部长度字段和总长度字段就可以知道ip数据报中数据内容的起始位置和长度（首部长度+1 ， 总长度-首部长度）。</p><p>标识字段：</p><p>标志字段：唯一标识主机发送的每一份数据报，通常每发送一次报文它的值就会增加1。</p><p>片偏移字段：</p><p>TTL生存时间字段：表示数据报可以经过的最多路由器数。TTL通常由源主机设置（32或64），经过一个处理它的路由器，ttl的值就减去1，当该字段为0时，数据报被丢弃，并发送ICMP报文通知源主机。</p><p>协议字段：</p><p>首部校验和字段：根据ip首部计算的校验和码（不对首部后面的数据进行计算）</p><p>选项字段：以32bit作为界限，有必要的时候插入0作为填充字节，以保证IP首部始终是32bit的整数倍</p><h5 id="3-3-路由选择"><a href="#3-3-路由选择" class="headerlink" title="3.3 路由选择"></a>3.3 路由选择</h5><p>IP路由选择是简单的，特别对于主机来说，如果目的主机与源主机直接相连或者都在一个共享网络上（以太网或者令牌环网），那么IP数据就直接发送到目的主机上。否则，主机把数据报发往默认的路由器上，由路由器转发该数据报。</p><p>IP层在内存中存在路由表。当收到一份数据报并进行转发时，都要对该表进行搜索。当数据报来自某个网络接口时，IP首先检查目的IP地址是否为本机的IP地址之一或者IP广播地址。如果是，数据报就会被送到由IP首部协议字段所指定的协议模块进行处理。如果不是且IP层被设置为路由器的功能那么就对数据报进行转发，否则数据报被丢弃。</p><h6 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h6><ul><li><p>目的IP地址(Destination)</p><p>可以是一个完整的主机地址，也可以是一个网络地址。图中第一条是默认规则(0.0.0.0)，仅当只有一条可用路径时才匹配。</p></li><li><p>下一站（下一跳）路由器的IP地址，下一站路由器是指一个直接相连的网络上的路由器，通过它可以转发数据报。</p></li><li><p>标志</p></li><li><p>为数据报的传输指定一个网络接口。</p></li></ul><h6 id="IP路由选择功能"><a href="#IP路由选择功能" class="headerlink" title="IP路由选择功能"></a>IP路由选择功能</h6><ol><li>搜索路由表，寻找与目的IP地址完全匹配的表目（网络号和主机号都要匹配）。</li><li>搜索路由表，寻找能与目的网络号匹配的表目。如果找到则把报文发送给该表目指定的下一跳路由器或者直接连接的网络接口。</li><li>搜索路由表，寻找标志为“默认（default）”的表目，如果找到，则把报文发送给改表目指定的下一跳路由器。</li><li>完整的主机地址匹配在网络号匹配之前执行。只有当他们都失败后才会选择默认路由。</li><li>为网络指定一个路由器，而不必为每一个主机都指定一个路由器，可以极大缩小路由表的规模。</li></ol><h5 id="3-4-子网寻址"><a href="#3-4-子网寻址" class="headerlink" title="3.4 子网寻址"></a>3.4 子网寻址</h5><p><img src="../../../Desktop/source/image/image-20210208163443250.png" alt="子网寻址"></p><p>所有主机都要求支持子网编址。不再是把IP地址看成单纯的一个网络号和一个主机号组成，而是把主机号再分成一个子网号和一个主机号。原因：A类和B类地址为主机号分配了太多空间，A类：2<sup>24</sup>-2（24位主机号:2<sup>24</sup>，全0和全1是无效的，所以减去2），B类：2<sup>16</sup>-2，事实上一个网络安排不了这么多主机。</p><p>例如上图中的B类地址：可以将主机号划分为8bit的子网号，8bit的主机号。也就是说将网络号是140.252的IP地址划分为254个子网，每个子网可以有254台主机。</p><h5 id="3-5-子网掩码"><a href="#3-5-子网掩码" class="headerlink" title="3.5 子网掩码"></a>3.5 子网掩码</h5><p>子网掩码用于确定IP地址中多少比特位用于子网号多少比特位用于主机号。</p><p>掩码是一个32bit的值，其中值为1的留给网络号和子网号，为0的比特留给主机号。</p><pre><code class="txt">10101100 00010000 00000000 00000000 IP网段: 172.16.0.011111111 11111111 00000000 00000000 掩码: 1610101100 00010000 00000000 00000000 IP网段: 172.16.16.011111111 11111111 11110000 00000000 掩码: 20</code></pre><p>给定IP地址和子网掩码之后，主机就可以确定IP数据报的目的地是：</p><ol><li>本子网上的主机</li><li>本网络中其它子网上的主机</li><li>其它网络上的主机</li></ol><h4 id="第六章-ICMP"><a href="#第六章-ICMP" class="headerlink" title="第六章 ICMP"></a>第六章 ICMP</h4><p>ICMP报文是在IP数据报内部被传输的。</p><p><img src="../../../Desktop/source/image/image-20210208204348894.png" alt="image-20210208204348894"></p><p><img src="../../../Desktop/source/image/image-20210208204543776.png" alt="image-20210208204543776"></p><p>类型字段有15个不同的值，以描述特定类型的ICMP报文。某些ICMP报文还使用代码字段的值来进一步描述不同的条件。</p><p>检验和字段覆盖整个ICMP报文。ICMP的校验和时必须的。</p><h4 id="第八章-Traceroute"><a href="#第八章-Traceroute" class="headerlink" title="第八章 Traceroute"></a>第八章 Traceroute</h4><p>TTL字段的目的是防止数据报在选路时无休止的在网络中流动。</p><p>当路由器收到一份IP数据报时，如果其ttl字段时0或者1，则路由器不转发该数据报，路由器会将该数据报丢弃并给信源机发送一份ICMP超时信息，Traceroute程序的关键在于包含这份icmp信息的ip报文的信源地址是该路由器的地址。</p><p>Traceroute工作原理：发送一个ttl为1的ip数据报给目的主机，这样就得到了第一个路由器的ip地址；紧接着发送一个ttl为2的数据包给目的主机…….。继续该过程直到该数据报到达目的主机。Traceroute发送一份udp数据报给目的主机，但它选择一个不可能的值作为udp端口号(大于30000)，使目的主机的任何一个应用程序都不能使用该端口。因为，当该数据报到达时，使目的主机的udp模块产生一份“端口不可达”错误的icmp报文，此时Tracetoute程序需要做的就是区分接受到的icmp报文是超时还是端口不可达。</p><h4 id="第九章-IP选路"><a href="#第九章-IP选路" class="headerlink" title="第九章 IP选路"></a>第九章 IP选路</h4><p>需要进行选路的数据报可以由本机产生，也可以由其它主机产生(此种情况下：主机必须被配置成一个路由器，否则通过网络接口接受到的数据报，如果目的地址不是本级就会被丢弃)</p><p>IP搜索路由表的步骤：</p><ol><li>搜索匹配的主机地址(网络号、主机号完全一致)</li><li>搜索匹配的网络地址(网络号一致)</li><li>搜索默认表项</li></ol><p>匹配主机地址始终发生在匹配网络地址步骤之前。</p><h5 id="9-2-1-路由表"><a href="#9-2-1-路由表" class="headerlink" title="9.2.1 路由表"></a>9.2.1 路由表</h5><p><img src="../../../Desktop/source/image/image-20210301163425431.png" alt="image-20210301163425431"></p><p><img src="../../../Desktop/source/image/image-20210301163453659.png" alt="image-20210301163453659"></p><p>标志G区分是直接路由还是间接路由(直接路由不设置G标志)：发往直接路由的分组中不但具有指明目的端的ip地址，还具有其链路层地址。当分组被发往一个间接路由时，IP地址指明的是最终的目的地，但是链路层指明的是网关(下一站路由器)。</p><h4 id="第11章-用户数据报协议"><a href="#第11章-用户数据报协议" class="headerlink" title="第11章 用户数据报协议"></a>第11章 用户数据报协议</h4><p>udp首部</p><p><img src="../../../Desktop/source/image/image-20210301171045570.png" alt="image-20210301171045570"></p><h5 id="11-5-IP分片"><a href="#11-5-IP分片" class="headerlink" title="11.5 IP分片"></a>11.5 IP分片</h5><p>物理网络层一般要限制每次发送数据帧的最大长度。任何时候IP层接收到一份要发送的IP数据报时，它要判断向本地哪个接口发送数据(选路)，并查询该接口获得MTU(最大传输单元,netstat -i)。IP把MTU与数据报长度进行比较，如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发生在中间路由器上。</p><blockquote><p>引自 《计算机网络》</p><p>标识（identification）：<strong>占16位</strong>。IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。</p><p>但这个“标识”不是序号，因为IP是无连接服务，<strong>数据报不存在按序接收的问题</strong>。当数据报由于长度超过网络的MTU而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原</p><p>来的数据报。</p><p><strong>标志（flag）：</strong>占3位，但目前只有两位有意义。</p><p>​    – 标志字段中的最低位为MF（More Fragment）。MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个。</p><p>​    – 标志字段中间的一位记为DF（Don’t Fragment），意思是“不能分片”。只有当DF=0时才允许分片。</p><p><strong>片偏移 ：</strong>占13位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以8个字节为偏移单位。也就是说，每个分片的长度一定是8字节（64位）的整数倍。</p></blockquote><h4 id="第十七章-TCP-传输控制协议"><a href="#第十七章-TCP-传输控制协议" class="headerlink" title="第十七章 TCP:传输控制协议"></a>第十七章 TCP:传输控制协议</h4><h5 id="17-2-TCP的服务"><a href="#17-2-TCP的服务" class="headerlink" title="17.2 TCP的服务"></a>17.2 TCP的服务</h5><p>尽管tcp和udp都使用相同的网络层(IP)，tcp向应用层提供与udp完全不同的服务。tcp提供一种面向连接的、可靠的字节流服务。</p><p>tcp通过下列方式提供可靠性：</p><ul><li>应用数据被分割成tcp认为最适合发送的数据块。（udp：应用产生的报文长度保持不变）</li><li>当tcp发出一个段之后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li><li>当tcp收到发自tcp连接另一端的数据，它将发送一个确认。</li><li>tcp将保持它首部和数据的校验和。（如果收到段的检验和有差错，tcp将丢弃这个报文段并不确认收到此报文段）</li><li>tcp报文段作为IP数据报传输，而ip数据报的到达可能会失序，因此tcp报文段的到达也有可能失序。tcp将会对收到的数据进行排序然后交给应用层。</li><li>ip数据报会发生重复，因此接收端必须丢弃重复的数据。</li><li>tcp能提供流量控制。tcp连接的每一方都有固定大小的缓冲空间。tcp的接收端只允许另一端发送接收端缓冲区所能接纳的大小。（防止发送较快的主机使接收的较慢的主机缓冲区溢出）</li></ul><h5 id="17-3-TCP的首部"><a href="#17-3-TCP的首部" class="headerlink" title="17.3 TCP的首部"></a>17.3 TCP的首部</h5><p>tcp数据被封装在一个ip数据报中。</p><p><img src="../../../Desktop/source/image/image-20210217022249843.png" alt="image-20210217022249843"></p><p>tcp首部：</p><ul><li>16位的源端口号和目的端口号（用于寻找发端和接收端的应用程序），客户端ip、客户端端口、服务端ip、服务端端口可唯一确定一个tcp连接。</li><li>序号：标识从tcp发端向tcp收端发送的数据字节流，它表示在这个报文段中的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则tcp用序号对每个字节进行计数。（序号是32bit，序号达到2<sup>32</sup>-1后又从0开始。）当建立一个新的连接时，SYN标志位变成1。序号字段包含由这个主机选择的该连接的初始序号ISN(Initial Sequece Number)。该主机要发送的第一个字节序列号为ISN+1(SYN标志消耗了一个序号)。</li><li>确认序号：是发送端序号的下一个序号。只有ACK标志为1时确认序号才有效。发送ACK不需要任何代价，因为是包含在首部中的字段，一个tcp连接一旦建立起来，ACK标识总是被置为1。tcp提供全双工服务</li><li>首部长度：4bit，能表示的范围是0-15，单位是4字节，所以tcp首部最大为60字节。</li><li>标志位：6个标志位<ul><li>URG：紧急指针有效</li><li>ACK：确认序号有效</li><li>PSH：接收方应尽快将这个报文交给应用层</li><li>RST：重建连接</li><li>SYN：同步序号，用来发起一个连接</li><li>FIN：发端完成发送任务</li></ul></li><li>窗口：tcp的流量控制由连接的每一端通过声明的窗口大小提供。窗口大小为字节数，16bit因而窗口大小最大为65535字节。</li><li>检验和：覆盖整个tcp报文段—-首部和数据</li><li>紧急指针：只有URG标志置为1时才有效。</li><li>常见可选字段：最长报文大小，又称为MSS(Maximum Segment Size)，每个连接方通常都在通信的第一个报文段中声明这个选项，它指明本端能接收最大长度的报文段。</li></ul><p><img src="../../../Desktop/source/image/image-20210217022444857.png" alt="image-20210217022444857"></p><h4 id="第十八章-TCP连接的建立与终止"><a href="#第十八章-TCP连接的建立与终止" class="headerlink" title="第十八章 TCP连接的建立与终止"></a>第十八章 TCP连接的建立与终止</h4><h5 id="18-2-连接的建立与终止"><a href="#18-2-连接的建立与终止" class="headerlink" title="18.2 连接的建立与终止"></a>18.2 连接的建立与终止</h5><p>注：Flags [S.]，S表示SYN，“.”表示ACK</p><p><img src="../../../Desktop/source/image/tcpdump.jpg" alt="tcpdump抓包"></p><p>这是用telnet实现的一次通信，利用tcpdump进行抓包，如下是分析（iZbp11u8qxiwepq15dm1liZ表示本机）：</p><p><img src="../../../Desktop/source/image/tcp.jpg" alt="tcpdump输出字段解释说明"></p><p>第一行：方向：iZbp11u8qxiwepq15dm1liZ &gt; 47.96.67.121。iZbp11u8qxiwepq15dm1liZ 通过54008端口发送一个SYN标志位为1(通过Flags字段得知)的报文给远端主机47.96.67.121的ssh端口–也就是22端口，此报文的序号即seq是：826162287（ISN），后面的字段暂时可以忽略。</p><p>第二行：方向：47.96.67.121 &gt; iZbp11u8qxiwepq15dm1liZ。远程主机47.96.67.121 回复一个SYN标志位为1的报文给 iZbp11u8qxiwepq15dm1liZ，此报文序号即seq是：1641364849，此报文中出现了ack字段（表示确认），只有在首部中ACK标志被置为1时才显示，说明此报文中SYN、ACK两个标志位为1，当ACK为1时确认序号生效—826162288</p><p>第三行：方向：iZbp11u8qxiwepq15dm1liZ &gt; 47.96.67.121。由于47.96.67.121发来的报文首部中序号是1641364849(第二行)，所以在给47.96.67.121 回包时会将确认序号置为 序号（1641364849）的下一个序号。</p><p>第四行：方向：47.96.67.121 &gt; iZbp11u8qxiwepq15dm1liZ。到这里连接建立成功，开始数据传输，据图第四行可知传输了21字节。</p><p>第五行：方向：iZbp11u8qxiwepq15dm1liZ &gt; 47.96.67.121。收到确认数据报文后通知发送端。</p><p>第六行：方向：iZbp11u8qxiwepq15dm1liZ &gt; 47.96.67.121。发送一个报文，标志位FIN为1，意思是给47.96.67.121说数据发送完毕，我要关闭了。</p><p>第七行：方向：47.96.67.121 &gt; iZbp11u8qxiwepq15dm1liZ。服务端回复一个ack给iZbp11u8qxiwepq15dm1liZ说 我已经收到你要关闭的消息了。</p><p>第八行：方向：47.96.67.121 &gt; iZbp11u8qxiwepq15dm1liZ。47.96.67.121发送FIN给iZbp11u8qxiwepq15dm1liZ说我关闭了。</p><p>第九行：方向：iZbp11u8qxiwepq15dm1liZ &gt; 47.96.67.121。告诉47.96.67.121我收到你的关闭消息了，然后发送一个ack向47.96.67.121确认。</p><h5 id="18-4-最大报文段长度"><a href="#18-4-最大报文段长度" class="headerlink" title="18.4 最大报文段长度"></a>18.4 最大报文段长度</h5><p><img src="../../../Desktop/source/image/tcpdump.jpg" alt="tcpdump抓包"></p><p>最大报文长度(MSS)表示tcp穿往另一端的最大块数据长度。当一个连接建立时，连接双方都要通告各自的MMS(MSS只能出现在SYN报文段中)。上图中第一行：mss为1406。</p><h5 id="18-5-TCP的半关闭"><a href="#18-5-TCP的半关闭" class="headerlink" title="18.5 TCP的半关闭"></a>18.5 TCP的半关闭</h5><p>TCP提供了连接的一段在结束了它的发送之后还能接收另一端的数据的能力。</p><h5 id="18-6-1-2MSL等待状态"><a href="#18-6-1-2MSL等待状态" class="headerlink" title="18.6.1 2MSL等待状态"></a>18.6.1 2MSL等待状态</h5><p>当tcp执行一端主动关闭，并发回最后一个ack，该连接必须在TIME_WAIT状态停留的时间为2MSL(Max Segment LifeTime)，这样可以让tcp能够再次发送最后的ACK以防止这个ACK丢失。在2MSL等待期间，插口中使用的本地端口在默认情况下不能再被使用。</p><h5 id="18-6-3-FIN-WAIT-2状态"><a href="#18-6-3-FIN-WAIT-2状态" class="headerlink" title="18.6.3 FIN_WAIT_2状态"></a>18.6.3 FIN_WAIT_2状态</h5><p><img src="../../../Desktop/source/image/image-20210217195649249.png" alt="image-20210217195649249"></p><h5 id="18-7-复位报文段"><a href="#18-7-复位报文段" class="headerlink" title="18.7 复位报文段"></a>18.7 复位报文段</h5><p><img src="../../../Desktop/source/image/image-20210217200503883.png" alt="tcpdump"></p><p><img src="../../../Desktop/source/image/image-20210217200816830.png" alt="试图在不存在的端口上打开连接而产生的复位"></p><p>向一个没有监听的端口发起连接，服务端返回了一个RST标志为1的报文。</p><h4 id="第二十章"><a href="#第二十章" class="headerlink" title="第二十章"></a>第二十章</h4><h5 id="20-6-慢启动"><a href="#20-6-慢启动" class="headerlink" title="20.6 慢启动"></a>20.6 慢启动</h5><p>在局域网络中，发送方一开始便向网络中发送多个报文段，直到达到接收方通告的窗口大小为止，这种方式是没有问题的。但是当发送端和接收端之间存在多个路由器和速率较慢的链路时，就有可能出现一些问题：一些中间路由器必须缓存分组(报文)，并有可能耗尽存储器的空间(存储器耗尽之后路由器会丢弃新收到的分组)。</p><p>tcp支持慢启动算法，该算法通过观察到新分组进入网络的速率应该和另一端返回确认的速率相同而进行工作。</p><p>慢启动为发送方tcp增加了另一个新窗口：拥塞窗口(cwnd)。当与另一个网络的主机建立tcp连接时，拥塞窗口被初始化为一个报文段大小(另一端通告的窗口大小)。每收到一个ack，拥塞窗口就增加一个报文段(cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加)。发送方取拥塞窗口与通告窗口中的最小值作为发送上限(报文长度)。拥塞窗口是发送发使用的流量控制，通告窗口是接收方使用的流量控制。</p><p>拥塞窗口也不可能无限增大，在网络传输中，当某些点上的路由器网络容量达到了上限，于是中间路由器开始丢弃分组并通知发送方。</p><h4 id="第二十一章-TCP的超时与重传"><a href="#第二十一章-TCP的超时与重传" class="headerlink" title="第二十一章 TCP的超时与重传"></a>第二十一章 TCP的超时与重传</h4><p>tcp提供可靠的运输层：确认从另一端收到的数据(ack)，但数据和确认都可能会发生丢失。tcp通过在发送时设置一个定时器解决数据和确认丢失的问题，当定时器发生溢出时还没有收到该数据的确认就重传该数据。</p><p>对于每个连接，tcp管理四个定时器：</p><ol><li>重传定时器：期望收到对端确认的最大等待时间。</li><li>坚持定时器：使窗口大小信息保持不断流动，当发送端的发送速度过快，接收方的缓冲区被打满时，接收方会通告窗口大小为0，此时发送方会暂停数据发送，坚持定时器的作用就是不断发送报文询问窗口大小防止出现死锁(接收端不通告新的窗口大小，发送方一直等待。)</li><li>保活定时器：可以检测到一个空闲连接的另一端何时崩溃或者重启。</li><li>2MSL定时器：测量一个连接处于TIME_WAIT状态的时间。</li></ol><h4 id="21-2-超时重传例子"><a href="#21-2-超时重传例子" class="headerlink" title="21.2 超时重传例子"></a>21.2 超时重传例子</h4><p><img src="../../../Desktop/source/image/image-20210305165017197.png" alt="image-20210305165017197"></p><h4 id="21-3-往返时间测量"><a href="#21-3-往返时间测量" class="headerlink" title="21.3 往返时间测量"></a>21.3 往返时间测量</h4><p>tcp超时与重传中最重要的部分就是对一个给定的连接的往返时间(RTT)测量</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h4&gt;&lt;h5 id=&quot;1-2-分层&quot;&gt;&lt;a href=&quot;#1-2-分层&quot; class=&quot;headerlink&quot; title=&quot;1.2 分层&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C和指针</title>
    <link href="http://blog.3amupupup.online/2021/03/18/C%E5%92%8C%E6%8C%87%E9%92%88/"/>
    <id>http://blog.3amupupup.online/2021/03/18/C%E5%92%8C%E6%8C%87%E9%92%88/</id>
    <published>2021-03-18T03:09:52.067Z</published>
    <updated>2021-03-18T03:09:52.067Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第3章"><a href="#第3章" class="headerlink" title="第3章"></a>第3章</h4><h5 id="3-1-基本数据类型"><a href="#3-1-基本数据类型" class="headerlink" title="3.1 基本数据类型"></a>3.1 基本数据类型</h5><h6 id="3-1-1-整形家族"><a href="#3-1-1-整形家族" class="headerlink" title="3.1.1 整形家族"></a>3.1.1 整形家族</h6><p>长整型至少应该和整型一样，而整型至少应该和短整型一样长。</p><p>一、整型字面值</p><p>初始化之后不可以被修改。</p><p>在整数字面值后面添加L或l，可以使这个整数被解释为long类型值，字符U或u则用于把数值指定为unsigned整型值。如果添加lu则被解释为 unsigned long 整型值。字符常量的类型总是int。</p><pre><code class="c">int main(){    123L;    123u;    123LU;    0123; // 8进制    0x1561; // 16进制    printf(&quot;%lu\n&quot;,sizeof(&#39;a&#39;)); // 4    return 0;}</code></pre><p>二、枚举类型</p><p>以整型方式存储。</p><pre><code class="c">enum age{    a,    b,    c,    d};</code></pre><h6 id="3-1-1-浮点类型"><a href="#3-1-1-浮点类型" class="headerlink" title="3.1.1 浮点类型"></a>3.1.1 浮点类型</h6><pre><code class="c">int main(){    printf(&quot;%lu\n&quot;,sizeof(3.14)); // 8,缺省时默认为double类型    printf(&quot;%lu\n&quot;,sizeof(3.14l)); // 16,long double    printf(&quot;%lu\n&quot;,sizeof(3.14f)); // 4    printf(&quot;%lu\n&quot;,sizeof(double )); // 8    printf(&quot;%lu\n&quot;,sizeof(float )); // 4    return 0;}</code></pre><h6 id="3-1-3-指针"><a href="#3-1-3-指针" class="headerlink" title="3.1.3 指针"></a>3.1.3 指针</h6><p>把内存想象成一条长街，每间房子都用一个唯一的号码进行标识。每一个位置包含一个值，这和它的地址式独立且显著不同的，即使他们都是数字。</p><p>一、指针常量</p><p>二、字符串常量</p><p>字符串：一串以NUL字节结尾的零个或多个字符。字符串通常存储在字符数组总，所以c语言中没有显示的字符串类型。</p><pre><code class="c">int main(){    printf(&quot;%lu\n&quot;,sizeof(&quot;&quot;)); // 1，虽然字符串为空，但是还是会分配内存    return 0;}</code></pre><p>在程序中使用字符串常量时会生成一个“指向字符的常量指针”，当一个字符串常量出现于一个表达式中时，表达式所使用的值就是这些字符所存储的地址，而不是这些字符本身。因此，可以把字符串常量赋值给一个“指向字符的指针”。但是不能把字符串常量赋值给一个字符数组，因为字符串常量的直接值是一个指针，而不是这些字符本身。</p><h5 id="3-2-基本申明"><a href="#3-2-基本申明" class="headerlink" title="3.2 基本申明"></a>3.2 基本申明</h5><p>int a;</p><h6 id="3-2-1-初始化"><a href="#3-2-1-初始化" class="headerlink" title="3.2.1 初始化"></a>3.2.1 初始化</h6><h6 id="3-2-2-声明简单数组"><a href="#3-2-2-声明简单数组" class="headerlink" title="3.2.2 声明简单数组"></a>3.2.2 声明简单数组</h6><pre><code class="c">int arr[100];</code></pre><h6 id="3-2-3-声明指针"><a href="#3-2-3-声明指针" class="headerlink" title="3.2.3 声明指针"></a>3.2.3 声明指针</h6><pre><code class="c">int *a;int *b,*c;char *message = &quot;hello world&quot;;/*char *message;message = &quot;hello world&quot;;*/</code></pre><h6 id="3-2-4-隐式声明"><a href="#3-2-4-隐式声明" class="headerlink" title="3.2.4 隐式声明"></a>3.2.4 隐式声明</h6><p>函数如果不显示的声明返回值的类型，就默认返回整型。</p><pre><code class="c">f(int x){    return x*2;}int main(){    printf(&quot;ret = %d\n&quot;,f(3));    return 0;}</code></pre><h5 id="3-3-typedef"><a href="#3-3-typedef" class="headerlink" title="3.3 typedef"></a>3.3 typedef</h5><p>为数据类型定义新的名字，而不是产生新的类型。</p><pre><code class="c">int const a;const int a; // 二者等价int const *pi; // const修饰 *pi ，可以修改pi的值但是不可以修改pi所指向的地址的值int * const cpi; // 可以修改cpi所指向地址的值但是不可以修改cpi指向的地址。int const * const cpci; // 无论是cpci指针本身还是它所指向的地址的值 都不可以修改</code></pre><h5 id="3-5-作用域"><a href="#3-5-作用域" class="headerlink" title="3.5 作用域"></a>3.5 作用域</h5><h6 id="3-5-1-代码块作用域"><a href="#3-5-1-代码块作用域" class="headerlink" title="3.5.1 代码块作用域"></a>3.5.1 代码块作用域</h6><p>任何在代码块的开始位置声明的标识符都具有代码块作用域。</p><h6 id="3-5-2-文件作用域"><a href="#3-5-2-文件作用域" class="headerlink" title="3.5.2 文件作用域"></a>3.5.2 文件作用域</h6><p>在代码块之外声明的标识符都具有文件作用域。</p><h6 id="3-5-3-原型作用域"><a href="#3-5-3-原型作用域" class="headerlink" title="3.5.3 原型作用域"></a>3.5.3 原型作用域</h6><p>只适用于在函数原型中声明的参数名。</p><pre><code class="c">int f(int x){ return x;  }</code></pre><h5 id="3-6-链接属性"><a href="#3-6-链接属性" class="headerlink" title="3.6 链接属性"></a>3.6 链接属性</h5><p>标识符的链接属性决定如何处理在不同文件中出现的标识符。</p><p>链接属性</p><ul><li><p>external (extern)</p><p>属于external链接属性的表示符不论声明多少次、位于几个源文件都表示同一实体。</p></li><li><p>internal (static)</p><p>属于internal的连接属性的标识符在同一源文件内的所有声明中都指同一个实体。</p></li><li><p>none (auto)</p><p>没有链接属性的标识符总是被当做单独的个体。</p></li></ul><h5 id="3-7-存储类型"><a href="#3-7-存储类型" class="headerlink" title="3.7 存储类型"></a>3.7 存储类型</h5><p>变量的存储类型是指存储变量值的内存类型。变量的存储类型决定变量何时创建、何时销毁以及它的值将保持多久。</p><ul><li>普通内存</li><li>运行时堆栈</li><li>硬件寄存器</li></ul><p>变量的缺省存储类型取决于它的声明位置。在任何代码块之外声明的变量总是存储于静态内存中(不属于堆栈)，这类变量称为静态变量。静态变量在程序运行之前创建，在程序的整个执行期间始终存在。</p><p>在代码块内部声明的变量的缺省内存存储类型是自动的(automatic)，它存储于堆栈中，称为自动(auto)变量。在程序执行到声明自动变量的代码块时，自动变量才被创建，当程序离开该代码块时自行销毁。</p><p>对于在代码块内部声明的变量，加上static关键字，可以使它的存储类型从自动变为静态。具有静态存储类型的变量在整个程序执行过程中一直存在，而不仅仅在声明它的代码块的执行时存在。修改变量的存储类型并不表示修改该变量的作用域，它仍然只能在该代码块内部按变量名访问。函数形式参数不能声明为静态，因为实参总是在堆栈中传递给函数，用于支持递归。</p><p>register可以用于自动变量声明，提示他们应该存储于机器的硬件寄存器而不是内存中，这类变量称为寄存器变量(因为不在内存中，所以不能用&amp;取地址。)</p><p>初始化</p><ul><li><p>静态变量</p><p>静态变量的初始化中，可以把可执行程序文件想要初始化的值放在当程序执行时变量将会使用的位置。当可执行文件载入到内存时，这个已经保存了正确初始值的位置将赋值给那个变量。完成这个任务并不需要额外时间，也不需要额外指令，变量将会得到正确的值。如果不显式的指定其初始值，静态变量将初始化为0。</p></li><li><p>自动变量</p><p>自动变量初始化需要更多的开销，因为当程序链接时还无法判断自动变量的存储位置。</p></li></ul><h4 id="第六章-指针"><a href="#第六章-指针" class="headerlink" title="第六章 指针"></a>第六章 指针</h4><h5 id="6-14-总结"><a href="#6-14-总结" class="headerlink" title="6.14 总结"></a>6.14 总结</h5><p>声明一个指针变量并不会自动分配任何内存。</p><h5 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章 函数"></a>第七章 函数</h5><pre><code class="c">int*find_int(int key, int arr[], int length);</code></pre><p>这种声明方式，也就是用单独的一行给出参数的类型，那么编译器就只记住函数返回值的类型，不保存函数的参数数量和类型信息。</p><pre><code>int func();这种声明会被解释为旧式风格的声明，只保存了函数的返回值类型。int func(void);使用新风格原型时，得加上void提示没有任何参数</code></pre><h5 id="7-3-函数的参数"><a href="#7-3-函数的参数" class="headerlink" title="7.3 函数的参数"></a>7.3 函数的参数</h5><p>C函数的所有参数均以“值传递调用”方式进行传递。(参数为指针时也会发生值拷贝，拷贝地址)</p><h5 id="7-6-可变参数列表"><a href="#7-6-可变参数列表" class="headerlink" title="7.6 可变参数列表"></a>7.6 可变参数列表</h5><h6 id="7-6-1-stdarg宏"><a href="#7-6-1-stdarg宏" class="headerlink" title="7.6.1 stdarg宏"></a>7.6.1 stdarg宏</h6><h4 id="第八章-数组"><a href="#第八章-数组" class="headerlink" title="第八章 数组"></a>第八章 数组</h4><ul><li><p>下标：为了对下标表达式求值，编译器在程序中插入指令，取得a的值，并把它与整形的长度(也就是4)相乘，这个乘法需要花费一定的时间和空间。</p></li><li><p>指针：尽管不存在下标，但还是存在乘法运算，1这个值必须和整数的长度相乘，然后再与指针相加。但是这里存在一个重大区别：循环每次执行时，执行乘法的运算都是两个相同的数(1和4)。结果，这个乘法只在编译时执行一次—-程序现在包含了一条指令，把4与指针相加。程序在执行时并不执行乘法运算。</p><pre><code class="c">int main(){    int arr[100] = { 0 }, *ap;    for (int i = 0; i &lt; 100; ++i) { // 下标        arr[i] = 0;    }    for (ap = arr; ap &lt; arr+10; ++ap) { // 指针        *ap = 0;    }    return 0;}</code></pre></li></ul><h5 id="8-1-一维数组"><a href="#8-1-一维数组" class="headerlink" title="8.1 一维数组"></a>8.1 一维数组</h5><h6 id="8-1-1-数组名"><a href="#8-1-1-数组名" class="headerlink" title="8.1.1 数组名"></a>8.1.1 数组名</h6><pre><code class="c">int a; // 标量int b[10]; // 集合，称为数组</code></pre><p>数据名是常量指针。</p><p>数组名在两种情况下表示整个数组，其余一律表示首元素。</p><pre><code>int arr[10];sizeof(arr);&amp;arr;</code></pre><h6 id="8-1-2-下标引用"><a href="#8-1-2-下标引用" class="headerlink" title="8.1.2 下标引用"></a>8.1.2 下标引用</h6><p>数组下标引用和间接访问完全相同。</p><p>C检查下标所涉及的开销比你想象的大得多。编译器必须在程序中插入指令，证实下标表达式的结果所引用的元素和指针表达式所指向的元素属于同一数组。这个比较操作需要程序中所有数组的位置和长度方面的信息。这将占用一些空间。当程序运行时，这些信息必须进行更新，以反映自动和动态分配的数组，这又将占用一定的时间。</p><h6 id="8-1-3-指针与下标"><a href="#8-1-3-指针与下标" class="headerlink" title="8.1.3 指针与下标"></a>8.1.3 指针与下标</h6><pre><code class="c">int main(){    int arr1[10],a;     for ( a = 0; a &lt; 10; ++a) {        arr1[a] = 0;    }    return 0;}</code></pre><p>为了对下标表达式求值，编译器在程序中插入指令，取得a的值，并把它与整形的长度(4)相乘。这个乘法需要花费一定的空间和时间。</p><pre><code class="c">int main(){    int arr2[10],*ap;    for (ap=arr2; ap &lt; arr2; ++ap) {        *ap = 0;    }    return 0;}</code></pre><p>这里的乘法运算出现在for语句的调整部分(++ap)，1这个值必须与整形的长度相乘，然后再与指针相加。但是这里存在很大的区别：循环每次执行时，执行乘法运算的都是两个相同的数(1和4)。结果这个乘法只会在编译时执行一次—-程序包含一条指令，把4与指针相加。程序在运行时并不执行乘法运算。</p><h6 id="8-1-4-指针的效率"><a href="#8-1-4-指针的效率" class="headerlink" title="8.1.4 指针的效率"></a>8.1.4 指针的效率</h6><h6 id="8-1-5-指针和数组"><a href="#8-1-5-指针和数组" class="headerlink" title="8.1.5 指针和数组"></a>8.1.5 指针和数组</h6><p>数组和指针不相等。</p><pre><code class="c">int a[5];int *p;</code></pre><p>声明一个数组时，编译器将根据声明所指定的元素数量为数组保存内存空间，然后创建数组名，它的值是一个常量，指向这段空间的起始位置。</p><p>声明一个指针变量时，编译器只为指针本身保留内存空间，它并不为任何整形值分配内存空间。而且指针变量并未被初始化为指向任何现有的内存空间，如果是一个自动变量，它甚至不会被初始化。</p><p>因此：*a是合法的。*b将访问内存中某个不确定的位置，或者导致程序终止。但是b++可以通过编译，a++缺不行，因为a是一个常量。</p><h6 id="8-1-6-作为函数参数的数组名"><a href="#8-1-6-作为函数参数的数组名" class="headerlink" title="8.1.6 作为函数参数的数组名"></a>8.1.6 作为函数参数的数组名</h6><p>一个数组名作为参数传递给函数：在函数传参时就会发生拷贝。可知数组是一个地址常量，在传参给函数时，发生地址拷贝，数组名(地址常量)传递给函数的形参，形参实例化成一个指针变量，指针变量存放数组的地址常量。因此数组地址传入函数之后，发生降维，降维成一个指针。函数如果执行了下标应用，实际山是对这个指针进行间接访问操作，并且通过这种间接访问，函数可以访问和修改调用程序的数组元素。</p><h6 id="8-1-7-声明数组参数"><a href="#8-1-7-声明数组参数" class="headerlink" title="8.1.7 声明数组参数"></a>8.1.7 声明数组参数</h6><pre><code>int strlen(char *string);int strlen(char string[]);</code></pre><h6 id="8-1-8-初始化"><a href="#8-1-8-初始化" class="headerlink" title="8.1.8 初始化"></a>8.1.8 初始化</h6><pre><code>char message1[] = &quot;Hello&quot;;char *message2 = &quot;Hello&quot;;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/15150075-912a16aa87956bdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h6 id="8-2-3-下标"><a href="#8-2-3-下标" class="headerlink" title="8.2.3 下标"></a>8.2.3 下标</h6><pre><code>int matrix[3][10];</code></pre><ul><li><p>matrix</p><p><img src="https://upload-images.jianshu.io/upload_images/15150075-4e7271031de98d6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>martrix此时指向第一个二维数组</p></li><li><p>matrix+1</p><p><img src="https://upload-images.jianshu.io/upload_images/15150075-cf614cf0e6dea534.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>*(matrix+1)</p><p><img src="https://upload-images.jianshu.io/upload_images/15150075-abe44a68c361cd8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>*(matrix+1)+5</p><p><img src="https://upload-images.jianshu.io/upload_images/15150075-921e9fc90ec740f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li></ul><h5 id="8-5-总结"><a href="#8-5-总结" class="headerlink" title="8.5 总结"></a>8.5 总结</h5><ul><li>在绝大多数表达式中，数组名是指向数组第一个元素的指针。只有两个规则例外：<ul><li>sizeof(arr)，返回整个数组占用的字节，而不是返回指针占用的字节。</li><li>&amp;arr，单目操作符&amp;返回一个指向整个数组的指针，而不是指向数组第一个元素的指针的指针。</li></ul></li><li>指针和数组不相等。<ul><li>声明一个数组，同时也分配了一些内存，用于容纳数组元素。</li><li>声明一个指针，只分配用于容纳指针本身的空间。</li></ul></li><li>当数组名作为函数参数传递。实际传递的是一个指向数组第一个元素的指针。函数所接收到的参数实际上是原参数的一份拷贝，所以函数可以对其进行操纵而不影响实际的参数。但是对指针执行间接访问操作允许函数修改原先数组的元素。</li><li>数组形参既可以声明成数组也可以声明成指针，这两种声明形式只有当他们作为函数形参时才相等。</li></ul><h4 id="第九章-字符串、字符和字节"><a href="#第九章-字符串、字符和字节" class="headerlink" title="第九章 字符串、字符和字节"></a>第九章 字符串、字符和字节</h4><h5 id="9-1-字符串基础"><a href="#9-1-字符串基础" class="headerlink" title="9.1 字符串基础"></a>9.1 字符串基础</h5><p>字符串是一串零个或多个字符，以NUL结尾。</p><h5 id="9-3-不受限制的字符串函数"><a href="#9-3-不受限制的字符串函数" class="headerlink" title="9.3 不受限制的字符串函数"></a>9.3 不受限制的字符串函数</h5><h6 id="9-3-1-复制字符串"><a href="#9-3-1-复制字符串" class="headerlink" title="9.3.1 复制字符串"></a>9.3.1 复制字符串</h6><p>char *strcpy(char *dst, char const *src);</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(){    char dest[] = &quot;abcde&quot;;    strcpy(dest,&quot;xyz&quot;);    printf(&quot;%s\n&quot;,dest); // xyz    return 0;}</code></pre><p>目标参数以前的内容将被覆盖，即使新的字符串比dest原先的内存更短。(NUL也会被复制)</p><p><img src="https://upload-images.jianshu.io/upload_images/15150075-5f82cd2ae2a6e440.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h6 id="9-3-2-连接字符串"><a href="#9-3-2-连接字符串" class="headerlink" title="9.3.2 连接字符串"></a>9.3.2 连接字符串</h6><p>char * strcat(char *dst, char const *src);</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(){    char message[100] = {0};    strcat(message,&quot;hello&quot;);    strcat(message,&quot; world&quot;);    printf(&quot;%s\n&quot;,message);    return 0;}</code></pre><h6 id="9-3-3-函数的返回值。"><a href="#9-3-3-函数的返回值。" class="headerlink" title="9.3.3 函数的返回值。"></a>9.3.3 函数的返回值。</h6><p>strcpy和strcat都返回它们第一个参数的一份拷贝，就是指向目标字符数组的指针。</p><h6 id="9-3-4-字符串比较"><a href="#9-3-4-字符串比较" class="headerlink" title="9.3.4 字符串比较"></a>9.3.4 字符串比较</h6><p>int strcmp(char const *s1, char const *s2);</p><pre><code>int main(){    int ret = strcmp(&quot;duwei&quot;,&quot;zhangsan&quot;);    /*    if (ret){ // ret的值有三种情况：大于0，等于0，小于0。将其用bool值表达是一种坏风格，正确的方式是将其与0值进行比较        printf(&quot;duwei &gt; zhangsan&quot;);    }    */    if (ret &gt; 0){        printf(&quot;duwei &gt; zhangsan&quot;);    }    return 0;}</code></pre><h5 id="9-5-字符串查找"><a href="#9-5-字符串查找" class="headerlink" title="9.5 字符串查找"></a>9.5 字符串查找</h5><h6 id="9-5-1-查找一个字符"><a href="#9-5-1-查找一个字符" class="headerlink" title="9.5.1 查找一个字符"></a>9.5.1 查找一个字符</h6><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(){    char message[] = &quot;learn C language.&quot;;    char *p1 = strchr(message,&#39;a&#39;); // 返回第一次出现的位置    printf(&quot;p1 - message = %lu\n&quot;,p1-message);    char *p2 = strrchr(message, &#39;a&#39;); // 返回最后一次出现的位置    printf(&quot;p2 - message = %lu\n&quot;,p2-message);    return 0;}</code></pre><h6 id="9-5-2-查找任何几个字符"><a href="#9-5-2-查找任何几个字符" class="headerlink" title="9.5.2 查找任何几个字符"></a>9.5.2 查找任何几个字符</h6><p>char *strpbrk(char const *str, char const *group); 查找一组字符串在字符串中第一次出现的位置。</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(){    char message[] = &quot;learn C language.&quot;;    char *p = strpbrk(message,&quot;zC&quot;); // 返回z或者C第一次出现的位置，    printf(&quot;%s\n&quot;,p);    return 0;}</code></pre><h6 id="9-5-3-查找一个子串"><a href="#9-5-3-查找一个子串" class="headerlink" title="9.5.3 查找一个子串"></a>9.5.3 查找一个子串</h6><p>char *strstr(char const *s1, char const *s2);</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(){    char message[] = &quot;learn C language.&quot;;    char *p = strstr(message,&quot;lang&quot;);    printf(&quot;%s\n&quot;,p);    return 0;}</code></pre><h5 id="9-9-内存操作"><a href="#9-9-内存操作" class="headerlink" title="9.9 内存操作"></a>9.9 内存操作</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;第3章&quot;&gt;&lt;a href=&quot;#第3章&quot; class=&quot;headerlink&quot; title=&quot;第3章&quot;&gt;&lt;/a&gt;第3章&lt;/h4&gt;&lt;h5 id=&quot;3-1-基本数据类型&quot;&gt;&lt;a href=&quot;#3-1-基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;3</summary>
      
    
    
    
    <category term="C语言" scheme="http://blog.3amupupup.online/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="book" scheme="http://blog.3amupupup.online/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>C Primer Plus</title>
    <link href="http://blog.3amupupup.online/2021/03/18/C%20Primer%20Plus/"/>
    <id>http://blog.3amupupup.online/2021/03/18/C%20Primer%20Plus/</id>
    <published>2021-03-18T03:09:52.065Z</published>
    <updated>2021-03-18T03:09:52.066Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="c">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stddef.h&gt;#define LEN 40#define MAX 41/*常量：在程序使用之前已经预设定好，在整个程序的运行过程中没有变化变量：在程序运行期间可能会被改变或者赋值数据：    显示十进制数：%d    显示八进制数：%o    显示十六进制数：%x指针&amp;数组：    数组名是首元素地址：        arr[i]=*(arr+i) 二者等价        特殊情况：            1. sizeof(数组名) - 数组名表示整个数组            2. &amp;数组名 - 数组名表示整个数组    指针操作：        赋值：可以把地址赋给指针        解引用：*运算符获得指针指向地址上存储的值        取地址：&amp;运算符，指针也拥有自己的地址        指针与整数相加：int *a = 1; a+1 即 a的地址 + sizeof(int)*1，步长为a指向的数据类型的大小        指针求差        比较：如果要使用关系运算符比较两个指针，那么要确保两个指针指向同一数据类型的对象        解引用未初始化的指针：严重的错误            int main(void){                int *pt; //错误写法                int *pt = NULL; //正确写法                *pt = 100; // pt在定义之后未被初始化，其值是一个随机值，不能确定100的存储位置，这可能不会出什么错，但是也有可能擦写数据或代码，导致程序崩溃，因此创建指针必须初始化，特殊情况下可以将指针指向NULL                printf(&quot;%d\n&quot;, *p);                return 0;            }    const：        1、把const或者非const数据的地址初始化为指向const的指针或者为其赋值是合法的。            int main(void){                int arr1[10] = {1,2,3,4,5,6,7,8,9,10};                const int arr2[10] = {11,12,13,14,15,16,17,18,19,20};                 const int * pt = arr1; //把pt指向的int类型的值声明为const(注意是值而非地址)，所以不能够用*pt修改数组的值，但是能修改pt所指向的地址                pt = arr2;                pt = &amp;arr1[3];                return 0;            }        2、只能把非const数据的地址赋给普通指针，            int main(void){                int arr1[10] = {1,2,3,4,5,6,7,8,9,10};                const int arr2[10] = {11,12,13,14,15,16,17,18,19,20};                const int * pt = arr1;                int * pt2 = arr1;                pt2 = arr2; //非法，只能将非const的数据的地址赋值给普通指针，否则通过指针就能改变const数组中的数组，显然不合理。                pt2 = &amp;arr1[3];                return 0;            }        3、创建一个不能改变指向地址的指针，但是能改变指针指向的地址的值                int main(void){                    int arr1[10] = {1,2,3,4,5,6,7,8,9,10};                    const int arr2[10] = {11,12,13,14,15,16,17,18,19,20};                    const int * pt = arr1;                    int * pt2 = arr1;                    pt2 = &amp;arr1[3];                    int * const pt3 = arr1;                    pt3 = &amp;arr1[3]; //非法                    *(pt3+1) = 100;                     printf(&quot;new = %d\n&quot;,arr1[1]);                    return 0;                }    指针和多维数组：        int main(void){            int arr[3][4];            printf(&quot;%d\n&quot;,**arr); // arr = arr[0] = &amp;arr[0][0],**arr 与 *&amp;arr[0][0]等价，**arrd第一次解引用表示arr[0],此时仍然是个地址所以需要再次解引用            printf(&quot;arr = %p, arr[0] = %p, arr[0][0] = %p\n&quot;,arr,arr[0],&amp;arr[0][0]); // arr = 0x7ffeeeec7be0, arr[0] = 0x7ffeeeec7be0, arr[0][0] = 0x7ffeeeec7be0            return 0;        }    指向数组的指针：        int *p[]; //指针数组        int (*p)[]; // 数组指针                ----例题：                    int main(void){                        int arr[10] = {100 ,2,3,4,5,6,7,8,9,10};                        int res = max(arr);                        printf(&quot;%d\n&quot;,res);                        return 0;                    }                    int max(int *arr){                        int temp;                        for (int i = 1; i &lt; 10; ++i)                        {                            if (arr[0]&lt;arr[i])                            {                                temp = arr[0];                                arr[0] = arr[i];                                arr[i] = temp;                            }                        }                        return arr[0];                    }分配内存 malloc 和 free    之前所使用的的存储类别有一个共同之处：在确定存储类别之后，根据已定制好的内存管理规则，将自动选择其作用域和存储期，然而还有更灵活的选择，即使用库函数分配和管理内存。    int main(){    double * ptd1;    ptd1 = (double *)malloc(30 * sizeof(double));  //为30个double类型的值申请内存空间，并让ptd指向该片内存的首地址。double类型且长度为30的数组    if (ptd1==NULL){        printf(&quot;内存分配失败\n&quot;);        exit(-1);    }    free(ptd1); //释放内存    long * ptd2;    ptd2 = (long *)calloc(100,sizeof(long));    printf(&quot;ptd2 = %d\n&quot;,ptd2);    free(ptd2);    return 0;}    可以认为程序把它的可用内存分为三部分：一部分供具有外部链接、内部链接和无连接的静态变量使用；一部分供自动变量使用；一部分供动态内存分配。    int num1 = 100; //文件作用域，外部链接    static int num2 = 100; //文件作用域，内部链接。    //无论外部还是内部链接，文件作用域变量都具有静态存储期(随程序执行创建，程序结束销毁，在程序执行和结束期间一直存在)    //块级作用域具有自动存储器。当程序进入定义这些变量的块时，为这些变量分配内存，当退出这个块时，释放刚才为变量分配的内存。(变长数组略有不同，它的存储器从生命到块结尾)    //块级作用域也能具有静态存储期。在块中声明变量时，加上static关键字。但是只有执行其所在的函数时才能访问，该函数可以提供改变量的存储地址以便间接的访问对象，例如返回一个指针    //静态变量：该变量在内存中原地不动，并不是值不可改变。    void trystat(void){        int fade = 1; //函数执行一次，初始化一次        static int stay = 1; //只在编译阶段初始化一次        printf(&quot;fade = %d and stay = %d\n&quot;,fade++,stay++);    }    void test(void){        extern int num1; //可选重复声明        printf(&quot;%d\n&quot;,num1);    }----------------------------------------------------------------------------------    C的存储类别：(静态存储期：随着程序运行创建，程序结束销毁，在这期间一直存在；文件作用域：可以多个程序文件使用；自动存储期：当程序进入定义这些变量的块时，为这些变量分配内存，当退出这个块时，释放刚才为变量分配的内存；静态存储期：在块中声明变量时，加上static关键字。但是只有执行其所在的函数时才能访问，该函数可以提供改变量的存储地址以便间接的访问对象)        自动：在块中不带存储类别说明符或带auto(默认)存储类说明符声明的变量(或者作为函数头中的形参)属于自动存储类别。        寄存器：在块中带register存储类别说明符声明的变量(或作为函数头中的形参)属于寄存器存储类别，具有自动存储区、块作用域、无链接且无法获取其地址。        静态、无链接：在块中带有static存储类别说明符声明的变量，具有静态存储期、块作用域、无链接，只在编译时初始化一次        静态、外部链接：在所有函数外部且没有使用static存储类别说明符，具有静态存储期、文件作用域、外部链接。只能在编译器被初始化一次        静态、内部链接：在所有函数外使用了static存储类别说明符，具有静态存储期、文件作用域、内部链接。只能在编译器被初始化一次        动态分配的内存：由malloc()相关函数分配。        类型限定符：const、volatile、restrict、_Automic，const限定符限定数据在程序运行时不能改变。对指针使用const时，可限定指针本身不能改变或者指向的数据不能改变。----------------------------------------------------------------------------------文件输入与输出：    r:只读打开    w:覆盖写    a:追加写    r+:读写    w+:读，覆盖写    a+:读，追加写    int main(){        int ch; //读文件时存储每个字符的地方        FILE *fp; //文件指针        int count = 0;        fp = fopen(&quot;test.txt&quot;,&quot;r&quot;);        if (fp==NULL){            return 0;        }        for (;(ch = getc(fp))!=EOF;){ //getc() putc() 要传递文件的指针。            putc(ch,stdout);            count++;         }        fclose(fp);        printf(&quot;\n%d\n&quot;, count);        return 0;    }    ---------------    文件读写demo:        int main(){            int ch;            FILE *fp,*wfp;            int count = 0;            wfp = fopen(&quot;test.txt&quot;,&quot;a+&quot;);            if ((fp=fopen(&quot;/Users/duwei/ingress-controller-manager.yaml&quot;,&quot;r&quot;))==NULL)            {                printf(&quot;%s\n&quot;,strerror(errno)); //strerror(errno)            }            for (;(ch = getc(fp)) != EOF;)            {                putc(ch,wfp);            }            fclose(fp);            return 0;        }    ---------------    rewind：        int main(){            FILE *fp;            char str1[10],str2[10],str3[10];            int year;            fp = fopen(&quot;test.txt&quot;,&quot;w+&quot;);            fputs(&quot;we are in 2020&quot;,fp);            rewind(fp);//写完时文件描述符在末尾，rewind将文件描述符拉回文件开始的地方            fscanf(fp,&quot;%s %s %s %de&quot;,&amp;str1,&amp;str2,&amp;str3,&amp;year);            printf(&quot;Read String1 |%s|\n&quot;, str1 );            printf(&quot;Read String2 |%s|\n&quot;, str2 );            printf(&quot;Read String3 |%s|\n&quot;, str3 );            printf(&quot;Read Integer |%d|\n&quot;, year );            fprintf(stderr, &quot;end.\n&quot;);            fclose(fp);            return 0;        }结构体：    ---------------    struct book{        char title[100];        char author[100];        int value;    };    void setV(struct book bk);    int main(){        struct book  library[100];        library[0].value = 99;        printf(&quot;out func,value = %d\n&quot;,library[0].value );        setV(library[0]);        printf(&quot;out func,value = %d\n&quot;,library[0].value );    }    void setV(struct book bk){        bk.value=999;        printf(&quot;in func,value = %d\n&quot;,bk.value);    }    stdout:        out func,value = 99        in func,value = 999        out func,value = 99    结论：结构体是值传递。    ---------------    对齐规则：    1、第一个成员在与结构体变量偏移量为0的地址处。(c1为起始位置)    2、其它成员变量要对齐到某个数(对齐数，vs默认为8，我用的gcc，对齐数就是成员自身大小)的整数倍的地址处。(对齐数: 编译器默认的对齐数 与 该成员大小 比较，小的就是该成员的对齐数。a大小为4，编译器默认的是8，那么该成员的对齐数就是4，    所以a的位置要为4的倍数处，所以a的位置为4，另外a占四个字节。同理c2的对齐数是1(1与8比较)，所以c2的位置为8。)    3、结构体总大小为最大对齐数(每个成员变量都有一个对齐数)的整数倍。(s1中的最大对齐数为4[来自a]，当前三个变量占了0-8也就是9个字节，所以结构体s1的整体大小为3*4=12字节)    4、如果嵌套了结构的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数(含嵌套结构体的对齐数)的整数倍。     在设计结构体时候，将占用空间小的成员尽量集中在一起。     #pragma pack(4) //设置默认对齐数    struct S1    {    char c1;    int a;    char c2;    };        _________________    ____         __________                                  0 |_________________|    c1              |                                      1 |_________________|    |               |                                        2 |_________________|    |               |                      3 |_________________|   _|__ 4 |_________________|    a          s1: 12个字节,1、2、3、9、10、11浪费掉 5 |_________________|                    |    6 |_________________|                    | 7 |_________________|   ____             | 8 |_________________|   _c2_             | 9 |_________________|                    |10 |_________________|                    | 11 |_________________|               _____|____12 |_________________|13 |_________________|14 |_________________|   |_________________|   |_________________|   |_________________|   |_________________|   |_________________|   |_________________|   |_________________|    同理s2如下：    struct S2    {    char c1;    char c2;    int a;    };    _________________    ____         _________ 0 |_________________|   _c1_            | 1 |_________________|   _c2_            | 2 |_________________|                   | 3 |_________________|   ____ 4 |_________________|    a          s1: 8 个字节,2、3浪费掉 5 |_________________|                   |    6 |_________________|                   | 7 |_________________|   ____        ____|_____ 8 |_________________|                     9 |_________________|                    10 |_________________|                    11 |_________________|           12 |_________________|13 |_________________|14 |_________________|   |_________________|   |_________________|   |_________________|   |_________________|   |_________________|   |_________________|   |_________________|   struct S3    {    double d;    char c;    int i;    };   struct S4    {    char c1;   struct S3 s3;    double d;    };————————----------——————————————    struct S{    int a;    char c;    double d;    };void Init(struct S * tmp){    tmp-&gt;a = 100;    tmp-&gt;c = &#39;d&#39;;    tmp-&gt;d = 3.14;}int main(){    struct S s = {0};    Init(&amp;s);    printf(&quot;%d\n&quot;, s.a);}————————----------——————————————位段：(二进制位)    1、位段的成员可以使 int、unsigned int、signed int 或者是char（属于整型家族）类型。    2、位段的空间上是按照需要以4个字节(int)或者一个字节(char)的方式来开辟的。    3、位段涉及很多不确定因素，不跨平台，注重可移植的程序应避免使用位段。    4、每一次开辟的内存，从右往左使用。            struct S             {                int _a:2; //2代表只需要两个比特位                int _b:5; //5代表只需要五个比特位                int _c:10;                int _d:30;            };            //47个比特位 需要 6字节*8bit = 48比特            int main()            {                struct S s;                printf(&quot;%d\n&quot;, sizeof(s)); //结果为8，int类型所以一次开辟四个字节，开辟两次。                return 0;            }            ——————————————————————————————————                    struct S                     {                        char a:3;                        char b:4;                        char c:5;                        char d:4;                    };                    int main()                    {                                                   |               |               |               |                        struct S s = {0};                                | | | | | | | | | | | | | | | | | | | | | | | | |                        s.a = 10; //二进制：1010，但是长度只给了3            |  b    |  a  |     |    b    |       |   d   |                        s.b = 20;                        s.c = 3;                        s.d = 4;                        printf(&quot;%d\n&quot;, sizeof(s)); // 类型是char：开辟一个字节放入a，再放入b，此时一个字节被占用了7个比特，剩下的1个比特不足以存放c，所以再开辟一个字节放入5，剩下的3个字节不足以存放d，so再次开辟一个字节。浪费了8比特。                        printf(&quot;%d\n&quot;, s.a);                        return 0;                    }————————————————————————————枚举：    enum Sex    {        MALE,        FAMALE,        SECRET    };    enum Color    {        RED, //0        GREEN, //1        BLUE //2    };    int main(){        enum Sex s = MALE;        enum Color c = BLUE;        printf(&quot;%d,%d,%d\n&quot;, RED,GREEN,BLUE);    }————————————————————————————union:    union Un    {        char c;         int i; //对齐数为4        char arr[5]; //对齐数是1而不是5，最小占用内存为 最大对齐数的整数倍    };    int main()    {        union Un u;        printf(&quot;%lu\n&quot;, sizeof(u));        printf(&quot;%p\n&quot;, &amp;u);        printf(&quot;%p\n&quot;, &amp;u.c);    }————————————————————————————动态内存分配：    _____________________________________    |          局部变量                  |    |          函数形参                  |    |                                   |    |                                   |    |                                   |  栈区    |                                   |    |                                   |    |                                   |    |                                   |    |———————————————————————————————————|    |      动态内存分配                   |    |                                   |    |                                   |    |                                   |    |                                   |    |                                   |    |                                   |  堆区    |                                   |    |                                   |    |                                   |    |                                   |    |                                   |    |                                   |    |———————————————————————————————————|    |                                   |    |        全局变量                    |    |        静态变量                    |    |                                   |    |                                   |    |                                   |  静态区    |                                   |    |                                   |    |                                   |    |                                   |    |                                   |    |                                   |    —————————————————————————————————————            int main()            {            int * p1 = (int *)malloc(10*sizeof(int)); //初始化之后默认值是随机的，int * p = realloc(NULL,40)            if (p1 == NULL)            {                printf(&quot;%s\n&quot;, strerror(errno));            }            else            {                for (int i = 0; i &lt; 10; ++i)                {                    printf(&quot;p1 = %d\n&quot;, p1[i]);                }            }            free(p1);            p1 = NULL;            printf(&quot;\n&quot;);            int * p2 = (int *)calloc(10,sizeof(int));  //初始化之后默认值是0            if (p2 == NULL)            {                printf(&quot;%s\n&quot;, strerror(errno));            }            else            {                for (int i = 0; i &lt; 10; ++i)                {                printf(&quot;p2 = %d\n&quot;, *(p2+i));                }            }            free(p2);            p2 = NULL;            printf(&quot;\n&quot;);            int * p3 = (int *)malloc(20);            if (p3 == NULL)            {                printf(&quot;%s\n&quot;, strerror(errno));            }            else            {                for (int i = 0; i &lt; 5; ++i)                {                    *(p3+i) = i;                }            }            int * p4 = realloc(p3,40); //调整已开辟内存的大小。            // 1、如果p3指向的内存空间后有足够的空间可以追加，则直接追加后返回p3。            // 2、如果p3指向的内存空间后没有足够的空间可以追加，则开辟一块全新的内存区域，将原来内存中的数据拷贝至新内存，释放旧内存空间，返回新开辟的内存空间地址            if (p4!=NULL)            {                p3 = p4;            }            for (int i = 0; i &lt; 40; ++i)            {                printf(&quot;p3 = %d\n&quot;, *(p4+i));            }            free(p3);            p3 = NULL;            return 0;        }*/// #pragma pack(4) //设置默认对齐数// void GetMemory(char **p)// {//     p = (char *)malloc(100);// }// void Test(void)// {//     char * str = NULL;//     GetMemory(&amp;str);//     strcpy(str,&quot;hello world&quot;);//     printf(str);// }// int main()// {//     //str传给GetMemory()函数，传的是str而不是str的地址，所以p是str的值拷贝，p的值为NULL，函数里将申请的内存的地址赋给p，GetMemory执行完毕之后，//     //p是临时变量被销毁，所以str的值还是NULL//     Test();//     return 0;// }// char *GetMemory(void)// {//      char p[] = &quot;hello world&quot;;//     return p;// }// void Test(void)// {//     char * str = NULL;//     str = GetMemory();//     printf(str);// }// int main()// {//     Test();//     return 0;// }int main(){    int a = 10000;    FILE* pf = fopen(&quot;test.txt&quot;,&quot;wb&quot;);    fwrite(&amp;a,4,1,pf);    fclose(pf);    pf = NULL;    return 0;}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt; 
#include &amp;lt;stdlib.h&amp;gt; 
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;st</summary>
      
    
    
    
    <category term="C语言" scheme="http://blog.3amupupup.online/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="c primer plus" scheme="http://blog.3amupupup.online/tags/c-primer-plus/"/>
    
  </entry>
  
</feed>
